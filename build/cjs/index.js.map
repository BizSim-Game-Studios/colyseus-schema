{"version":3,"file":"index.js","sources":["../../src/encoding/spec.ts","../../src/symbol.shim.ts","../../src/types/symbols.ts","../../src/encoding/encode.ts","../../src/encoding/decode.ts","../../src/types/registry.ts","../../src/types/TypeContext.ts","../../src/Metadata.ts","../../src/encoder/ChangeTree.ts","../../src/encoder/EncodeOperation.ts","../../src/decoder/DecodeOperation.ts","../../src/encoding/assert.ts","../../src/types/custom/ArraySchema.ts","../../src/types/custom/MapSchema.ts","../../src/types/custom/CollectionSchema.ts","../../src/types/custom/SetSchema.ts","../../src/annotations.ts","../../src/utils.ts","../../src/Schema.ts","../../node_modules/tslib/tslib.es6.js","../../src/encoder/Root.ts","../../src/encoder/Encoder.ts","../../src/types/utils.ts","../../src/decoder/ReferenceTracker.ts","../../src/decoder/Decoder.ts","../../src/Reflection.ts","../../src/decoder/strategy/StateCallbacks.ts","../../src/decoder/strategy/RawChanges.ts","../../src/encoder/StateView.ts","../../src/index.ts"],"sourcesContent":["export const SWITCH_TO_STRUCTURE = 255; // (decoding collides with DELETE_AND_ADD + fieldIndex = 63)\r\nexport const TYPE_ID = 213;\r\n\r\n/**\r\n * Encoding Schema field operations.\r\n */\r\nexport enum OPERATION {\r\n    ADD = 128,            // (10000000) add new structure/primitive\r\n    REPLACE = 0,          // (00000001) replace structure/primitive\r\n    DELETE = 64,          // (01000000) delete field\r\n    DELETE_AND_MOVE = 96, // () ArraySchema only\r\n    MOVE_AND_ADD = 160,   // () ArraySchema only\r\n    DELETE_AND_ADD = 192, // (11000000) DELETE field, followed by an ADD\r\n\r\n    /**\r\n     * Collection operations\r\n     */\r\n    CLEAR = 10,\r\n\r\n    /**\r\n     * ArraySchema operations\r\n     */\r\n    REVERSE = 15,\r\n    MOVE = 32,\r\n    DELETE_BY_REFID = 33, // This operation is only used at ENCODING time. During DECODING, DELETE_BY_REFID is converted to DELETE\r\n    ADD_BY_REFID = 129,\r\n}\r\n","\r\n//\r\n// Must have Symbol.metadata defined for metadata support on decorators:\r\n// https://github.com/microsoft/TypeScript/issues/55453#issuecomment-1687496648\r\n//\r\nexport {};\r\ndeclare global {\r\n    interface SymbolConstructor {\r\n        readonly metadata: unique symbol;\r\n    }\r\n}\r\n(Symbol as any).metadata ??= Symbol.for(\"Symbol.metadata\");","export const $track = \"~track\";\r\nexport const $encoder = \"~encoder\";\r\nexport const $decoder = \"~decoder\";\r\n\r\nexport const $filter = \"~filter\";\r\n\r\nexport const $getByIndex = \"~getByIndex\";\r\nexport const $deleteByIndex = \"~deleteByIndex\";\r\n\r\n/**\r\n * Used to hold ChangeTree instances whitin the structures\r\n */\r\nexport const $changes = '~changes';\r\n\r\n/**\r\n * Used to keep track of the type of the child elements of a collection\r\n * (MapSchema, ArraySchema, etc.)\r\n */\r\nexport const $childType = '~childType';\r\n\r\n/**\r\n * Optional \"discard\" method for custom types (ArraySchema)\r\n * (Discards changes for next serialization)\r\n */\r\nexport const $onEncodeEnd = '~onEncodeEnd';\r\n\r\n/**\r\n * When decoding, this method is called after the instance is fully decoded\r\n */\r\nexport const $onDecodeEnd = \"~onDecodeEnd\";\r\n\r\n/**\r\n * Metadata\r\n */\r\nexport const $descriptors = \"~descriptors\";\r\nexport const $numFields = \"~__numFields\";\r\nexport const $refTypeFieldIndexes = \"~__refTypeFieldIndexes\";\r\nexport const $viewFieldIndexes = \"~__viewFieldIndexes\";\r\nexport const $fieldIndexesByViewTag = \"$__fieldIndexesByViewTag\";","// @ts-nocheck\r\n\r\n/**\r\n * Copyright (c) 2018 Endel Dreyer\r\n * Copyright (c) 2014 Ion Drive Software Ltd.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in all\r\n * copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n * SOFTWARE\r\n */\r\n\r\nimport type { TextEncoder } from \"util\";\r\nimport type { Iterator } from \"./decode\";\r\n\r\nexport type BufferLike = number[] | ArrayBufferLike | Buffer;\r\n\r\n/**\r\n * msgpack implementation highly based on notepack.io\r\n * https://github.com/darrachequesne/notepack\r\n */\r\n\r\nlet textEncoder: TextEncoder;\r\n// @ts-ignore\r\ntry { textEncoder = new TextEncoder(); } catch (e) { }\r\n\r\n// force little endian to facilitate decoding on multiple implementations\r\nconst _isLittleEndian = true;  // new Uint16Array(new Uint8Array([1, 0]).buffer)[0] === 1;\r\nconst _convoBuffer = new ArrayBuffer(8);\r\nconst _int32 = new Int32Array(_convoBuffer);\r\nconst _float32 = new Float32Array(_convoBuffer);\r\nconst _float64 = new Float64Array(_convoBuffer);\r\nconst _int64 = new BigInt64Array(_convoBuffer);\r\n\r\nconst hasBufferByteLength = (typeof Buffer !== 'undefined' && Buffer.byteLength);\r\n\r\nconst utf8Length: (str: string, _?: any) => number = (hasBufferByteLength)\r\n    ? Buffer.byteLength // node\r\n    : function (str: string, _?: any) {\r\n        var c = 0, length = 0;\r\n        for (var i = 0, l = str.length; i < l; i++) {\r\n            c = str.charCodeAt(i);\r\n            if (c < 0x80) {\r\n                length += 1;\r\n            }\r\n            else if (c < 0x800) {\r\n                length += 2;\r\n            }\r\n            else if (c < 0xd800 || c >= 0xe000) {\r\n                length += 3;\r\n            }\r\n            else {\r\n                i++;\r\n                length += 4;\r\n            }\r\n        }\r\n        return length;\r\n    }\r\n\r\nfunction utf8Write(view: BufferLike, str: string, it: Iterator) {\r\n  var c = 0;\r\n  for (var i = 0, l = str.length; i < l; i++) {\r\n    c = str.charCodeAt(i);\r\n    if (c < 0x80) {\r\n      view[it.offset++] = c;\r\n    }\r\n    else if (c < 0x800) {\r\n      view[it.offset] = 0xc0 | (c >> 6);\r\n      view[it.offset + 1] = 0x80 | (c & 0x3f);\r\n      it.offset += 2;\r\n    }\r\n    else if (c < 0xd800 || c >= 0xe000) {\r\n      view[it.offset] = 0xe0 | (c >> 12);\r\n      view[it.offset+1] = 0x80 | (c >> 6 & 0x3f);\r\n      view[it.offset+2] = 0x80 | (c & 0x3f);\r\n      it.offset += 3;\r\n    }\r\n    else {\r\n      i++;\r\n      c = 0x10000 + (((c & 0x3ff) << 10) | (str.charCodeAt(i) & 0x3ff));\r\n      view[it.offset] = 0xf0 | (c >> 18);\r\n      view[it.offset+1] = 0x80 | (c >> 12 & 0x3f);\r\n      view[it.offset+2] = 0x80 | (c >> 6 & 0x3f);\r\n      view[it.offset+3] = 0x80 | (c & 0x3f);\r\n      it.offset += 4;\r\n    }\r\n  }\r\n}\r\n\r\nfunction int8(bytes: BufferLike, value: number, it: Iterator) {\r\n    bytes[it.offset++] = value & 255;\r\n};\r\n\r\nfunction uint8(bytes: BufferLike, value: number, it: Iterator) {\r\n    bytes[it.offset++] = value & 255;\r\n};\r\n\r\nfunction int16(bytes: BufferLike, value: number, it: Iterator) {\r\n    bytes[it.offset++] = value & 255;\r\n    bytes[it.offset++] = (value >> 8) & 255;\r\n};\r\n\r\nfunction uint16(bytes: BufferLike, value: number, it: Iterator) {\r\n    bytes[it.offset++] = value & 255;\r\n    bytes[it.offset++] = (value >> 8) & 255;\r\n};\r\n\r\nfunction int32(bytes: BufferLike, value: number, it: Iterator) {\r\n  bytes[it.offset++] = value & 255;\r\n  bytes[it.offset++] = (value >> 8) & 255;\r\n  bytes[it.offset++] = (value >> 16) & 255;\r\n  bytes[it.offset++] = (value >> 24) & 255;\r\n};\r\n\r\nfunction uint32(bytes: BufferLike, value: number, it: Iterator) {\r\n  const b4 = value >> 24;\r\n  const b3 = value >> 16;\r\n  const b2 = value >> 8;\r\n  const b1 = value;\r\n  bytes[it.offset++] = b1 & 255;\r\n  bytes[it.offset++] = b2 & 255;\r\n  bytes[it.offset++] = b3 & 255;\r\n  bytes[it.offset++] = b4 & 255;\r\n};\r\n\r\nfunction int64(bytes: BufferLike, value: number, it: Iterator) {\r\n  const high = Math.floor(value / Math.pow(2, 32));\r\n  const low = value >>> 0;\r\n  uint32(bytes, low, it);\r\n  uint32(bytes, high, it);\r\n};\r\n\r\nfunction uint64(bytes: BufferLike, value: number, it: Iterator) {\r\n  const high = (value / Math.pow(2, 32)) >> 0;\r\n  const low = value >>> 0;\r\n  uint32(bytes, low, it);\r\n  uint32(bytes, high, it);\r\n};\r\n\r\nfunction bigint64(bytes: BufferLike, value: bigint, it: Iterator) {\r\n    _int64[0] = BigInt.asIntN(64, value);\r\n    int32(bytes, _int32[0], it);\r\n    int32(bytes, _int32[1], it);\r\n}\r\n\r\nfunction biguint64(bytes: BufferLike, value: bigint, it: Iterator) {\r\n    _int64[0] = BigInt.asIntN(64, value);\r\n    int32(bytes, _int32[0], it);\r\n    int32(bytes, _int32[1], it);\r\n}\r\n\r\nfunction float32(bytes: BufferLike, value: number, it: Iterator) {\r\n  _float32[0] = value;\r\n  int32(bytes, _int32[0], it);\r\n}\r\n\r\nfunction float64(bytes: BufferLike, value: number, it: Iterator) {\r\n  _float64[0] = value;\r\n  int32(bytes, _int32[_isLittleEndian ? 0 : 1], it);\r\n  int32(bytes, _int32[_isLittleEndian ? 1 : 0], it);\r\n}\r\n\r\nfunction boolean(bytes: BufferLike, value: number, it: Iterator) {\r\n  bytes[it.offset++] = value ? 1 : 0; // uint8\r\n};\r\n\r\nfunction string(bytes: BufferLike, value: string, it: Iterator) {\r\n  // encode `null` strings as empty.\r\n  if (!value) { value = \"\"; }\r\n\r\n  let length = utf8Length(value, \"utf8\");\r\n  let size = 0;\r\n\r\n  // fixstr\r\n  if (length < 0x20) {\r\n    bytes[it.offset++] = length | 0xa0;\r\n    size = 1;\r\n  }\r\n  // str 8\r\n  else if (length < 0x100) {\r\n    bytes[it.offset++] = 0xd9;\r\n    bytes[it.offset++] = length % 255;\r\n    size = 2;\r\n  }\r\n  // str 16\r\n  else if (length < 0x10000) {\r\n    bytes[it.offset++] = 0xda;\r\n    uint16(bytes, length, it);\r\n    size = 3;\r\n  }\r\n  // str 32\r\n  else if (length < 0x100000000) {\r\n    bytes[it.offset++] = 0xdb;\r\n    uint32(bytes, length, it);\r\n    size = 5;\r\n  } else {\r\n    throw new Error('String too long');\r\n  }\r\n\r\n  utf8Write(bytes, value, it);\r\n\r\n  return size + length;\r\n}\r\n\r\nfunction number(bytes: BufferLike, value: number, it: Iterator) {\r\n  if (isNaN(value)) {\r\n    return number(bytes, 0, it);\r\n\r\n  } else if (!isFinite(value)) {\r\n    return number(bytes, (value > 0) ? Number.MAX_SAFE_INTEGER : -Number.MAX_SAFE_INTEGER, it);\r\n\r\n  } else if (value !== (value|0)) {\r\n    if (Math.abs(value) <= 3.4028235e+38) { // range check\r\n        _float32[0] = value;\r\n        if (Math.abs(Math.abs(_float32[0]) - Math.abs(value)) < 1e-4) { // precision check; adjust 1e-n (n = precision) to in-/decrease acceptable precision loss\r\n            // now we know value is in range for f32 and has acceptable precision for f32\r\n            bytes[it.offset++] = 0xca;\r\n            float32(bytes, value, it);\r\n            return 5;\r\n        }\r\n    }\r\n\r\n    bytes[it.offset++] = 0xcb;\r\n    float64(bytes, value, it);\r\n    return 9;\r\n  }\r\n\r\n  if (value >= 0) {\r\n    // positive fixnum\r\n    if (value < 0x80) {\r\n      bytes[it.offset++] = value & 255; // uint8\r\n      return 1;\r\n    }\r\n\r\n    // uint 8\r\n    if (value < 0x100) {\r\n      bytes[it.offset++] = 0xcc;\r\n      bytes[it.offset++] = value & 255; // uint8\r\n      return 2;\r\n    }\r\n\r\n    // uint 16\r\n    if (value < 0x10000) {\r\n      bytes[it.offset++] = 0xcd;\r\n      uint16(bytes, value, it);\r\n      return 3;\r\n    }\r\n\r\n    // uint 32\r\n    if (value < 0x100000000) {\r\n      bytes[it.offset++] = 0xce;\r\n      uint32(bytes, value, it);\r\n      return 5;\r\n    }\r\n\r\n    // uint 64\r\n    bytes[it.offset++] = 0xcf;\r\n    uint64(bytes, value, it);\r\n    return 9;\r\n\r\n  } else {\r\n\r\n    // negative fixnum\r\n    if (value >= -0x20) {\r\n      bytes[it.offset++] = 0xe0 | (value + 0x20);\r\n      return 1;\r\n    }\r\n\r\n    // int 8\r\n    if (value >= -0x80) {\r\n      bytes[it.offset++] = 0xd0;\r\n      int8(bytes, value, it);\r\n      return 2;\r\n    }\r\n\r\n    // int 16\r\n    if (value >= -0x8000) {\r\n      bytes[it.offset++] = 0xd1;\r\n      int16(bytes, value, it);\r\n      return 3;\r\n    }\r\n\r\n    // int 32\r\n    if (value >= -0x80000000) {\r\n      bytes[it.offset++] = 0xd2;\r\n      int32(bytes, value, it);\r\n      return 5;\r\n    }\r\n\r\n    // int 64\r\n    bytes[it.offset++] = 0xd3;\r\n    int64(bytes, value, it);\r\n    return 9;\r\n  }\r\n}\r\n\r\nexport const encode = {\r\n    int8,\r\n    uint8,\r\n    int16,\r\n    uint16,\r\n    int32,\r\n    uint32,\r\n    int64,\r\n    uint64,\r\n    bigint64,\r\n    biguint64,\r\n    float32,\r\n    float64,\r\n    boolean,\r\n    string,\r\n    number,\r\n    utf8Write,\r\n    utf8Length,\r\n}","// @ts-nocheck\r\n\r\n/**\r\n * Copyright (c) 2018 Endel Dreyer\r\n * Copyright (c) 2014 Ion Drive Software Ltd.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in all\r\n * copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n * SOFTWARE\r\n */\r\n\r\nimport type { BufferLike } from \"./encode\";\r\n\r\n/**\r\n * msgpack implementation highly based on notepack.io\r\n * https://github.com/darrachequesne/notepack\r\n */\r\n\r\nexport interface Iterator { offset: number; }\r\n\r\n// force little endian to facilitate decoding on multiple implementations\r\nconst _isLittleEndian = true;  // new Uint16Array(new Uint8Array([1, 0]).buffer)[0] === 1;\r\nconst _convoBuffer = new ArrayBuffer(8);\r\n\r\nconst _int32 = new Int32Array(_convoBuffer);\r\nconst _float32 = new Float32Array(_convoBuffer);\r\nconst _float64 = new Float64Array(_convoBuffer);\r\nconst _uint64 = new BigUint64Array(_convoBuffer);\r\nconst _int64 = new BigInt64Array(_convoBuffer);\r\n\r\nfunction utf8Read(bytes: BufferLike, it: Iterator, length: number) {\r\n  // boundary check\r\n  if (length > bytes.length - it.offset) { length = bytes.length - it.offset; }\r\n\r\n  var string = '', chr = 0;\r\n  for (var i = it.offset, end = it.offset + length; i < end; i++) {\r\n    var byte = bytes[i];\r\n    if ((byte & 0x80) === 0x00) {\r\n      string += String.fromCharCode(byte);\r\n      continue;\r\n    }\r\n    if ((byte & 0xe0) === 0xc0) {\r\n      string += String.fromCharCode(\r\n        ((byte & 0x1f) << 6) |\r\n        (bytes[++i] & 0x3f)\r\n      );\r\n      continue;\r\n    }\r\n    if ((byte & 0xf0) === 0xe0) {\r\n      string += String.fromCharCode(\r\n        ((byte & 0x0f) << 12) |\r\n        ((bytes[++i] & 0x3f) << 6) |\r\n        ((bytes[++i] & 0x3f) << 0)\r\n      );\r\n      continue;\r\n    }\r\n    if ((byte & 0xf8) === 0xf0) {\r\n      chr = ((byte & 0x07) << 18) |\r\n        ((bytes[++i] & 0x3f) << 12) |\r\n        ((bytes[++i] & 0x3f) << 6) |\r\n        ((bytes[++i] & 0x3f) << 0);\r\n      if (chr >= 0x010000) { // surrogate pair\r\n        chr -= 0x010000;\r\n        string += String.fromCharCode((chr >>> 10) + 0xD800, (chr & 0x3FF) + 0xDC00);\r\n      } else {\r\n        string += String.fromCharCode(chr);\r\n      }\r\n      continue;\r\n    }\r\n\r\n    // (do not throw error to avoid server/client from crashing due to hack attemps)\r\n    // throw new Error('Invalid byte ' + byte.toString(16));\r\n\r\n    console.error('decode.utf8Read(): Invalid byte ' + byte + ' at offset ' + i + '. Skip to end of string: ' + (it.offset + length));\r\n    break;\r\n  }\r\n  it.offset += length;\r\n  return string;\r\n}\r\n\r\nfunction int8 (bytes: BufferLike, it: Iterator) {\r\n    return uint8(bytes, it) << 24 >> 24;\r\n};\r\n\r\nfunction uint8 (bytes: BufferLike, it: Iterator) {\r\n    return bytes[it.offset++];\r\n};\r\n\r\nfunction int16 (bytes: BufferLike, it: Iterator) {\r\n    return uint16(bytes, it) << 16 >> 16;\r\n};\r\n\r\nfunction uint16 (bytes: BufferLike, it: Iterator) {\r\n    return bytes[it.offset++] | bytes[it.offset++] << 8;\r\n};\r\n\r\nfunction int32 (bytes: BufferLike, it: Iterator) {\r\n    return bytes[it.offset++] | bytes[it.offset++] << 8 | bytes[it.offset++] << 16 | bytes[it.offset++] << 24;\r\n};\r\n\r\nfunction uint32 (bytes: BufferLike, it: Iterator) {\r\n    return int32(bytes, it) >>> 0;\r\n};\r\n\r\nfunction float32 (bytes: BufferLike, it: Iterator) {\r\n    _int32[0] = int32(bytes, it);\r\n    return _float32[0];\r\n};\r\n\r\nfunction float64 (bytes: BufferLike, it: Iterator) {\r\n    _int32[_isLittleEndian ? 0 : 1] = int32(bytes, it);\r\n    _int32[_isLittleEndian ? 1 : 0] = int32(bytes, it);\r\n    return _float64[0];\r\n};\r\n\r\nfunction int64(bytes: BufferLike, it: Iterator) {\r\n  const low = uint32(bytes, it);\r\n  const high = int32(bytes, it) * Math.pow(2, 32);\r\n  return high + low;\r\n};\r\n\r\nfunction uint64(bytes: BufferLike, it: Iterator) {\r\n    const low = uint32(bytes, it);\r\n    const high = uint32(bytes, it) * Math.pow(2, 32);\r\n    return high + low;\r\n};\r\n\r\nfunction bigint64(bytes: BufferLike, it: Iterator) {\r\n    _int32[0] = int32(bytes, it);\r\n    _int32[1] = int32(bytes, it);\r\n    return _int64[0];\r\n}\r\n\r\nfunction biguint64(bytes: BufferLike, it: Iterator) {\r\n    _int32[0] = int32(bytes, it);\r\n    _int32[1] = int32(bytes, it);\r\n    return _uint64[0];\r\n}\r\n\r\nfunction boolean (bytes: BufferLike, it: Iterator) {\r\n    return uint8(bytes, it) > 0;\r\n};\r\n\r\nfunction string (bytes: BufferLike, it: Iterator) {\r\n  const prefix = bytes[it.offset++];\r\n  let length: number;\r\n\r\n  if (prefix < 0xc0) {\r\n    // fixstr\r\n    length = prefix & 0x1f;\r\n\r\n  } else if (prefix === 0xd9) {\r\n    length = uint8(bytes, it);\r\n\r\n  } else if (prefix === 0xda) {\r\n    length = uint16(bytes, it);\r\n\r\n  } else if (prefix === 0xdb) {\r\n    length = uint32(bytes, it);\r\n  }\r\n\r\n  return utf8Read(bytes, it, length);\r\n}\r\n\r\nfunction number (bytes: BufferLike, it: Iterator) {\r\n  const prefix = bytes[it.offset++];\r\n\r\n  if (prefix < 0x80) {\r\n    // positive fixint\r\n    return prefix;\r\n\r\n  } else if (prefix === 0xca) {\r\n    // float 32\r\n    return float32(bytes, it);\r\n\r\n  } else if (prefix === 0xcb) {\r\n    // float 64\r\n    return float64(bytes, it);\r\n\r\n  } else if (prefix === 0xcc) {\r\n    // uint 8\r\n    return uint8(bytes, it);\r\n\r\n  } else if (prefix === 0xcd) {\r\n    // uint 16\r\n    return uint16(bytes, it);\r\n\r\n  } else if (prefix === 0xce) {\r\n    // uint 32\r\n    return uint32(bytes, it);\r\n\r\n  } else if (prefix === 0xcf) {\r\n    // uint 64\r\n    return uint64(bytes, it);\r\n\r\n  } else if (prefix === 0xd0) {\r\n    // int 8\r\n    return int8(bytes, it);\r\n\r\n  } else if (prefix === 0xd1) {\r\n    // int 16\r\n    return int16(bytes, it);\r\n\r\n  } else if (prefix === 0xd2) {\r\n    // int 32\r\n    return int32(bytes, it);\r\n\r\n  } else if (prefix === 0xd3) {\r\n    // int 64\r\n    return int64(bytes, it);\r\n\r\n  } else if (prefix > 0xdf) {\r\n    // negative fixint\r\n    return (0xff - prefix + 1) * -1\r\n  }\r\n};\r\n\r\nexport function stringCheck(bytes: BufferLike, it: Iterator) {\r\n  const prefix = bytes[it.offset];\r\n  return (\r\n    // fixstr\r\n    (prefix < 0xc0 && prefix > 0xa0) ||\r\n    // str 8\r\n    prefix === 0xd9 ||\r\n    // str 16\r\n    prefix === 0xda ||\r\n    // str 32\r\n    prefix === 0xdb\r\n  );\r\n}\r\n\r\nexport const decode = {\r\n    utf8Read,\r\n    int8,\r\n    uint8,\r\n    int16,\r\n    uint16,\r\n    int32,\r\n    uint32,\r\n    float32,\r\n    float64,\r\n    int64,\r\n    uint64,\r\n    bigint64,\r\n    biguint64,\r\n    boolean,\r\n    string,\r\n    number,\r\n    stringCheck,\r\n};","import { DefinitionType, type } from \"../annotations\";\r\nimport { BufferLike, encode } from \"../encoding/encode\";\r\nimport { decode, Iterator } from \"../encoding/decode\";\r\n\r\nexport interface TypeDefinition {\r\n    constructor?: any,\r\n    encode?: (bytes: BufferLike, value: any, it: Iterator) => any;\r\n    decode?: (bytes: BufferLike, it: Iterator) => any;\r\n}\r\n\r\nexport const registeredTypes: {[identifier: string] : TypeDefinition} = {};\r\n\r\nconst identifiers = new Map<any, string>();\r\n\r\nexport function registerType(identifier: string, definition: TypeDefinition) {\r\n    if (definition.constructor) {\r\n        identifiers.set(definition.constructor, identifier);\r\n        registeredTypes[identifier] = definition;\r\n    }\r\n\r\n    if (definition.encode) { (encode as any)[identifier] = definition.encode; }\r\n    if (definition.decode) { (decode as any)[identifier] = definition.decode; }\r\n}\r\n\r\nexport function getIdentifier(klass: any): string {\r\n    return identifiers.get(klass);\r\n}\r\n\r\nexport function getType(identifier: string): TypeDefinition {\r\n    return registeredTypes[identifier];\r\n}\r\n\r\nexport function defineCustomTypes<T extends {[key: string]: TypeDefinition}>(types: T) {\r\n    for (const identifier in types) {\r\n        registerType(identifier, types[identifier]);\r\n    }\r\n\r\n    return (t: keyof T) => type(t as DefinitionType);\r\n}","import { Metadata } from \"../Metadata\";\r\nimport { Schema } from \"../Schema\";\r\nimport { $viewFieldIndexes } from \"./symbols\";\r\n\r\nexport class TypeContext {\r\n    types: { [id: number]: typeof Schema; } = {};\r\n    schemas = new Map<typeof Schema, number>();\r\n\r\n    hasFilters: boolean = false;\r\n    parentFiltered: {[typeIdAndParentIndex: string]: boolean} = {};\r\n\r\n    /**\r\n     * For inheritance support\r\n     * Keeps track of which classes extends which. (parent -> children)\r\n     */\r\n    static inheritedTypes = new Map<typeof Schema, Set<typeof Schema>>();\r\n    static cachedContexts = new Map<typeof Schema, TypeContext>();\r\n\r\n    static register(target: typeof Schema) {\r\n        const parent = Object.getPrototypeOf(target);\r\n        if (parent !== Schema) {\r\n            let inherits = TypeContext.inheritedTypes.get(parent);\r\n            if (!inherits) {\r\n                inherits = new Set<typeof Schema>();\r\n                TypeContext.inheritedTypes.set(parent, inherits);\r\n            }\r\n            inherits.add(target);\r\n        }\r\n    }\r\n\r\n    static cache (rootClass: typeof Schema) {\r\n        let context = TypeContext.cachedContexts.get(rootClass);\r\n        if (!context) {\r\n            context = new TypeContext(rootClass);\r\n            TypeContext.cachedContexts.set(rootClass, context);\r\n        }\r\n        return context;\r\n    }\r\n\r\n    constructor(rootClass?: typeof Schema) {\r\n        if (rootClass) {\r\n            this.discoverTypes(rootClass);\r\n        }\r\n    }\r\n\r\n    has(schema: typeof Schema) {\r\n        return this.schemas.has(schema);\r\n    }\r\n\r\n    get(typeid: number) {\r\n        return this.types[typeid];\r\n    }\r\n\r\n    add(schema: typeof Schema, typeid = this.schemas.size) {\r\n        // skip if already registered\r\n        if (this.schemas.has(schema)) {\r\n            return false;\r\n        }\r\n\r\n        this.types[typeid] = schema;\r\n\r\n        //\r\n        // Workaround to allow using an empty Schema (with no `@type()` fields)\r\n        //\r\n        if (schema[Symbol.metadata] === undefined) {\r\n            Metadata.initialize(schema);\r\n        }\r\n\r\n        this.schemas.set(schema, typeid);\r\n        return true;\r\n    }\r\n\r\n    getTypeId(klass: typeof Schema) {\r\n        return this.schemas.get(klass);\r\n    }\r\n\r\n    private discoverTypes(klass: typeof Schema, parentType?: typeof Schema, parentIndex?: number, parentHasViewTag?: boolean) {\r\n        if (parentHasViewTag) {\r\n            this.registerFilteredByParent(klass, parentType, parentIndex);\r\n        }\r\n\r\n        // skip if already registered\r\n        if (!this.add(klass)) { return; }\r\n\r\n        // add classes inherited from this base class\r\n        TypeContext.inheritedTypes.get(klass)?.forEach((child) => {\r\n            this.discoverTypes(child, parentType, parentIndex, parentHasViewTag);\r\n        });\r\n\r\n        // add parent classes\r\n        let parent: any = klass;\r\n        while (\r\n            (parent = Object.getPrototypeOf(parent)) &&\r\n            parent !== Schema && // stop at root (Schema)\r\n            parent !== Function.prototype // stop at root (non-Schema)\r\n        ) {\r\n            this.discoverTypes(parent);\r\n        }\r\n\r\n        const metadata: Metadata = (klass[Symbol.metadata] ??= {} as Metadata);\r\n\r\n        // if any schema/field has filters, mark \"context\" as having filters.\r\n        if (metadata[$viewFieldIndexes]) {\r\n            this.hasFilters = true;\r\n        }\r\n\r\n        for (const fieldIndex in metadata) {\r\n            const index = fieldIndex as any as number;\r\n\r\n            const fieldType = metadata[index].type;\r\n            const fieldHasViewTag = (metadata[index].tag !== undefined);\r\n\r\n            if (typeof (fieldType) === \"string\") {\r\n                continue;\r\n            }\r\n\r\n            if (typeof (fieldType) === \"function\") {\r\n                this.discoverTypes(fieldType as typeof Schema, klass, index, parentHasViewTag || fieldHasViewTag);\r\n\r\n            } else {\r\n                const type = Object.values(fieldType)[0];\r\n\r\n                // skip primitive types\r\n                if (typeof (type) === \"string\") {\r\n                    continue;\r\n                }\r\n\r\n                this.discoverTypes(type as typeof Schema, klass, index, parentHasViewTag || fieldHasViewTag);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Keep track of which classes have filters applied.\r\n     * Format: `${typeid}-${parentTypeid}-${parentIndex}`\r\n     */\r\n    private registerFilteredByParent(schema: typeof Schema, parentType?: typeof Schema, parentIndex?: number) {\r\n        const typeid = this.schemas.get(schema) ?? this.schemas.size;\r\n\r\n        let key = `${typeid}`;\r\n        if (parentType) { key += `-${this.schemas.get(parentType)}`; }\r\n\r\n        key += `-${parentIndex}`;\r\n        this.parentFiltered[key] = true;\r\n    }\r\n\r\n    debug() {\r\n        let parentFiltered = \"\";\r\n\r\n        for (const key in this.parentFiltered) {\r\n            const keys: number[] = key.split(\"-\").map(Number);\r\n            const fieldIndex = keys.pop();\r\n\r\n            parentFiltered += `\\n\\t\\t`;\r\n            parentFiltered += `${key}: ${keys.reverse().map((id, i) => {\r\n                const klass = this.types[id];\r\n                const metadata: Metadata = klass[Symbol.metadata];\r\n                let txt = klass.name;\r\n                if (i === 0) { txt += `[${metadata[fieldIndex].name}]`; }\r\n                return `${txt}`;\r\n            }).join(\" -> \")}`;\r\n        }\r\n\r\n        return `TypeContext ->\\n` +\r\n            `\\tSchema types: ${this.schemas.size}\\n` +\r\n            `\\thasFilters: ${this.hasFilters}\\n` +\r\n            `\\tparentFiltered:${parentFiltered}`;\r\n    }\r\n\r\n}\r\n","import { DefinitionType, getPropertyDescriptor } from \"./annotations\";\r\nimport { Schema } from \"./Schema\";\r\nimport { getType, registeredTypes } from \"./types/registry\";\r\nimport { $decoder, $descriptors, $encoder, $fieldIndexesByViewTag, $numFields, $refTypeFieldIndexes, $track, $viewFieldIndexes } from \"./types/symbols\";\r\nimport { TypeContext } from \"./types/TypeContext\";\r\n\r\nexport type MetadataField = {\r\n    type: DefinitionType,\r\n    name: string,\r\n    index: number,\r\n    tag?: number,\r\n    unreliable?: boolean,\r\n    deprecated?: boolean,\r\n};\r\n\r\nexport type Metadata =\r\n    { [$numFields]: number; } & // number of fields\r\n    { [$viewFieldIndexes]: number[]; } & // all field indexes with \"view\" tag\r\n    { [$fieldIndexesByViewTag]: {[tag: number]: number[]}; } & // field indexes by \"view\" tag\r\n    { [$refTypeFieldIndexes]: number[]; } & // all field indexes containing Ref types (Schema, ArraySchema, MapSchema, etc)\r\n    { [field: number]: MetadataField; } & // index => field name\r\n    { [field: string]: number; } & // field name => field metadata\r\n    { [$descriptors]: { [field: string]: PropertyDescriptor } }  // property descriptors\r\n\r\nexport function getNormalizedType(type: any): DefinitionType  {\r\n    if (Array.isArray(type)) {\r\n        return { array: getNormalizedType(type[0]) };\r\n\r\n    } else if (typeof (type['type']) !== \"undefined\") {\r\n        return type['type'];\r\n\r\n    } else if (isTSEnum(type)) {\r\n        // Detect TS Enum type (either string or number)\r\n        return Object.keys(type).every(key => typeof type[key] === \"string\")\r\n            ? \"string\"\r\n            : \"number\";\r\n\r\n    } else if (typeof type === \"object\" && type !== null) {\r\n        // Handle collection types\r\n        const collectionType = Object.keys(type).find(k => registeredTypes[k] !== undefined);\r\n        if (collectionType) {\r\n            type[collectionType] = getNormalizedType(type[collectionType]);\r\n            return type;\r\n        }\r\n    }\r\n    return type;\r\n}\r\n\r\nfunction isTSEnum(_enum: any) {\r\n    if (typeof _enum === 'function' && _enum[Symbol.metadata]) {\r\n        return false;\r\n    }\r\n\r\n    const keys = Object.keys(_enum);\r\n    const numericFields = keys.filter(k => /\\d+/.test(k));\r\n\r\n    // Check for number enum (has numeric keys and reverse mapping)\r\n    if (numericFields.length > 0 && numericFields.length === (keys.length / 2) && _enum[_enum[numericFields[0]]] == numericFields[0]) {\r\n        return true;\r\n    }\r\n\r\n    // Check for string enum (all values are strings and keys match values)\r\n    if (keys.length > 0 && keys.every(key => typeof _enum[key] === 'string' && _enum[key] === key)) {\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\nexport const Metadata = {\r\n\r\n    addField(metadata: any, index: number, name: string, type: DefinitionType, descriptor?: PropertyDescriptor) {\r\n        if (index > 64) {\r\n            throw new Error(`Can't define field '${name}'.\\nSchema instances may only have up to 64 fields.`);\r\n        }\r\n\r\n        metadata[index] = Object.assign(\r\n            metadata[index] || {}, // avoid overwriting previous field metadata (@owned / @deprecated)\r\n            {\r\n                type: getNormalizedType(type),\r\n                index,\r\n                name,\r\n            }\r\n        );\r\n\r\n        // create \"descriptors\" map\r\n        Object.defineProperty(metadata, $descriptors, {\r\n            value: metadata[$descriptors] || {},\r\n            enumerable: false,\r\n            configurable: true,\r\n        });\r\n\r\n        if (descriptor) {\r\n            // for encoder\r\n            metadata[$descriptors][name] = descriptor;\r\n            metadata[$descriptors][`_${name}`] = {\r\n                value: undefined,\r\n                writable: true,\r\n                enumerable: false,\r\n                configurable: true,\r\n            };\r\n        } else {\r\n            // for decoder\r\n            metadata[$descriptors][name] = {\r\n                value: undefined,\r\n                writable: true,\r\n                enumerable: true,\r\n                configurable: true,\r\n            };\r\n        }\r\n\r\n        // map -1 as last field index\r\n        Object.defineProperty(metadata, $numFields, {\r\n            value: index,\r\n            enumerable: false,\r\n            configurable: true\r\n        });\r\n\r\n        // map field name => index (non enumerable)\r\n        Object.defineProperty(metadata, name, {\r\n            value: index,\r\n            enumerable: false,\r\n            configurable: true,\r\n        });\r\n\r\n        // if child Ref/complex type, add to -4\r\n        if (typeof (metadata[index].type) !== \"string\") {\r\n            if (metadata[$refTypeFieldIndexes] === undefined) {\r\n                Object.defineProperty(metadata, $refTypeFieldIndexes, {\r\n                    value: [],\r\n                    enumerable: false,\r\n                    configurable: true,\r\n                });\r\n            }\r\n            metadata[$refTypeFieldIndexes].push(index);\r\n        }\r\n    },\r\n\r\n    setTag(metadata: Metadata, fieldName: string, tag: number) {\r\n        const index = metadata[fieldName];\r\n        const field = metadata[index];\r\n\r\n        // add 'tag' to the field\r\n        field.tag = tag;\r\n\r\n        if (!metadata[$viewFieldIndexes]) {\r\n            // -2: all field indexes with \"view\" tag\r\n            Object.defineProperty(metadata, $viewFieldIndexes, {\r\n                value: [],\r\n                enumerable: false,\r\n                configurable: true\r\n            });\r\n\r\n            // -3: field indexes by \"view\" tag\r\n            Object.defineProperty(metadata, $fieldIndexesByViewTag, {\r\n                value: {},\r\n                enumerable: false,\r\n                configurable: true\r\n            });\r\n        }\r\n\r\n        metadata[$viewFieldIndexes].push(index);\r\n\r\n        if (!metadata[$fieldIndexesByViewTag][tag]) {\r\n            metadata[$fieldIndexesByViewTag][tag] = [];\r\n        }\r\n\r\n        metadata[$fieldIndexesByViewTag][tag].push(index);\r\n    },\r\n\r\n    setFields<T extends { new (...args: any[]): InstanceType<T> } = any>(target: T, fields: { [field in keyof InstanceType<T>]?: DefinitionType }) {\r\n        // for inheritance support\r\n        const constructor = target.prototype.constructor;\r\n        TypeContext.register(constructor);\r\n\r\n        const parentClass = Object.getPrototypeOf(constructor);\r\n        const parentMetadata = parentClass && parentClass[Symbol.metadata];\r\n        const metadata = Metadata.initialize(constructor);\r\n\r\n        // Use Schema's methods if not defined in the class\r\n        if (!constructor[$track]) { constructor[$track] = Schema[$track]; }\r\n        if (!constructor[$encoder]) { constructor[$encoder] = Schema[$encoder]; }\r\n        if (!constructor[$decoder]) { constructor[$decoder] = Schema[$decoder]; }\r\n        if (!constructor.prototype.toJSON) { constructor.prototype.toJSON = Schema.prototype.toJSON; }\r\n\r\n        //\r\n        // detect index for this field, considering inheritance\r\n        //\r\n        let fieldIndex = metadata[$numFields] // current structure already has fields defined\r\n            ?? (parentMetadata && parentMetadata[$numFields]) // parent structure has fields defined\r\n            ?? -1; // no fields defined\r\n\r\n        fieldIndex++;\r\n\r\n        for (const field in fields) {\r\n            const type = getNormalizedType(fields[field]);\r\n\r\n            // FIXME: this code is duplicated from @type() annotation\r\n            const complexTypeKlass = typeof(Object.keys(type)[0]) === \"string\" && getType(Object.keys(type)[0]);\r\n\r\n            const childType = (complexTypeKlass)\r\n                ? Object.values(type)[0]\r\n                : type;\r\n\r\n            Metadata.addField(\r\n                metadata,\r\n                fieldIndex,\r\n                field,\r\n                type,\r\n                getPropertyDescriptor(`_${field}`, fieldIndex, childType, complexTypeKlass)\r\n            );\r\n\r\n            fieldIndex++;\r\n        }\r\n\r\n        return target;\r\n    },\r\n\r\n    isDeprecated(metadata: any, field: string) {\r\n        return metadata[field].deprecated === true;\r\n    },\r\n\r\n    init(klass: any) {\r\n        //\r\n        // Used only to initialize an empty Schema (Encoder#constructor)\r\n        // TODO: remove/refactor this...\r\n        //\r\n        const metadata = {};\r\n        klass[Symbol.metadata] = metadata;\r\n        Object.defineProperty(metadata, $numFields, {\r\n            value: 0,\r\n            enumerable: false,\r\n            configurable: true,\r\n        });\r\n    },\r\n\r\n    initialize(constructor: any) {\r\n        const parentClass = Object.getPrototypeOf(constructor);\r\n        const parentMetadata: Metadata = parentClass[Symbol.metadata];\r\n\r\n        let metadata: Metadata = constructor[Symbol.metadata] ?? Object.create(null);\r\n\r\n        // make sure inherited classes have their own metadata object.\r\n        if (parentClass !== Schema && metadata === parentMetadata) {\r\n            metadata = Object.create(null);\r\n\r\n            if (parentMetadata) {\r\n                //\r\n                // assign parent metadata to current\r\n                //\r\n                Object.setPrototypeOf(metadata, parentMetadata);\r\n\r\n                // $numFields\r\n                Object.defineProperty(metadata, $numFields, {\r\n                    value: parentMetadata[$numFields],\r\n                    enumerable: false,\r\n                    configurable: true,\r\n                    writable: true,\r\n                });\r\n\r\n                // $viewFieldIndexes / $fieldIndexesByViewTag\r\n                if (parentMetadata[$viewFieldIndexes] !== undefined) {\r\n                    Object.defineProperty(metadata, $viewFieldIndexes, {\r\n                        value: [...parentMetadata[$viewFieldIndexes]],\r\n                        enumerable: false,\r\n                        configurable: true,\r\n                        writable: true,\r\n                    });\r\n                    Object.defineProperty(metadata, $fieldIndexesByViewTag, {\r\n                        value: { ...parentMetadata[$fieldIndexesByViewTag] },\r\n                        enumerable: false,\r\n                        configurable: true,\r\n                        writable: true,\r\n                    });\r\n                }\r\n\r\n                // $refTypeFieldIndexes\r\n                if (parentMetadata[$refTypeFieldIndexes] !== undefined) {\r\n                    Object.defineProperty(metadata, $refTypeFieldIndexes, {\r\n                        value: [...parentMetadata[$refTypeFieldIndexes]],\r\n                        enumerable: false,\r\n                        configurable: true,\r\n                        writable: true,\r\n                    });\r\n                }\r\n\r\n                // $descriptors\r\n                Object.defineProperty(metadata, $descriptors, {\r\n                    value: { ...parentMetadata[$descriptors] },\r\n                    enumerable: false,\r\n                    configurable: true,\r\n                    writable: true,\r\n                });\r\n            }\r\n        }\r\n\r\n        Object.defineProperty(constructor, Symbol.metadata, {\r\n            value: metadata,\r\n            writable: false,\r\n            configurable: true\r\n        });\r\n\r\n        return metadata;\r\n    },\r\n\r\n    isValidInstance(klass: any) {\r\n        return (\r\n            klass.constructor[Symbol.metadata] &&\r\n            Object.prototype.hasOwnProperty.call(klass.constructor[Symbol.metadata], $numFields) as boolean\r\n        );\r\n    },\r\n\r\n    getFields(klass: any) {\r\n        const metadata: Metadata = klass[Symbol.metadata];\r\n        const fields: any = {};\r\n        for (let i = 0; i <= metadata[$numFields]; i++) {\r\n            fields[metadata[i].name] = metadata[i].type;\r\n        }\r\n        return fields;\r\n    },\r\n\r\n    hasViewTagAtIndex(metadata: Metadata, index: number) {\r\n        return metadata?.[$viewFieldIndexes]?.includes(index);\r\n    }\r\n}","import { OPERATION } from \"../encoding/spec\";\r\nimport { Schema } from \"../Schema\";\r\nimport { $changes, $childType, $decoder, $onEncodeEnd, $encoder, $getByIndex, $refTypeFieldIndexes, $viewFieldIndexes, type $deleteByIndex } from \"../types/symbols\";\r\n\r\nimport type { MapSchema } from \"../types/custom/MapSchema\";\r\nimport type { ArraySchema } from \"../types/custom/ArraySchema\";\r\nimport type { CollectionSchema } from \"../types/custom/CollectionSchema\";\r\nimport type { SetSchema } from \"../types/custom/SetSchema\";\r\n\r\nimport { Root } from \"./Root\";\r\nimport { Metadata } from \"../Metadata\";\r\nimport type { EncodeOperation } from \"./EncodeOperation\";\r\nimport type { DecodeOperation } from \"../decoder/DecodeOperation\";\r\n\r\ndeclare global {\r\n    interface Object {\r\n        // FIXME: not a good practice to extend globals here\r\n        [$changes]?: ChangeTree;\r\n        [$encoder]?: EncodeOperation,\r\n        [$decoder]?: DecodeOperation,\r\n    }\r\n}\r\n\r\nexport interface IRef {\r\n    [$changes]?: ChangeTree;\r\n    [$getByIndex]?: (index: number, isEncodeAll?: boolean) => any;\r\n    [$deleteByIndex]?: (index: number) => void;\r\n}\r\n\r\nexport type Ref = Schema\r\n    | ArraySchema\r\n    | MapSchema\r\n    | CollectionSchema\r\n    | SetSchema;\r\n\r\nexport type ChangeSetName = \"changes\"\r\n    | \"allChanges\"\r\n    | \"filteredChanges\"\r\n    | \"allFilteredChanges\";\r\n\r\nexport interface IndexedOperations {\r\n    [index: number]: OPERATION;\r\n}\r\n\r\n// Linked list node for change trees\r\nexport interface ChangeTreeNode {\r\n    changeTree: ChangeTree;\r\n    next?: ChangeTreeNode;\r\n    prev?: ChangeTreeNode;\r\n    position: number; // Cached position in the linked list for O(1) lookup\r\n}\r\n\r\n// Linked list for change trees\r\nexport interface ChangeTreeList {\r\n    next?: ChangeTreeNode;\r\n    tail?: ChangeTreeNode;\r\n}\r\n\r\nexport interface ChangeSet {\r\n    // field index -> operation index\r\n    indexes: { [index: number]: number };\r\n    operations: number[];\r\n    queueRootNode?: ChangeTreeNode; // direct reference to ChangeTreeNode in the linked list\r\n}\r\n\r\nfunction createChangeSet(queueRootNode?: ChangeTreeNode): ChangeSet {\r\n    return { indexes: {}, operations: [], queueRootNode };\r\n}\r\n\r\n// Linked list helper functions\r\nexport function createChangeTreeList(): ChangeTreeList {\r\n    return { next: undefined, tail: undefined };\r\n}\r\n\r\nexport function setOperationAtIndex(changeSet: ChangeSet, index: number) {\r\n    const operationsIndex = changeSet.indexes[index];\r\n    if (operationsIndex === undefined) {\r\n        changeSet.indexes[index] = changeSet.operations.push(index) - 1;\r\n    } else {\r\n        changeSet.operations[operationsIndex] = index;\r\n    }\r\n}\r\n\r\nexport function deleteOperationAtIndex(changeSet: ChangeSet, index: number | string) {\r\n    let operationsIndex = changeSet.indexes[index as any as number];\r\n    if (operationsIndex === undefined) {\r\n        //\r\n        // if index is not found, we need to find the last operation\r\n        // FIXME: this is not very efficient\r\n        //\r\n        // > See \"should allow consecutive splices (same place)\" tests\r\n        //\r\n        operationsIndex = Object.values(changeSet.indexes).at(-1);\r\n        index = Object.entries(changeSet.indexes).find(([_, value]) => value === operationsIndex)?.[0];\r\n    }\r\n    changeSet.operations[operationsIndex] = undefined;\r\n    delete changeSet.indexes[index as any as number];\r\n}\r\n\r\nexport function debugChangeSet(label: string, changeSet: ChangeSet) {\r\n    let indexes: string[] = [];\r\n    let operations: string[] = [];\r\n\r\n    for (const index in changeSet.indexes) {\r\n        indexes.push(`\\t${index} => [${changeSet.indexes[index]}]`);\r\n    }\r\n\r\n    for (let i = 0; i < changeSet.operations.length; i++) {\r\n        const index = changeSet.operations[i];\r\n        if (index !== undefined) {\r\n            operations.push(`\\t[${i}] => ${index}`);\r\n        }\r\n    }\r\n\r\n    console.log(`${label} =>\\nindexes (${Object.keys(changeSet.indexes).length}) {`);\r\n    console.log(indexes.join(\"\\n\"), \"\\n}\");\r\n    console.log(`operations (${changeSet.operations.filter(op => op !== undefined).length}) {`);\r\n    console.log(operations.join(\"\\n\"), \"\\n}\");\r\n}\r\n\r\nexport interface ParentChain {\r\n    ref: Ref;\r\n    index: number;\r\n    next?: ParentChain;\r\n}\r\n\r\nexport class ChangeTree<T extends Ref = any> {\r\n    ref: T;\r\n    refId: number;\r\n    metadata: Metadata;\r\n\r\n    root?: Root;\r\n    parentChain?: ParentChain; // Linked list for tracking parents\r\n\r\n    /**\r\n     * Whether this structure is parent of a filtered structure.\r\n     */\r\n    isFiltered: boolean = false;\r\n    isVisibilitySharedWithParent?: boolean; // See test case: 'should not be required to manually call view.add() items to child arrays without @view() tag'\r\n\r\n    indexedOperations: IndexedOperations = {};\r\n\r\n    //\r\n    // TODO:\r\n    //   try storing the index + operation per item.\r\n    //   example: 1024 & 1025 => ADD, 1026 => DELETE\r\n    //\r\n    // => https://chatgpt.com/share/67107d0c-bc20-8004-8583-83b17dd7c196\r\n    //\r\n    changes: ChangeSet = { indexes: {}, operations: [] };\r\n    allChanges: ChangeSet = { indexes: {}, operations: [] };\r\n    filteredChanges: ChangeSet;\r\n    allFilteredChanges: ChangeSet;\r\n\r\n    indexes: { [index: string]: any }; // TODO: remove this, only used by MapSchema/SetSchema/CollectionSchema (`encodeKeyValueOperation`)\r\n\r\n    /**\r\n     * Is this a new instance? Used on ArraySchema to determine OPERATION.MOVE_AND_ADD operation.\r\n     */\r\n    isNew = true;\r\n\r\n    constructor(ref: T) {\r\n        this.ref = ref;\r\n        this.metadata = (ref.constructor as typeof Schema)[Symbol.metadata];\r\n\r\n        //\r\n        // Does this structure have \"filters\" declared?\r\n        //\r\n        if (this.metadata?.[$viewFieldIndexes]) {\r\n            this.allFilteredChanges = { indexes: {}, operations: [] };\r\n            this.filteredChanges = { indexes: {}, operations: [] };\r\n        }\r\n    }\r\n\r\n    setRoot(root: Root) {\r\n        this.root = root;\r\n\r\n        const isNewChangeTree = this.root.add(this);\r\n\r\n        this.checkIsFiltered(this.parent, this.parentIndex, isNewChangeTree);\r\n\r\n        // Recursively set root on child structures\r\n        if (isNewChangeTree) {\r\n            this.forEachChild((child, _) => {\r\n                if (child.root !== root) {\r\n                    child.setRoot(root);\r\n                } else {\r\n                    root.add(child); // increment refCount\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    setParent(\r\n        parent: Ref,\r\n        root?: Root,\r\n        parentIndex?: number,\r\n    ) {\r\n        this.addParent(parent, parentIndex);\r\n\r\n        // avoid setting parents with empty `root`\r\n        if (!root) { return; }\r\n\r\n        const isNewChangeTree = root.add(this);\r\n\r\n        // skip if parent is already set\r\n        if (root !== this.root) {\r\n            this.root = root;\r\n            this.checkIsFiltered(parent, parentIndex, isNewChangeTree);\r\n        }\r\n\r\n        // assign same parent on child structures\r\n        if (isNewChangeTree) {\r\n            //\r\n            // assign same parent on child structures\r\n            //\r\n            this.forEachChild((child, index) => {\r\n                if (child.root === root) {\r\n                    //\r\n                    // re-assigning a child of the same root, move it next to parent\r\n                    // so encoding order is preserved\r\n                    //\r\n                    root.add(child);\r\n                    root.moveNextToParent(child);\r\n                    return;\r\n                }\r\n                child.setParent(this.ref, root, index);\r\n            });\r\n        }\r\n    }\r\n\r\n    forEachChild(callback: (change: ChangeTree, at: any) => void) {\r\n        //\r\n        // assign same parent on child structures\r\n        //\r\n        if ((this.ref as any)[$childType]) {\r\n            if (typeof ((this.ref as any)[$childType]) !== \"string\") {\r\n                // MapSchema / ArraySchema, etc.\r\n                for (const [key, value] of (this.ref as MapSchema).entries()) {\r\n                    if (!value) { continue; } // sparse arrays can have undefined values\r\n                    callback(value[$changes], this.indexes?.[key] ?? key);\r\n                };\r\n            }\r\n\r\n        } else {\r\n            for (const index of this.metadata?.[$refTypeFieldIndexes] ?? []) {\r\n                const field = this.metadata[index as any as number];\r\n                const value = this.ref[field.name as keyof Ref];\r\n                if (!value) { continue; }\r\n                callback(value[$changes], index);\r\n            }\r\n        }\r\n    }\r\n\r\n    operation(op: OPERATION) {\r\n        // operations without index use negative values to represent them\r\n        // this is checked during .encode() time.\r\n        if (this.filteredChanges !== undefined) {\r\n            this.filteredChanges.operations.push(-op);\r\n            this.root?.enqueueChangeTree(this, 'filteredChanges');\r\n\r\n        } else {\r\n            this.changes.operations.push(-op);\r\n            this.root?.enqueueChangeTree(this, 'changes');\r\n        }\r\n    }\r\n\r\n    change(index: number, operation: OPERATION = OPERATION.ADD) {\r\n        const isFiltered = this.isFiltered || (this.metadata?.[index]?.tag !== undefined);\r\n        const changeSet = (isFiltered)\r\n            ? this.filteredChanges\r\n            : this.changes;\r\n\r\n        const previousOperation = this.indexedOperations[index];\r\n        if (!previousOperation || previousOperation === OPERATION.DELETE) {\r\n            const op = (!previousOperation)\r\n                ? operation\r\n                : (previousOperation === OPERATION.DELETE)\r\n                    ? OPERATION.DELETE_AND_ADD\r\n                    : operation\r\n            //\r\n            // TODO: are DELETE operations being encoded as ADD here ??\r\n            //\r\n            this.indexedOperations[index] = op;\r\n        }\r\n\r\n        setOperationAtIndex(changeSet, index);\r\n\r\n        if (isFiltered) {\r\n            setOperationAtIndex(this.allFilteredChanges, index);\r\n\r\n            if (this.root) {\r\n                this.root.enqueueChangeTree(this, 'filteredChanges');\r\n                this.root.enqueueChangeTree(this, 'allFilteredChanges');\r\n            }\r\n\r\n        } else {\r\n            setOperationAtIndex(this.allChanges, index);\r\n            this.root?.enqueueChangeTree(this, 'changes');\r\n        }\r\n    }\r\n\r\n    shiftChangeIndexes(shiftIndex: number) {\r\n        //\r\n        // Used only during:\r\n        //\r\n        // - ArraySchema#unshift()\r\n        //\r\n        const changeSet = (this.isFiltered)\r\n            ? this.filteredChanges\r\n            : this.changes;\r\n\r\n        const newIndexedOperations: any = {};\r\n        const newIndexes: { [index: number]: number } = {};\r\n        for (const index in this.indexedOperations) {\r\n            newIndexedOperations[Number(index) + shiftIndex] = this.indexedOperations[index];\r\n            newIndexes[Number(index) + shiftIndex] = changeSet.indexes[index];\r\n        }\r\n        this.indexedOperations = newIndexedOperations;\r\n        changeSet.indexes = newIndexes;\r\n\r\n        changeSet.operations = changeSet.operations.map((index) => index + shiftIndex);\r\n    }\r\n\r\n    shiftAllChangeIndexes(shiftIndex: number, startIndex: number = 0) {\r\n        //\r\n        // Used only during:\r\n        //\r\n        // - ArraySchema#splice()\r\n        //\r\n        if (this.filteredChanges !== undefined) {\r\n            this._shiftAllChangeIndexes(shiftIndex, startIndex, this.allFilteredChanges);\r\n            this._shiftAllChangeIndexes(shiftIndex, startIndex, this.allChanges);\r\n\r\n        } else {\r\n            this._shiftAllChangeIndexes(shiftIndex, startIndex, this.allChanges);\r\n        }\r\n    }\r\n\r\n    private _shiftAllChangeIndexes(shiftIndex: number, startIndex: number = 0, changeSet: ChangeSet) {\r\n        const newIndexes: { [index: number]: number } = {};\r\n        let newKey = 0;\r\n        for (const key in changeSet.indexes) {\r\n            newIndexes[newKey++] = changeSet.indexes[key];\r\n        }\r\n        changeSet.indexes = newIndexes;\r\n\r\n        for (let i = 0; i < changeSet.operations.length; i++) {\r\n            const index = changeSet.operations[i];\r\n            if (index > startIndex) {\r\n                changeSet.operations[i] = index + shiftIndex;\r\n            }\r\n        }\r\n    }\r\n\r\n    indexedOperation(index: number, operation: OPERATION, allChangesIndex: number = index) {\r\n        this.indexedOperations[index] = operation;\r\n\r\n        if (this.filteredChanges !== undefined) {\r\n            setOperationAtIndex(this.allFilteredChanges, allChangesIndex);\r\n            setOperationAtIndex(this.filteredChanges, index);\r\n            this.root?.enqueueChangeTree(this, 'filteredChanges');\r\n\r\n        } else {\r\n            setOperationAtIndex(this.allChanges, allChangesIndex);\r\n            setOperationAtIndex(this.changes, index);\r\n            this.root?.enqueueChangeTree(this, 'changes');\r\n        }\r\n    }\r\n\r\n    getType(index?: number) {\r\n        return (\r\n            //\r\n            // Get the child type from parent structure.\r\n            // - [\"string\"] => \"string\"\r\n            // - { map: \"string\" } => \"string\"\r\n            // - { set: \"string\" } => \"string\"\r\n            //\r\n            (this.ref as any)[$childType] || // ArraySchema | MapSchema | SetSchema | CollectionSchema\r\n            this.metadata[index].type // Schema\r\n        );\r\n    }\r\n\r\n    getChange(index: number) {\r\n        return this.indexedOperations[index];\r\n    }\r\n\r\n    //\r\n    // used during `.encode()`\r\n    //\r\n    getValue(index: number, isEncodeAll: boolean = false) {\r\n        //\r\n        // `isEncodeAll` param is only used by ArraySchema\r\n        //\r\n        return (this.ref as any)[$getByIndex](index, isEncodeAll);\r\n    }\r\n\r\n    delete(index: number, operation?: OPERATION, allChangesIndex = index) {\r\n        if (index === undefined) {\r\n            try {\r\n                throw new Error(`@colyseus/schema ${this.ref.constructor.name}: trying to delete non-existing index '${index}'`);\r\n            } catch (e) {\r\n                console.warn(e);\r\n            }\r\n            return;\r\n        }\r\n\r\n        const changeSet = (this.filteredChanges !== undefined)\r\n            ? this.filteredChanges\r\n            : this.changes;\r\n\r\n        this.indexedOperations[index] = operation ?? OPERATION.DELETE;\r\n        setOperationAtIndex(changeSet, index);\r\n        deleteOperationAtIndex(this.allChanges, allChangesIndex);\r\n\r\n        const previousValue = this.getValue(index);\r\n\r\n        // remove `root` reference\r\n        if (previousValue && previousValue[$changes]) {\r\n            //\r\n            // FIXME: this.root is \"undefined\"\r\n            //\r\n            // This method is being called at decoding time when a DELETE operation is found.\r\n            //\r\n            // - This is due to using the concrete Schema class at decoding time.\r\n            // - \"Reflected\" structures do not have this problem.\r\n            //\r\n            // (The property descriptors should NOT be used at decoding time. only at encoding time.)\r\n            //\r\n            this.root?.remove(previousValue[$changes]);\r\n        }\r\n\r\n        //\r\n        // FIXME: this is looking a ugly and repeated\r\n        //\r\n        if (this.filteredChanges !== undefined) {\r\n            deleteOperationAtIndex(this.allFilteredChanges, allChangesIndex);\r\n            this.root?.enqueueChangeTree(this, 'filteredChanges');\r\n\r\n        } else {\r\n            this.root?.enqueueChangeTree(this, 'changes');\r\n        }\r\n\r\n        return previousValue;\r\n    }\r\n\r\n    endEncode(changeSetName: ChangeSetName) {\r\n        this.indexedOperations = {};\r\n\r\n        // clear changeset\r\n        this[changeSetName] = createChangeSet();\r\n\r\n        // ArraySchema and MapSchema have a custom \"encode end\" method\r\n        (this.ref as any)[$onEncodeEnd]?.();\r\n\r\n        // Not a new instance anymore\r\n        this.isNew = false;\r\n    }\r\n\r\n    discard(discardAll: boolean = false) {\r\n        //\r\n        // > MapSchema:\r\n        //      Remove cached key to ensure ADD operations is unsed instead of\r\n        //      REPLACE in case same key is used on next patches.\r\n        //\r\n        (this.ref as any)[$onEncodeEnd]?.();\r\n\r\n        this.indexedOperations = {};\r\n        this.changes = createChangeSet(this.changes.queueRootNode);\r\n\r\n        if (this.filteredChanges !== undefined) {\r\n            this.filteredChanges = createChangeSet(this.filteredChanges.queueRootNode);\r\n        }\r\n\r\n        if (discardAll) {\r\n            // preserve queueRootNode references\r\n            this.allChanges = createChangeSet(this.allChanges.queueRootNode);\r\n\r\n            if (this.allFilteredChanges !== undefined) {\r\n                this.allFilteredChanges = createChangeSet(this.allFilteredChanges.queueRootNode);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Recursively discard all changes from this, and child structures.\r\n     * (Used in tests only)\r\n     */\r\n    discardAll() {\r\n        const keys = Object.keys(this.indexedOperations);\r\n        for (let i = 0, len = keys.length; i < len; i++) {\r\n            const value = this.getValue(Number(keys[i]));\r\n\r\n            if (value && value[$changes]) {\r\n                value[$changes].discardAll();\r\n            }\r\n        }\r\n\r\n        this.discard();\r\n    }\r\n\r\n    get changed() {\r\n        return (Object.entries(this.indexedOperations).length > 0);\r\n    }\r\n\r\n    protected checkIsFiltered(parent: Ref, parentIndex: number, isNewChangeTree: boolean) {\r\n        if (this.root.types.hasFilters) {\r\n            //\r\n            // At Schema initialization, the \"root\" structure might not be available\r\n            // yet, as it only does once the \"Encoder\" has been set up.\r\n            //\r\n            // So the \"parent\" may be already set without a \"root\".\r\n            //\r\n            this._checkFilteredByParent(parent, parentIndex);\r\n\r\n            if (this.filteredChanges !== undefined) {\r\n                this.root?.enqueueChangeTree(this, 'filteredChanges');\r\n\r\n                if (isNewChangeTree) {\r\n                    this.root?.enqueueChangeTree(this, 'allFilteredChanges');\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!this.isFiltered) {\r\n            this.root?.enqueueChangeTree(this, 'changes');\r\n\r\n            if (isNewChangeTree) {\r\n                this.root?.enqueueChangeTree(this, 'allChanges');\r\n            }\r\n        }\r\n    }\r\n\r\n    protected _checkFilteredByParent(parent: Ref, parentIndex: number) {\r\n        // skip if parent is not set\r\n        if (!parent) { return; }\r\n\r\n        //\r\n        // ArraySchema | MapSchema - get the child type\r\n        // (if refType is typeof string, the parentFiltered[key] below will always be invalid)\r\n        //\r\n        const refType = Metadata.isValidInstance(this.ref)\r\n            ? this.ref.constructor\r\n            : (this.ref as any)[$childType];\r\n\r\n        let parentChangeTree: ChangeTree;\r\n\r\n        let parentIsCollection = !Metadata.isValidInstance(parent);\r\n        if (parentIsCollection) {\r\n            parentChangeTree = parent[$changes];\r\n            parent = parentChangeTree.parent;\r\n            parentIndex = parentChangeTree.parentIndex;\r\n\r\n        } else {\r\n            parentChangeTree = parent[$changes]\r\n        }\r\n\r\n        const parentConstructor = parent.constructor as typeof Schema;\r\n\r\n        let key = `${this.root.types.getTypeId(refType as typeof Schema)}`;\r\n        if (parentConstructor) {\r\n            key += `-${this.root.types.schemas.get(parentConstructor)}`;\r\n        }\r\n        key += `-${parentIndex}`;\r\n\r\n        const fieldHasViewTag = Metadata.hasViewTagAtIndex(parentConstructor?.[Symbol.metadata], parentIndex);\r\n\r\n        this.isFiltered = parent[$changes].isFiltered // in case parent is already filtered\r\n            || this.root.types.parentFiltered[key]\r\n            || fieldHasViewTag;\r\n\r\n        //\r\n        // \"isFiltered\" may not be imedialely available during `change()` due to the instance not being attached to the root yet.\r\n        // when it's available, we need to enqueue the \"changes\" changeset into the \"filteredChanges\" changeset.\r\n        //\r\n        if (this.isFiltered) {\r\n\r\n            this.isVisibilitySharedWithParent = (\r\n                parentChangeTree.isFiltered &&\r\n                typeof (refType) !== \"string\" &&\r\n                !fieldHasViewTag &&\r\n                parentIsCollection\r\n            );\r\n\r\n            if (!this.filteredChanges) {\r\n                this.filteredChanges = createChangeSet();\r\n                this.allFilteredChanges = createChangeSet();\r\n            }\r\n\r\n            if (this.changes.operations.length > 0) {\r\n                this.changes.operations.forEach((index) =>\r\n                    setOperationAtIndex(this.filteredChanges, index));\r\n\r\n                this.allChanges.operations.forEach((index) =>\r\n                    setOperationAtIndex(this.allFilteredChanges, index));\r\n\r\n                this.changes = createChangeSet();\r\n                this.allChanges = createChangeSet();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the immediate parent\r\n     */\r\n    get parent(): Ref | undefined {\r\n        return this.parentChain?.ref;\r\n    }\r\n\r\n    /**\r\n     * Get the immediate parent index\r\n     */\r\n    get parentIndex(): number | undefined {\r\n        return this.parentChain?.index;\r\n    }\r\n\r\n    /**\r\n     * Add a parent to the chain\r\n     */\r\n    addParent(parent: Ref, index: number) {\r\n        // Check if this parent already exists in the chain\r\n        if (this.hasParent((p, _) => p[$changes] === parent[$changes])) {\r\n        // if (this.hasParent((p, i) => p[$changes] === parent[$changes] && i === index)) {\r\n            this.parentChain.index = index;\r\n            return;\r\n        }\r\n\r\n        this.parentChain = {\r\n            ref: parent,\r\n            index,\r\n            next: this.parentChain\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Remove a parent from the chain\r\n     * @param parent - The parent to remove\r\n     * @returns true if parent was removed\r\n     */\r\n    removeParent(parent: Ref = this.parent): boolean {\r\n        let current = this.parentChain;\r\n        let previous = null;\r\n        while (current) {\r\n            //\r\n            // FIXME: it is required to check against `$changes` here because\r\n            // ArraySchema is instance of Proxy\r\n            //\r\n            if (current.ref[$changes] === parent[$changes]) {\r\n                if (previous) {\r\n                    previous.next = current.next;\r\n                } else {\r\n                    this.parentChain = current.next;\r\n                }\r\n                return true;\r\n            }\r\n            previous = current;\r\n            current = current.next;\r\n        }\r\n        return this.parentChain === undefined;\r\n    }\r\n\r\n    /**\r\n     * Find a specific parent in the chain\r\n     */\r\n    findParent(predicate: (parent: Ref, index: number) => boolean): ParentChain | undefined {\r\n        let current = this.parentChain;\r\n        while (current) {\r\n            if (predicate(current.ref, current.index)) {\r\n                return current;\r\n            }\r\n            current = current.next;\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    /**\r\n     * Check if this ChangeTree has a specific parent\r\n     */\r\n    hasParent(predicate: (parent: Ref, index: number) => boolean): boolean {\r\n        return this.findParent(predicate) !== undefined;\r\n    }\r\n\r\n    /**\r\n     * Get all parents as an array (for debugging/testing)\r\n     */\r\n    getAllParents(): Array<{ ref: Ref, index: number }> {\r\n        const parents: Array<{ ref: Ref, index: number }> = [];\r\n        let current = this.parentChain;\r\n        while (current) {\r\n            parents.push({ ref: current.ref, index: current.index });\r\n            current = current.next;\r\n        }\r\n        return parents;\r\n    }\r\n\r\n}\r\n","import { OPERATION } from \"../encoding/spec\";\r\nimport { $changes, $childType, $getByIndex } from \"../types/symbols\";\r\n\r\nimport { encode } from \"../encoding/encode\";\r\n\r\nimport type { ChangeTree, Ref } from \"./ChangeTree\";\r\nimport type { Encoder } from \"./Encoder\";\r\nimport type { Schema } from \"../Schema\";\r\n\r\nimport type { Iterator } from \"../encoding/decode\";\r\nimport type { ArraySchema } from \"../types/custom/ArraySchema\";\r\nimport type { Metadata } from \"../Metadata\";\r\n\r\nexport type EncodeOperation<T extends Ref = any> = (\r\n    encoder: Encoder,\r\n    bytes: Buffer,\r\n    changeTree: ChangeTree<T>,\r\n    index: number,\r\n    operation: OPERATION,\r\n    it: Iterator,\r\n    isEncodeAll: boolean,\r\n    hasView: boolean,\r\n    metadata?: Metadata,\r\n) => void;\r\n\r\nexport function encodeValue(\r\n    encoder: Encoder,\r\n    bytes: Buffer,\r\n    type: any,\r\n    value: any,\r\n    operation: OPERATION,\r\n    it: Iterator,\r\n) {\r\n    if (typeof (type) === \"string\") {\r\n        (encode as any)[type]?.(bytes, value, it);\r\n\r\n    } else if (type[Symbol.metadata] !== undefined) {\r\n        //\r\n        // Encode refId for this instance.\r\n        // The actual instance is going to be encoded on next `changeTree` iteration.\r\n        //\r\n        encode.number(bytes, value[$changes].refId, it);\r\n\r\n        // Try to encode inherited TYPE_ID if it's an ADD operation.\r\n        if ((operation & OPERATION.ADD) === OPERATION.ADD) {\r\n            encoder.tryEncodeTypeId(bytes, type as typeof Schema, value.constructor as typeof Schema, it);\r\n        }\r\n\r\n    } else {\r\n        //\r\n        // Encode refId for this instance.\r\n        // The actual instance is going to be encoded on next `changeTree` iteration.\r\n        //\r\n        encode.number(bytes, value[$changes].refId, it);\r\n    }\r\n}\r\n\r\n/**\r\n * Used for Schema instances.\r\n * @private\r\n */\r\nexport const encodeSchemaOperation: EncodeOperation = function <T extends Schema> (\r\n    encoder: Encoder,\r\n    bytes: Buffer,\r\n    changeTree: ChangeTree<T>,\r\n    index: number,\r\n    operation: OPERATION,\r\n    it: Iterator,\r\n    _: any,\r\n    __: any,\r\n    metadata: Metadata,\r\n) {\r\n    // \"compress\" field index + operation\r\n    bytes[it.offset++] = (index | operation) & 255;\r\n\r\n    // Do not encode value for DELETE operations\r\n    if (operation === OPERATION.DELETE) {\r\n        return;\r\n    }\r\n\r\n    const ref = changeTree.ref;\r\n    const field = metadata[index];\r\n\r\n    // TODO: inline this function call small performance gain\r\n    encodeValue(\r\n        encoder,\r\n        bytes,\r\n        metadata[index].type,\r\n        ref[field.name as keyof T],\r\n        operation,\r\n        it\r\n    );\r\n}\r\n\r\n/**\r\n * Used for collections (MapSchema, CollectionSchema, SetSchema)\r\n * @private\r\n */\r\nexport const encodeKeyValueOperation: EncodeOperation = function (\r\n    encoder: Encoder,\r\n    bytes: Buffer,\r\n    changeTree: ChangeTree,\r\n    index: number,\r\n    operation: OPERATION,\r\n    it: Iterator,\r\n) {\r\n    // encode operation\r\n    bytes[it.offset++] = operation & 255;\r\n\r\n    // encode index\r\n    encode.number(bytes, index, it);\r\n\r\n    // Do not encode value for DELETE operations\r\n    if (operation === OPERATION.DELETE) {\r\n        return;\r\n    }\r\n\r\n    const ref = changeTree.ref;\r\n\r\n    //\r\n    // encode \"alias\" for dynamic fields (maps)\r\n    //\r\n    if ((operation & OPERATION.ADD) === OPERATION.ADD) { // ADD or DELETE_AND_ADD\r\n        if (typeof(ref['set']) === \"function\") {\r\n            //\r\n            // MapSchema dynamic key\r\n            //\r\n            const dynamicIndex = changeTree.ref['$indexes'].get(index);\r\n            encode.string(bytes, dynamicIndex, it);\r\n        }\r\n    }\r\n\r\n    const type = ref[$childType];\r\n    const value = ref[$getByIndex](index);\r\n\r\n    // try { throw new Error(); } catch (e) {\r\n    //     // only print if not coming from Reflection.ts\r\n    //     if (!e.stack.includes(\"src/Reflection.ts\")) {\r\n    //         console.log(\"encodeKeyValueOperation -> \", {\r\n    //             ref: changeTree.ref.constructor.name,\r\n    //             field,\r\n    //             operation: OPERATION[operation],\r\n    //             value: value?.toJSON(),\r\n    //             items: ref.toJSON(),\r\n    //         });\r\n    //     }\r\n    // }\r\n\r\n    // TODO: inline this function call small performance gain\r\n    encodeValue(\r\n        encoder,\r\n        bytes,\r\n        type,\r\n        value,\r\n        operation,\r\n        it\r\n    );\r\n}\r\n\r\n/**\r\n * Used for collections (MapSchema, ArraySchema, etc.)\r\n * @private\r\n */\r\nexport const encodeArray: EncodeOperation = function (\r\n    encoder: Encoder,\r\n    bytes: Buffer,\r\n    changeTree: ChangeTree<ArraySchema>,\r\n    field: number,\r\n    operation: OPERATION,\r\n    it: Iterator,\r\n    isEncodeAll: boolean,\r\n    hasView: boolean,\r\n) {\r\n    const ref = changeTree.ref;\r\n    const useOperationByRefId = hasView && changeTree.isFiltered && (typeof (changeTree.getType(field)) !== \"string\");\r\n\r\n    let refOrIndex: number;\r\n\r\n    if (useOperationByRefId) {\r\n        const item = ref['tmpItems'][field];\r\n\r\n        // Skip encoding if item is undefined (e.g. when clear() is called)\r\n        if (!item) { return; }\r\n\r\n        refOrIndex = item[$changes].refId;\r\n\r\n        if (operation === OPERATION.DELETE) {\r\n            operation = OPERATION.DELETE_BY_REFID;\r\n\r\n        } else if (operation === OPERATION.ADD) {\r\n            operation = OPERATION.ADD_BY_REFID;\r\n        }\r\n\r\n    } else {\r\n        refOrIndex = field;\r\n    }\r\n\r\n    // encode operation\r\n    bytes[it.offset++] = operation & 255;\r\n\r\n    // encode index\r\n    encode.number(bytes, refOrIndex, it);\r\n\r\n    // Do not encode value for DELETE operations\r\n    if (operation === OPERATION.DELETE || operation === OPERATION.DELETE_BY_REFID) {\r\n        return;\r\n    }\r\n\r\n    const type = changeTree.getType(field);\r\n    const value = changeTree.getValue(field, isEncodeAll);\r\n\r\n    // console.log({ type, field, value });\r\n\r\n    // console.log(\"encodeArray -> \", {\r\n    //     ref: changeTree.ref.constructor.name,\r\n    //     field,\r\n    //     operation: OPERATION[operation],\r\n    //     value: value?.toJSON(),\r\n    //     items: ref.toJSON(),\r\n    // });\r\n\r\n    // TODO: inline this function call small performance gain\r\n    encodeValue(\r\n        encoder,\r\n        bytes,\r\n        type,\r\n        value,\r\n        operation,\r\n        it\r\n    );\r\n}","import { OPERATION } from \"../encoding/spec\";\r\nimport { Metadata } from \"../Metadata\";\r\nimport { Schema } from \"../Schema\";\r\nimport type { Ref } from \"../encoder/ChangeTree\";\r\nimport type { Decoder } from \"./Decoder\";\r\nimport { Iterator, decode } from \"../encoding/decode\";\r\nimport { $childType, $deleteByIndex, $getByIndex } from \"../types/symbols\";\r\n\r\nimport type { MapSchema } from \"../types/custom/MapSchema\";\r\nimport type { ArraySchema } from \"../types/custom/ArraySchema\";\r\nimport type { CollectionSchema } from \"../types/custom/CollectionSchema\";\r\n\r\nimport { getType } from \"../types/registry\";\r\nimport { Collection } from \"../types/HelperTypes\";\r\n\r\nexport interface DataChange<T = any, F = string> {\r\n    ref: Ref,\r\n    refId: number,\r\n    op: OPERATION,\r\n    field: F;\r\n    dynamicIndex?: number | string;\r\n    value: T;\r\n    previousValue: T;\r\n}\r\n\r\nexport const DEFINITION_MISMATCH = -1;\r\n\r\nexport type DecodeOperation<T extends Schema = any> = (\r\n    decoder: Decoder<T>,\r\n    bytes: Buffer,\r\n    it: Iterator,\r\n    ref: Ref,\r\n    allChanges: DataChange[],\r\n) => number | void;\r\n\r\nexport function decodeValue<T extends Ref>(\r\n    decoder: Decoder,\r\n    operation: OPERATION,\r\n    ref: T,\r\n    index: number,\r\n    type: any,\r\n    bytes: Buffer,\r\n    it: Iterator,\r\n    allChanges: DataChange[],\r\n) {\r\n    const $root = decoder.root;\r\n    const previousValue = (ref as any)[$getByIndex](index) as T;\r\n\r\n    let value: any;\r\n\r\n    if ((operation & OPERATION.DELETE) === OPERATION.DELETE)\r\n    {\r\n        // Flag `refId` for garbage collection.\r\n        const previousRefId = $root.refIds.get(previousValue);\r\n        if (previousRefId !== undefined) { $root.removeRef(previousRefId); }\r\n\r\n        //\r\n        // Delete operations\r\n        //\r\n        if (operation !== OPERATION.DELETE_AND_ADD) {\r\n            (ref as any)[$deleteByIndex](index);\r\n        }\r\n\r\n        value = undefined;\r\n    }\r\n\r\n    if (operation === OPERATION.DELETE) {\r\n        //\r\n        // Don't do anything\r\n        //\r\n\r\n    } else if (Schema.is(type)) {\r\n        const refId = decode.number(bytes, it);\r\n        value = $root.refs.get(refId);\r\n\r\n        if ((operation & OPERATION.ADD) === OPERATION.ADD) {\r\n            const childType = decoder.getInstanceType(bytes, it, type);\r\n            if (!value) {\r\n                value = decoder.createInstanceOfType(childType);\r\n            }\r\n\r\n            $root.addRef(\r\n                refId,\r\n                value,\r\n                (\r\n                    value !== previousValue || // increment ref count if value has changed\r\n                    (operation === OPERATION.DELETE_AND_ADD && value === previousValue) // increment ref count if the same instance is being added again\r\n                )\r\n            );\r\n        }\r\n\r\n    } else if (typeof(type) === \"string\") {\r\n        //\r\n        // primitive value (number, string, boolean, etc)\r\n        //\r\n        value = (decode as any)[type](bytes, it);\r\n\r\n    } else {\r\n        const typeDef = getType(Object.keys(type)[0]);\r\n        const refId = decode.number(bytes, it);\r\n\r\n        const valueRef: Ref = ($root.refs.has(refId))\r\n            ? previousValue || $root.refs.get(refId)\r\n            : new typeDef.constructor();\r\n\r\n        value = valueRef.clone(true);\r\n        value[$childType] = Object.values(type)[0]; // cache childType for ArraySchema and MapSchema\r\n\r\n        if (previousValue) {\r\n            let previousRefId = $root.refIds.get(previousValue);\r\n\r\n            if (previousRefId !== undefined && refId !== previousRefId) {\r\n                //\r\n                // enqueue onRemove if structure has been replaced.\r\n                //\r\n                const entries: IterableIterator<[any, any]> = (previousValue as any).entries();\r\n                let iter: IteratorResult<[any, any]>;\r\n                while ((iter = entries.next()) && !iter.done) {\r\n                    const [key, value] = iter.value;\r\n\r\n                    // if value is a schema, remove its reference\r\n                    if (typeof(value) === \"object\") {\r\n                        previousRefId = $root.refIds.get(value);\r\n                        $root.removeRef(previousRefId);\r\n                    }\r\n\r\n                    allChanges.push({\r\n                        ref: previousValue,\r\n                        refId: previousRefId,\r\n                        op: OPERATION.DELETE,\r\n                        field: key,\r\n                        value: undefined,\r\n                        previousValue: value,\r\n                    });\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n        $root.addRef(refId, value, (\r\n            valueRef !== previousValue ||\r\n            (operation === OPERATION.DELETE_AND_ADD && valueRef === previousValue)\r\n        ));\r\n    }\r\n\r\n    return { value, previousValue };\r\n}\r\n\r\nexport const decodeSchemaOperation: DecodeOperation = function <T extends Schema>(\r\n    decoder: Decoder<any>,\r\n    bytes: Buffer,\r\n    it: Iterator,\r\n    ref: T,\r\n    allChanges: DataChange[],\r\n) {\r\n    const first_byte = bytes[it.offset++];\r\n    const metadata: Metadata = (ref.constructor as typeof Schema)[Symbol.metadata];\r\n\r\n    // \"compressed\" index + operation\r\n    const operation = (first_byte >> 6) << 6\r\n    const index = first_byte % (operation || 255);\r\n\r\n    // skip early if field is not defined\r\n    const field = metadata[index];\r\n    if (field === undefined) {\r\n        console.warn(\"@colyseus/schema: field not defined at\", { index, ref: ref.constructor.name, metadata });\r\n        return DEFINITION_MISMATCH;\r\n    }\r\n\r\n    const { value, previousValue } = decodeValue(\r\n        decoder,\r\n        operation,\r\n        ref,\r\n        index,\r\n        field.type,\r\n        bytes,\r\n        it,\r\n        allChanges,\r\n    );\r\n\r\n    if (value !== null && value !== undefined) {\r\n        ref[field.name as keyof T] = value;\r\n    }\r\n\r\n    // add change\r\n    if (previousValue !== value) {\r\n        allChanges.push({\r\n            ref,\r\n            refId: decoder.currentRefId,\r\n            op: operation,\r\n            field: field.name,\r\n            value,\r\n            previousValue,\r\n        });\r\n    }\r\n}\r\n\r\nexport const decodeKeyValueOperation: DecodeOperation = function (\r\n    decoder: Decoder<any>,\r\n    bytes: Buffer,\r\n    it: Iterator,\r\n    ref: Ref,\r\n    allChanges: DataChange[]\r\n) {\r\n    // \"uncompressed\" index + operation (array/map items)\r\n    const operation = bytes[it.offset++];\r\n\r\n    if (operation === OPERATION.CLEAR) {\r\n        //\r\n        // When decoding:\r\n        // - enqueue items for DELETE callback.\r\n        // - flag child items for garbage collection.\r\n        //\r\n        decoder.removeChildRefs(ref as unknown as Collection, allChanges);\r\n\r\n        (ref as any).clear();\r\n        return;\r\n    }\r\n\r\n    const index = decode.number(bytes, it);\r\n    const type = (ref as any)[$childType];\r\n\r\n    let dynamicIndex: number | string;\r\n\r\n    if ((operation & OPERATION.ADD) === OPERATION.ADD) { // ADD or DELETE_AND_ADD\r\n        if (typeof((ref as any)['set']) === \"function\") {\r\n            dynamicIndex = decode.string(bytes, it); // MapSchema\r\n            (ref as any)['setIndex'](index, dynamicIndex);\r\n        } else {\r\n            dynamicIndex = index; // ArraySchema\r\n        }\r\n    } else {\r\n        // get dynamic index from \"ref\"\r\n        dynamicIndex = (ref as any)['getIndex'](index);\r\n    }\r\n\r\n    const { value, previousValue } = decodeValue(\r\n        decoder,\r\n        operation,\r\n        ref,\r\n        index,\r\n        type,\r\n        bytes,\r\n        it,\r\n        allChanges,\r\n    );\r\n\r\n    if (value !== null && value !== undefined) {\r\n        if (typeof((ref as any)['set']) === \"function\") {\r\n            // MapSchema\r\n            (ref as any)['$items'].set(dynamicIndex as string, value);\r\n\r\n        } else if (typeof((ref as any)['$setAt']) === \"function\") {\r\n            // ArraySchema\r\n            (ref as any)['$setAt'](index, value, operation);\r\n\r\n        } else if (typeof((ref as any)['add']) === \"function\") {\r\n            // CollectionSchema && SetSchema\r\n            const index = (ref as any).add(value);\r\n\r\n            if (typeof(index) === \"number\") {\r\n                (ref as any)['setIndex'](index, index);\r\n            }\r\n        }\r\n    }\r\n\r\n    // add change\r\n    if (previousValue !== value) {\r\n        allChanges.push({\r\n            ref,\r\n            refId: decoder.currentRefId,\r\n            op: operation,\r\n            field: \"\", // FIXME: remove this\r\n            dynamicIndex,\r\n            value,\r\n            previousValue,\r\n        });\r\n    }\r\n}\r\n\r\nexport const decodeArray: DecodeOperation = function (\r\n    decoder: Decoder<any>,\r\n    bytes: Buffer,\r\n    it: Iterator,\r\n    ref: ArraySchema,\r\n    allChanges: DataChange[]\r\n) {\r\n    // \"uncompressed\" index + operation (array/map items)\r\n    let operation = bytes[it.offset++];\r\n    let index: number;\r\n\r\n    if (operation === OPERATION.CLEAR) {\r\n        //\r\n        // When decoding:\r\n        // - enqueue items for DELETE callback.\r\n        // - flag child items for garbage collection.\r\n        //\r\n        decoder.removeChildRefs(ref as unknown as Collection, allChanges);\r\n        (ref as ArraySchema).clear();\r\n        return;\r\n\r\n    } else if (operation === OPERATION.REVERSE) {\r\n        (ref as ArraySchema).reverse();\r\n        return;\r\n\r\n    } else if (operation === OPERATION.DELETE_BY_REFID) {\r\n        // TODO: refactor here, try to follow same flow as below\r\n        const refId = decode.number(bytes, it);\r\n        const previousValue = decoder.root.refs.get(refId);\r\n        index = ref.findIndex((value) => value === previousValue);\r\n        ref[$deleteByIndex](index);\r\n        allChanges.push({\r\n            ref,\r\n            refId: decoder.currentRefId,\r\n            op: OPERATION.DELETE,\r\n            field: \"\", // FIXME: remove this\r\n            dynamicIndex: index,\r\n            value: undefined,\r\n            previousValue,\r\n        });\r\n\r\n        return;\r\n\r\n    } else if (operation === OPERATION.ADD_BY_REFID) {\r\n        const refId = decode.number(bytes, it);\r\n        const itemByRefId = decoder.root.refs.get(refId);\r\n\r\n        // if item already exists, use existing index\r\n        if (itemByRefId) {\r\n            index = ref.findIndex((value) => value === itemByRefId);\r\n        }\r\n\r\n        // fallback to use last index\r\n        if (index === -1 || index === undefined) {\r\n            index = ref.length;\r\n        }\r\n\r\n    } else {\r\n        index = decode.number(bytes, it);\r\n    }\r\n\r\n    const type = ref[$childType];\r\n\r\n    let dynamicIndex: number | string = index;\r\n\r\n    const { value, previousValue } = decodeValue(\r\n        decoder,\r\n        operation,\r\n        ref,\r\n        index,\r\n        type,\r\n        bytes,\r\n        it,\r\n        allChanges,\r\n    );\r\n\r\n    if (\r\n        value !== null && value !== undefined &&\r\n        value !== previousValue // avoid setting same value twice (if index === 0 it will result in a \"unshift\" for ArraySchema)\r\n    ) {\r\n        // ArraySchema\r\n        (ref as ArraySchema)['$setAt'](index, value, operation);\r\n    }\r\n\r\n    // add change\r\n    if (previousValue !== value) {\r\n        allChanges.push({\r\n            ref,\r\n            refId: decoder.currentRefId,\r\n            op: operation,\r\n            field: \"\", // FIXME: remove this\r\n            dynamicIndex,\r\n            value,\r\n            previousValue,\r\n        });\r\n    }\r\n}","import type { Schema } from \"../Schema\";\r\nimport type { CollectionSchema } from \"../types/custom/CollectionSchema\";\r\nimport type { MapSchema } from \"../types/custom/MapSchema\";\r\nimport type { SetSchema } from \"../types/custom/SetSchema\";\r\nimport type { ArraySchema } from \"../types/custom/ArraySchema\";\r\nimport type { Ref } from \"../encoder/ChangeTree\";\r\n\r\nexport class EncodeSchemaError extends Error {}\r\n\r\nexport function assertType(value: any, type: string, klass: Schema, field: string | number) {\r\n    let typeofTarget: string;\r\n    let allowNull: boolean = false;\r\n\r\n    switch (type) {\r\n        case \"number\":\r\n        case \"int8\":\r\n        case \"uint8\":\r\n        case \"int16\":\r\n        case \"uint16\":\r\n        case \"int32\":\r\n        case \"uint32\":\r\n        case \"int64\":\r\n        case \"uint64\":\r\n        case \"float32\":\r\n        case \"float64\":\r\n            typeofTarget = \"number\";\r\n            if (isNaN(value)) {\r\n                console.log(`trying to encode \"NaN\" in ${klass.constructor.name}#${field}`);\r\n            }\r\n            break;\r\n        case \"bigint64\":\r\n        case \"biguint64\":\r\n            typeofTarget = \"bigint\";\r\n            break;\r\n        case \"string\":\r\n            typeofTarget = \"string\";\r\n            allowNull = true;\r\n            break;\r\n        case \"boolean\":\r\n            // boolean is always encoded as true/false based on truthiness\r\n            return;\r\n        default:\r\n            // skip assertion for custom types\r\n            // TODO: allow custom types to define their own assertions\r\n            return;\r\n    }\r\n\r\n    if (typeof (value) !== typeofTarget && (!allowNull || (allowNull && value !== null))) {\r\n        let foundValue = `'${JSON.stringify(value)}'${(value && value.constructor && ` (${value.constructor.name})`) || ''}`;\r\n        throw new EncodeSchemaError(`a '${typeofTarget}' was expected, but ${foundValue} was provided in ${klass.constructor.name}#${field}`);\r\n    }\r\n}\r\n\r\nexport function assertInstanceType(\r\n    value: Ref,\r\n    type: typeof Schema\r\n        | typeof ArraySchema\r\n        | typeof MapSchema\r\n        | typeof CollectionSchema\r\n        | typeof SetSchema,\r\n    instance: Ref,\r\n    field: string | number,\r\n) {\r\n    if (!(value instanceof type)) {\r\n        throw new EncodeSchemaError(`a '${type.name}' was expected, but '${value && (value as any).constructor.name}' was provided in ${instance.constructor.name}#${field}`);\r\n    }\r\n}","import { $changes, $childType, $decoder, $deleteByIndex, $onEncodeEnd, $encoder, $filter, $getByIndex, $onDecodeEnd } from \"../symbols\";\r\nimport type { Schema } from \"../../Schema\";\r\nimport { type IRef, ChangeTree, setOperationAtIndex } from \"../../encoder/ChangeTree\";\r\nimport { OPERATION } from \"../../encoding/spec\";\r\nimport { registerType } from \"../registry\";\r\nimport { Collection } from \"../HelperTypes\";\r\n\r\nimport { encodeArray } from \"../../encoder/EncodeOperation\";\r\nimport { decodeArray } from \"../../decoder/DecodeOperation\";\r\nimport type { StateView } from \"../../encoder/StateView\";\r\nimport { assertInstanceType } from \"../../encoding/assert\";\r\n\r\nconst DEFAULT_SORT = (a: any, b: any) => {\r\n    const A = a.toString();\r\n    const B = b.toString();\r\n    if (A < B) return -1;\r\n    else if (A > B) return 1;\r\n    else return 0\r\n}\r\n\r\nexport class ArraySchema<V = any> implements Array<V>, Collection<number, V>, IRef {\r\n    [n: number]: V;\r\n    [$changes]: ChangeTree;\r\n\r\n    protected [$childType]: string | typeof Schema;\r\n\r\n    protected items: V[] = [];\r\n    protected tmpItems: V[] = [];\r\n    protected deletedIndexes: {[index: number]: boolean} = {};\r\n    protected isMovingItems = false;\r\n\r\n    static [$encoder] = encodeArray;\r\n    static [$decoder] = decodeArray;\r\n\r\n    /**\r\n     * Determine if a property must be filtered.\r\n     * - If returns false, the property is NOT going to be encoded.\r\n     * - If returns true, the property is going to be encoded.\r\n     *\r\n     * Encoding with \"filters\" happens in two steps:\r\n     * - First, the encoder iterates over all \"not owned\" properties and encodes them.\r\n     * - Then, the encoder iterates over all \"owned\" properties per instance and encodes them.\r\n     */\r\n    static [$filter] (ref: ArraySchema, index: number, view: StateView) {\r\n        return (\r\n            !view ||\r\n            typeof (ref[$childType]) === \"string\" ||\r\n            view.isChangeTreeVisible(ref['tmpItems'][index]?.[$changes])\r\n        );\r\n    }\r\n\r\n    static is(type: any) {\r\n        return (\r\n            // type format: [\"string\"]\r\n            Array.isArray(type) ||\r\n\r\n            // type format: { array: \"string\" }\r\n            (type['array'] !== undefined)\r\n        );\r\n    }\r\n\r\n    static from<T>(iterable: Iterable<T> | ArrayLike<T>) {\r\n        return new ArraySchema<T>(...Array.from(iterable));\r\n    }\r\n\r\n    constructor (...items: V[]) {\r\n        Object.defineProperty(this, $childType, {\r\n            value: undefined,\r\n            enumerable: false,\r\n            writable: true,\r\n            configurable: true,\r\n        });\r\n\r\n        const proxy = new Proxy(this, {\r\n            get: (obj, prop) => {\r\n                if (\r\n                    typeof (prop) !== \"symbol\" &&\r\n                    // FIXME: d8 accuses this as low performance\r\n                    !isNaN(prop as any) // https://stackoverflow.com/a/175787/892698\r\n                ) {\r\n                    return this.items[prop as unknown as number];\r\n\r\n                } else {\r\n                    return Reflect.get(obj, prop);\r\n                }\r\n            },\r\n\r\n            set: (obj, key, setValue) => {\r\n                if (typeof (key) !== \"symbol\" && !isNaN(key as any)) {\r\n                    if (setValue === undefined || setValue === null) {\r\n                        obj.$deleteAt(key as unknown as number);\r\n\r\n                    } else {\r\n                        if (setValue[$changes]) {\r\n                            assertInstanceType(setValue, obj[$childType] as typeof Schema, obj, key);\r\n\r\n                            const previousValue = obj.items[key as unknown as number];\r\n\r\n                            if (!obj.isMovingItems) {\r\n                                obj.$changeAt(Number(key), setValue);\r\n\r\n                            } else {\r\n                                if (previousValue !== undefined) {\r\n                                    if (setValue[$changes].isNew) {\r\n                                        obj[$changes].indexedOperation(Number(key), OPERATION.MOVE_AND_ADD);\r\n\r\n                                    } else {\r\n                                        if ((obj[$changes].getChange(Number(key)) & OPERATION.DELETE) === OPERATION.DELETE) {\r\n                                            obj[$changes].indexedOperation(Number(key), OPERATION.DELETE_AND_MOVE);\r\n\r\n                                        } else {\r\n                                            obj[$changes].indexedOperation(Number(key), OPERATION.MOVE);\r\n                                        }\r\n                                    }\r\n\r\n                                } else if (setValue[$changes].isNew) {\r\n                                    obj[$changes].indexedOperation(Number(key), OPERATION.ADD);\r\n                                }\r\n\r\n                                setValue[$changes].setParent(this, obj[$changes].root, key);\r\n                            }\r\n\r\n                            if (previousValue !== undefined) {\r\n                                // remove root reference from previous value\r\n                                previousValue[$changes].root?.remove(previousValue[$changes]);\r\n                            }\r\n\r\n                        } else {\r\n                            obj.$changeAt(Number(key), setValue);\r\n                        }\r\n\r\n                        obj.items[key as unknown as number] = setValue;\r\n                        obj.tmpItems[key as unknown as number] = setValue;\r\n                    }\r\n\r\n                    return true;\r\n                } else {\r\n                    return Reflect.set(obj, key, setValue);\r\n                }\r\n            },\r\n\r\n            deleteProperty: (obj, prop) => {\r\n                if (typeof (prop) === \"number\") {\r\n                    obj.$deleteAt(prop);\r\n\r\n                } else {\r\n                    delete obj[prop as unknown as number];\r\n                }\r\n\r\n                return true;\r\n            },\r\n\r\n            has: (obj, key) => {\r\n                if (typeof (key) !== \"symbol\" && !isNaN(Number(key))) {\r\n                    return Reflect.has(this.items, key);\r\n                }\r\n                return Reflect.has(obj, key)\r\n            }\r\n        });\r\n\r\n        Object.defineProperty(this, $changes, {\r\n            value: new ChangeTree(proxy),\r\n            enumerable: false,\r\n            writable: true,\r\n        });\r\n\r\n        if (items.length > 0) {\r\n            this.push(...items);\r\n        }\r\n\r\n        return proxy;\r\n    }\r\n\r\n    set length (newLength: number) {\r\n        if (newLength === 0) {\r\n            this.clear();\r\n        } else if (newLength < this.items.length) {\r\n            this.splice(newLength, this.length - newLength);\r\n        } else {\r\n            console.warn(\"ArraySchema: can't set .length to a higher value than its length.\");\r\n        }\r\n    }\r\n\r\n    get length() {\r\n        return this.items.length;\r\n    }\r\n\r\n    push(...values: V[]) {\r\n        let length = this.tmpItems.length;\r\n\r\n        const changeTree = this[$changes];\r\n\r\n        for (let i = 0, l = values.length; i < l; i++, length++) {\r\n            const value = values[i];\r\n\r\n            if (value === undefined || value === null) {\r\n                // skip null values\r\n                return;\r\n\r\n            } else if (typeof (value) === \"object\" && this[$childType]) {\r\n                assertInstanceType(value as any, this[$childType] as typeof Schema, this, i);\r\n                // TODO: move value[$changes]?.setParent() to this block.\r\n            }\r\n\r\n            changeTree.indexedOperation(length, OPERATION.ADD, this.items.length);\r\n\r\n            this.items.push(value);\r\n            this.tmpItems.push(value);\r\n\r\n            //\r\n            // set value's parent after the value is set\r\n            // (to avoid encoding \"refId\" operations before parent's \"ADD\" operation)\r\n            //\r\n            value[$changes]?.setParent(this, changeTree.root, length);\r\n        }\r\n\r\n        return length;\r\n    }\r\n\r\n    /**\r\n     * Removes the last element from an array and returns it.\r\n     */\r\n    pop(): V | undefined {\r\n        let index: number = -1;\r\n\r\n        // find last non-undefined index\r\n        for (let i = this.tmpItems.length - 1; i >= 0; i--) {\r\n            // if (this.tmpItems[i] !== undefined) {\r\n            if (this.deletedIndexes[i] !== true) {\r\n                index = i;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (index < 0) {\r\n            return undefined;\r\n        }\r\n\r\n        this[$changes].delete(index, undefined, this.items.length - 1);\r\n\r\n        this.deletedIndexes[index] = true;\r\n\r\n        return this.items.pop();\r\n    }\r\n\r\n    at(index: number) {\r\n        // Allow negative indexing from the end\r\n        if (index < 0) index += this.length;\r\n        return this.items[index];\r\n    }\r\n\r\n    // encoding only\r\n    protected $changeAt(index: number, value: V) {\r\n        if (value === undefined || value === null) {\r\n            console.error(\"ArraySchema items cannot be null nor undefined; Use `deleteAt(index)` instead.\");\r\n            return;\r\n        }\r\n\r\n        // skip if the value is the same as cached.\r\n        if (this.items[index] === value) {\r\n            return;\r\n        }\r\n\r\n        const operation = (this.items[index] !== undefined)\r\n            ? typeof(value) === \"object\"\r\n                ? OPERATION.DELETE_AND_ADD // schema child\r\n                : OPERATION.REPLACE // primitive\r\n            : OPERATION.ADD;\r\n\r\n        const changeTree = this[$changes];\r\n        changeTree.change(index, operation);\r\n\r\n        //\r\n        // set value's parent after the value is set\r\n        // (to avoid encoding \"refId\" operations before parent's \"ADD\" operation)\r\n        //\r\n        value[$changes]?.setParent(this, changeTree.root, index);\r\n    }\r\n\r\n    // encoding only\r\n    protected $deleteAt(index: number, operation?: OPERATION) {\r\n        this[$changes].delete(index, operation);\r\n    }\r\n\r\n    // decoding only\r\n    protected $setAt(index: number, value: V, operation: OPERATION) {\r\n        if (\r\n            index === 0 &&\r\n            operation === OPERATION.ADD &&\r\n            this.items[index] !== undefined\r\n        ) {\r\n            // handle decoding unshift\r\n            this.items.unshift(value);\r\n\r\n        } else if (operation === OPERATION.DELETE_AND_MOVE) {\r\n            this.items.splice(index, 1);\r\n            this.items[index] = value;\r\n\r\n        } else {\r\n            this.items[index] = value;\r\n        }\r\n    }\r\n\r\n    clear() {\r\n        // skip if already clear\r\n        if (this.items.length === 0) {\r\n            return;\r\n        }\r\n\r\n        // discard previous operations.\r\n        const changeTree = this[$changes];\r\n\r\n        // remove children references\r\n        changeTree.forEachChild((childChangeTree, _) => {\r\n            changeTree.root?.remove(childChangeTree);\r\n        });\r\n\r\n        changeTree.discard(true);\r\n        changeTree.operation(OPERATION.CLEAR);\r\n\r\n        this.items.length = 0;\r\n        this.tmpItems.length = 0;\r\n    }\r\n\r\n    /**\r\n     * Combines two or more arrays.\r\n     * @param items Additional items to add to the end of array1.\r\n     */\r\n    // @ts-ignore\r\n    concat(...items: (V | ConcatArray<V>)[]): ArraySchema<V> {\r\n        return new ArraySchema(...this.items.concat(...items));\r\n    }\r\n\r\n    /**\r\n     * Adds all the elements of an array separated by the specified separator string.\r\n     * @param separator A string used to separate one element of an array from the next in the resulting String. If omitted, the array elements are separated with a comma.\r\n     */\r\n    join(separator?: string): string {\r\n        return this.items.join(separator);\r\n    }\r\n\r\n    /**\r\n     * Reverses the elements in an Array.\r\n     */\r\n    // @ts-ignore\r\n    reverse(): ArraySchema<V> {\r\n        this[$changes].operation(OPERATION.REVERSE);\r\n        this.items.reverse();\r\n        this.tmpItems.reverse();\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Removes the first element from an array and returns it.\r\n     */\r\n    shift(): V | undefined {\r\n        if (this.items.length === 0) { return undefined; }\r\n\r\n        const changeTree = this[$changes];\r\n\r\n        const index = this.tmpItems.findIndex(item => item === this.items[0]);\r\n        const allChangesIndex = this.items.findIndex(item => item === this.items[0]);\r\n\r\n        changeTree.delete(index, OPERATION.DELETE, allChangesIndex);\r\n        changeTree.shiftAllChangeIndexes(-1, allChangesIndex);\r\n\r\n        this.deletedIndexes[index] = true;\r\n\r\n        return this.items.shift();\r\n    }\r\n\r\n    /**\r\n     * Returns a section of an array.\r\n     * @param start The beginning of the specified portion of the array.\r\n     * @param end The end of the specified portion of the array. This is exclusive of the element at the index 'end'.\r\n     */\r\n    slice(start?: number, end?: number): V[] {\r\n        const sliced = new ArraySchema<V>();\r\n        sliced.push(...this.items.slice(start, end));\r\n        return sliced as unknown as V[];\r\n    }\r\n\r\n    /**\r\n     * Sorts an array.\r\n     * @param compareFn Function used to determine the order of the elements. It is expected to return\r\n     * a negative value if first argument is less than second argument, zero if they're equal and a positive\r\n     * value otherwise. If omitted, the elements are sorted in ascending, ASCII character order.\r\n     * ```ts\r\n     * [11,2,22,1].sort((a, b) => a - b)\r\n     * ```\r\n     */\r\n    sort(compareFn: (a: V, b: V) => number = DEFAULT_SORT): this {\r\n        this.isMovingItems = true;\r\n\r\n        const changeTree = this[$changes];\r\n        const sortedItems = this.items.sort(compareFn);\r\n\r\n        // wouldn't OPERATION.MOVE make more sense here?\r\n        sortedItems.forEach((_, i) => changeTree.change(i, OPERATION.REPLACE));\r\n\r\n        this.tmpItems.sort(compareFn);\r\n\r\n        this.isMovingItems = false;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Removes elements from an array and, if necessary, inserts new elements in their place, returning the deleted elements.\r\n     * @param start The zero-based location in the array from which to start removing elements.\r\n     * @param deleteCount The number of elements to remove.\r\n     * @param insertItems Elements to insert into the array in place of the deleted elements.\r\n     */\r\n    splice(\r\n        start: number,\r\n        deleteCount?: number,\r\n        ...insertItems: V[]\r\n    ): V[] {\r\n        const changeTree = this[$changes];\r\n\r\n        const itemsLength = this.items.length;\r\n        const tmpItemsLength = this.tmpItems.length;\r\n        const insertCount = insertItems.length;\r\n\r\n        // build up-to-date list of indexes, excluding removed values.\r\n        const indexes: number[] = [];\r\n        for (let i = 0; i < tmpItemsLength; i++) {\r\n            if (this.deletedIndexes[i] !== true) {\r\n                indexes.push(i);\r\n            }\r\n        }\r\n\r\n        if (itemsLength > start) {\r\n            // if deleteCount is not provided, delete all items from start to end\r\n            if (deleteCount === undefined) {\r\n                deleteCount = itemsLength - start;\r\n            }\r\n\r\n            //\r\n            // delete operations at correct index\r\n            //\r\n            for (let i = start; i < start + deleteCount; i++) {\r\n                const index = indexes[i];\r\n                changeTree.delete(index, OPERATION.DELETE);\r\n                this.deletedIndexes[index] = true;\r\n            }\r\n\r\n        } else {\r\n            // not enough items to delete\r\n            deleteCount = 0;\r\n        }\r\n\r\n        // insert operations\r\n        if (insertCount > 0) {\r\n            if (insertCount > deleteCount) {\r\n                console.error(\"Inserting more elements than deleting during ArraySchema#splice()\");\r\n                throw new Error(\"ArraySchema#splice(): insertCount must be equal or lower than deleteCount.\");\r\n            }\r\n\r\n            for (let i = 0; i < insertCount; i++) {\r\n                const addIndex = (indexes[start] ?? itemsLength) + i;\r\n\r\n                changeTree.indexedOperation(\r\n                    addIndex,\r\n                    (this.deletedIndexes[addIndex])\r\n                        ? OPERATION.DELETE_AND_ADD\r\n                        : OPERATION.ADD\r\n                );\r\n\r\n                // set value's parent/root\r\n                insertItems[i][$changes]?.setParent(this, changeTree.root, addIndex);\r\n            }\r\n        }\r\n\r\n        //\r\n        // delete exceeding indexes from \"allChanges\"\r\n        // (prevent .encodeAll() from encoding non-existing items)\r\n        //\r\n        if (deleteCount > insertCount) {\r\n            changeTree.shiftAllChangeIndexes(-(deleteCount - insertCount), indexes[start + insertCount]);\r\n            // debugChangeSet(\"AFTER SHIFT indexes\", changeTree.allChanges);\r\n        }\r\n\r\n        //\r\n        // FIXME: this code block is duplicated on ChangeTree\r\n        //\r\n        if (changeTree.filteredChanges !== undefined) {\r\n            changeTree.root?.enqueueChangeTree(changeTree, 'filteredChanges');\r\n\r\n        } else {\r\n            changeTree.root?.enqueueChangeTree(changeTree, 'changes');\r\n        }\r\n\r\n        return this.items.splice(start, deleteCount, ...insertItems);\r\n    }\r\n\r\n    /**\r\n     * Inserts new elements at the start of an array.\r\n     * @param items  Elements to insert at the start of the Array.\r\n     */\r\n    unshift(...items: V[]): number {\r\n        const changeTree = this[$changes];\r\n\r\n        // shift indexes\r\n        changeTree.shiftChangeIndexes(items.length);\r\n\r\n        // new index\r\n        if (changeTree.isFiltered) {\r\n            setOperationAtIndex(changeTree.filteredChanges, this.items.length);\r\n            // changeTree.filteredChanges[this.items.length] = OPERATION.ADD;\r\n        } else {\r\n            setOperationAtIndex(changeTree.allChanges, this.items.length);\r\n            // changeTree.allChanges[this.items.length] = OPERATION.ADD;\r\n        }\r\n\r\n        // FIXME: should we use OPERATION.MOVE here instead?\r\n        items.forEach((_, index) => {\r\n            changeTree.change(index, OPERATION.ADD)\r\n        });\r\n\r\n        this.tmpItems.unshift(...items);\r\n\r\n        return this.items.unshift(...items);\r\n    }\r\n\r\n    /**\r\n     * Returns the index of the first occurrence of a value in an array.\r\n     * @param searchElement The value to locate in the array.\r\n     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at index 0.\r\n     */\r\n    indexOf(searchElement: V, fromIndex?: number): number {\r\n        return this.items.indexOf(searchElement, fromIndex);\r\n    }\r\n\r\n    /**\r\n     * Returns the index of the last occurrence of a specified value in an array.\r\n     * @param searchElement The value to locate in the array.\r\n     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at the last index in the array.\r\n     */\r\n    lastIndexOf(searchElement: V, fromIndex: number = this.length - 1): number {\r\n        return this.items.lastIndexOf(searchElement, fromIndex);\r\n    }\r\n\r\n    /**\r\n     * Determines whether all the members of an array satisfy the specified test.\r\n     * @param callbackfn A function that accepts up to three arguments. The every method calls\r\n     * the callbackfn function for each element in the array until the callbackfn returns a value\r\n     * which is coercible to the Boolean value false, or until the end of the array.\r\n     * @param thisArg An object to which the this keyword can refer in the callbackfn function.\r\n     * If thisArg is omitted, undefined is used as the this value.\r\n     */\r\n    every<S extends V>(predicate: (value: V, index: number, array: V[]) => value is S, thisArg?: any): this is S[];\r\n    every(callbackfn: (value: V, index: number, array: V[]) => unknown, thisArg?: any): boolean;\r\n    every(callbackfn: (value: V, index: number, array: V[]) => unknown, thisArg?: any): boolean {\r\n        return this.items.every(callbackfn, thisArg);\r\n    }\r\n\r\n    /**\r\n     * Determines whether the specified callback function returns true for any element of an array.\r\n     * @param callbackfn A function that accepts up to three arguments. The some method calls\r\n     * the callbackfn function for each element in the array until the callbackfn returns a value\r\n     * which is coercible to the Boolean value true, or until the end of the array.\r\n     * @param thisArg An object to which the this keyword can refer in the callbackfn function.\r\n     * If thisArg is omitted, undefined is used as the this value.\r\n     */\r\n    some(callbackfn: (value: V, index: number, array: V[]) => unknown, thisArg?: any): boolean {\r\n        return this.items.some(callbackfn, thisArg);\r\n    }\r\n\r\n    /**\r\n     * Performs the specified action for each element in an array.\r\n     * @param callbackfn  A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array.\r\n     * @param thisArg  An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.\r\n     */\r\n    forEach(callbackfn: (value: V, index: number, array: V[]) => void, thisArg?: any): void {\r\n        return this.items.forEach(callbackfn, thisArg);\r\n    }\r\n\r\n    /**\r\n     * Calls a defined callback function on each element of an array, and returns an array that contains the results.\r\n     * @param callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array.\r\n     * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.\r\n     */\r\n    map<U>(callbackfn: (value: V, index: number, array: V[]) => U, thisArg?: any): U[] {\r\n        return this.items.map(callbackfn, thisArg);\r\n    }\r\n\r\n    /**\r\n     * Returns the elements of an array that meet the condition specified in a callback function.\r\n     * @param callbackfn A function that accepts up to three arguments. The filter method calls the callbackfn function one time for each element in the array.\r\n     * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.\r\n     */\r\n    filter(callbackfn: (value: V, index: number, array: V[]) => unknown, thisArg?: any): V[]\r\n    filter<S extends V>(callbackfn: (value: V, index: number, array: V[]) => value is S, thisArg?: any): V[] {\r\n        return this.items.filter(callbackfn, thisArg);\r\n    }\r\n\r\n    /**\r\n     * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.\r\n     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.\r\n     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.\r\n     */\r\n    reduce<U=V>(callbackfn: (previousValue: U, currentValue: V, currentIndex: number, array: V[]) => U, initialValue?: U): U {\r\n        return this.items.reduce(callbackfn, initialValue);\r\n    }\r\n\r\n    /**\r\n     * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.\r\n     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.\r\n     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.\r\n     */\r\n    reduceRight<U=V>(callbackfn: (previousValue: U, currentValue: V, currentIndex: number, array: V[]) => U, initialValue?: U): U {\r\n        return this.items.reduceRight(callbackfn, initialValue);\r\n    }\r\n\r\n    /**\r\n     * Returns the value of the first element in the array where predicate is true, and undefined\r\n     * otherwise.\r\n     * @param predicate find calls predicate once for each element of the array, in ascending\r\n     * order, until it finds one where predicate returns true. If such an element is found, find\r\n     * immediately returns that element value. Otherwise, find returns undefined.\r\n     * @param thisArg If provided, it will be used as the this value for each invocation of\r\n     * predicate. If it is not provided, undefined is used instead.\r\n     */\r\n    find(predicate: (value: V, index: number, obj: V[]) => boolean, thisArg?: any): V | undefined {\r\n        return this.items.find(predicate, thisArg);\r\n    }\r\n\r\n    /**\r\n     * Returns the index of the first element in the array where predicate is true, and -1\r\n     * otherwise.\r\n     * @param predicate find calls predicate once for each element of the array, in ascending\r\n     * order, until it finds one where predicate returns true. If such an element is found,\r\n     * findIndex immediately returns that element index. Otherwise, findIndex returns -1.\r\n     * @param thisArg If provided, it will be used as the this value for each invocation of\r\n     * predicate. If it is not provided, undefined is used instead.\r\n     */\r\n    findIndex(predicate: (value: V, index: number, obj: V[]) => unknown, thisArg?: any): number {\r\n        return this.items.findIndex(predicate, thisArg);\r\n    }\r\n\r\n    /**\r\n     * Returns the this object after filling the section identified by start and end with value\r\n     * @param value value to fill array section with\r\n     * @param start index to start filling the array at. If start is negative, it is treated as\r\n     * length+start where length is the length of the array.\r\n     * @param end index to stop filling the array at. If end is negative, it is treated as\r\n     * length+end.\r\n     */\r\n    fill(value: V, start?: number, end?: number): this {\r\n        //\r\n        // TODO\r\n        //\r\n        throw new Error(\"ArraySchema#fill() not implemented\");\r\n        // this.$items.fill(value, start, end);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns the this object after copying a section of the array identified by start and end\r\n     * to the same array starting at position target\r\n     * @param target If target is negative, it is treated as length+target where length is the\r\n     * length of the array.\r\n     * @param start If start is negative, it is treated as length+start. If end is negative, it\r\n     * is treated as length+end.\r\n     * @param end If not specified, length of the this object is used as its default value.\r\n     */\r\n    copyWithin(target: number, start: number, end?: number): this {\r\n        //\r\n        // TODO\r\n        //\r\n        throw new Error(\"ArraySchema#copyWithin() not implemented\");\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns a string representation of an array.\r\n     */\r\n    toString(): string {\r\n        return this.items.toString();\r\n    }\r\n\r\n    /**\r\n     * Returns a string representation of an array. The elements are converted to string using their toLocalString methods.\r\n     */\r\n    toLocaleString(): string {\r\n        return this.items.toLocaleString()\r\n    };\r\n\r\n    /** Iterator */\r\n    [Symbol.iterator](): ArrayIterator<V> {\r\n        return this.items[Symbol.iterator]();\r\n    }\r\n\r\n    static get [Symbol.species]() {\r\n        return ArraySchema;\r\n    }\r\n\r\n    // WORKAROUND for compatibility\r\n    // - TypeScript 4 defines @@unscopables as a function\r\n    // - TypeScript 5 defines @@unscopables as an object\r\n    [Symbol.unscopables]: any;\r\n\r\n    /**\r\n     * Returns an iterable of key, value pairs for every entry in the array\r\n     */\r\n    entries(): ArrayIterator<[number, V]> { return this.items.entries(); }\r\n\r\n    /**\r\n     * Returns an iterable of keys in the array\r\n     */\r\n    keys(): ArrayIterator<number> { return this.items.keys(); }\r\n\r\n    /**\r\n     * Returns an iterable of values in the array\r\n     */\r\n    values(): ArrayIterator<V> { return this.items.values(); }\r\n\r\n    /**\r\n     * Determines whether an array includes a certain element, returning true or false as appropriate.\r\n     * @param searchElement The element to search for.\r\n     * @param fromIndex The position in this array at which to begin searching for searchElement.\r\n     */\r\n    includes(searchElement: V, fromIndex?: number): boolean {\r\n        return this.items.includes(searchElement, fromIndex);\r\n    }\r\n\r\n    //\r\n    // ES2022\r\n    //\r\n\r\n    /**\r\n     * Calls a defined callback function on each element of an array. Then, flattens the result into\r\n     * a new array.\r\n     * This is identical to a map followed by flat with depth 1.\r\n     *\r\n     * @param callback A function that accepts up to three arguments. The flatMap method calls the\r\n     * callback function one time for each element in the array.\r\n     * @param thisArg An object to which the this keyword can refer in the callback function. If\r\n     * thisArg is omitted, undefined is used as the this value.\r\n     */\r\n    // @ts-ignore\r\n    flatMap<U, This = undefined>(callback: (this: This, value: V, index: number, array: V[]) => U | ReadonlyArray<U>, thisArg?: This): U[] {\r\n        // @ts-ignore\r\n        throw new Error(\"ArraySchema#flatMap() is not supported.\");\r\n    }\r\n\r\n    /**\r\n     * Returns a new array with all sub-array elements concatenated into it recursively up to the\r\n     * specified depth.\r\n     *\r\n     * @param depth The maximum recursion depth\r\n     */\r\n    // @ts-ignore\r\n    flat<A, D extends number = 1>(this: A, depth?: D): any {\r\n        throw new Error(\"ArraySchema#flat() is not supported.\");\r\n    }\r\n\r\n    findLast() {\r\n        // @ts-ignore\r\n        return this.items.findLast.apply(this.items, arguments);\r\n    }\r\n\r\n    findLastIndex(...args: any[]) {\r\n        // @ts-ignore\r\n        return this.items.findLastIndex.apply(this.items, arguments);\r\n    }\r\n\r\n    //\r\n    // ES2023\r\n    //\r\n    with(index: number, value: V): ArraySchema<V> {\r\n        const copy = this.items.slice();\r\n        // Allow negative indexing from the end\r\n        if (index < 0) index += this.length;\r\n        copy[index] = value;\r\n        return new ArraySchema(...copy);\r\n    }\r\n    toReversed(): V[] {\r\n        return this.items.slice().reverse();\r\n    }\r\n    toSorted(compareFn?: (a: V, b: V) => number): V[] {\r\n        return this.items.slice().sort(compareFn);\r\n    }\r\n    toSpliced(start: number, deleteCount: number, ...items: V[]): V[];\r\n    toSpliced(start: number, deleteCount?: number): V[];\r\n    // @ts-ignore\r\n    toSpliced(start: unknown, deleteCount?: unknown, ...items?: unknown[]): V[] {\r\n        // @ts-ignore\r\n        return this.items.toSpliced.apply(copy, arguments);\r\n    }\r\n\r\n    shuffle() {\r\n        return this.move((_) => {\r\n            let currentIndex = this.items.length;\r\n            while (currentIndex != 0) {\r\n                let randomIndex = Math.floor(Math.random() * currentIndex);\r\n                currentIndex--;\r\n                [this[currentIndex], this[randomIndex]] = [this[randomIndex], this[currentIndex]];\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Allows to move items around in the array.\r\n     *\r\n     * Example:\r\n     *     state.cards.move((cards) => {\r\n     *         [cards[4], cards[3]] = [cards[3], cards[4]];\r\n     *         [cards[3], cards[2]] = [cards[2], cards[3]];\r\n     *         [cards[2], cards[0]] = [cards[0], cards[2]];\r\n     *         [cards[1], cards[1]] = [cards[1], cards[1]];\r\n     *         [cards[0], cards[0]] = [cards[0], cards[0]];\r\n     *     })\r\n     *\r\n     * @param cb\r\n     * @returns\r\n     */\r\n    move(cb: (arr: this) => void) {\r\n        this.isMovingItems = true;\r\n        cb(this);\r\n        this.isMovingItems = false;\r\n        return this;\r\n    }\r\n\r\n    [$getByIndex](index: number, isEncodeAll: boolean = false): any {\r\n        //\r\n        // TODO: avoid unecessary `this.tmpItems` check during decoding.\r\n        //\r\n        //    ENCODING uses `this.tmpItems` (or `this.items` if `isEncodeAll` is true)\r\n        //    DECODING uses `this.items`\r\n        //\r\n\r\n        return (isEncodeAll)\r\n            ? this.items[index]\r\n            : this.deletedIndexes[index]\r\n                ? this.items[index]\r\n                : this.tmpItems[index] || this.items[index];\r\n    }\r\n\r\n    [$deleteByIndex](index: number): void {\r\n        this.items[index] = undefined;\r\n        this.tmpItems[index] = undefined; // TODO: do not try to get \"tmpItems\" at decoding time.\r\n    }\r\n\r\n    protected [$onEncodeEnd]() {\r\n        this.tmpItems = this.items.slice();\r\n        this.deletedIndexes = {};\r\n    }\r\n\r\n    protected [$onDecodeEnd]() {\r\n        this.items = this.items.filter((item) => item !== undefined);\r\n        this.tmpItems = this.items.slice(); // TODO: do no use \"tmpItems\" at decoding time.\r\n    }\r\n\r\n    toArray() {\r\n        return this.items.slice(0);\r\n    }\r\n\r\n    toJSON() {\r\n        return this.toArray().map((value: any) => {\r\n            return (typeof (value['toJSON']) === \"function\")\r\n                ? value['toJSON']()\r\n                : value;\r\n        });\r\n    }\r\n\r\n    //\r\n    // Decoding utilities\r\n    //\r\n    clone(isDecoding?: boolean): ArraySchema<V> {\r\n        let cloned: ArraySchema;\r\n\r\n        if (isDecoding) {\r\n            cloned = new ArraySchema();\r\n            cloned.push(...this.items);\r\n\r\n        } else {\r\n            cloned = new ArraySchema(...this.map(item => (\r\n                (item[$changes])\r\n                    ? (item as any as Schema).clone()\r\n                    : item\r\n            )));\r\n        }\r\n\r\n        return cloned;\r\n    };\r\n\r\n}\r\n\r\nregisterType(\"array\", { constructor: ArraySchema });\r\n","import { $changes, $childType, $decoder, $deleteByIndex, $onEncodeEnd, $encoder, $filter, $getByIndex, $numFields } from \"../symbols\";\r\nimport { ChangeTree, IRef } from \"../../encoder/ChangeTree\";\r\nimport { OPERATION } from \"../../encoding/spec\";\r\nimport { registerType } from \"../registry\";\r\nimport { Collection } from \"../HelperTypes\";\r\nimport { decodeKeyValueOperation } from \"../../decoder/DecodeOperation\";\r\nimport { encodeKeyValueOperation } from \"../../encoder/EncodeOperation\";\r\nimport type { StateView } from \"../../encoder/StateView\";\r\nimport type { Schema } from \"../../Schema\";\r\nimport { assertInstanceType } from \"../../encoding/assert\";\r\n\r\nexport class MapSchema<V=any, K extends string = string> implements Map<K, V>, Collection<K, V, [K, V]>, IRef {\r\n    protected childType: new () => V;\r\n    [$changes]: ChangeTree;\r\n    protected [$childType]: string | typeof Schema;\r\n\r\n    protected $items: Map<K, V> = new Map<K, V>();\r\n    protected $indexes: Map<number, K> = new Map<number, K>();\r\n    protected deletedItems: { [index: string]: V } = {};\r\n\r\n    static [$encoder] = encodeKeyValueOperation;\r\n    static [$decoder] = decodeKeyValueOperation;\r\n\r\n    /**\r\n     * Determine if a property must be filtered.\r\n     * - If returns false, the property is NOT going to be encoded.\r\n     * - If returns true, the property is going to be encoded.\r\n     *\r\n     * Encoding with \"filters\" happens in two steps:\r\n     * - First, the encoder iterates over all \"not owned\" properties and encodes them.\r\n     * - Then, the encoder iterates over all \"owned\" properties per instance and encodes them.\r\n     */\r\n    static [$filter] (ref: MapSchema, index: number, view: StateView) {\r\n        return (\r\n            !view ||\r\n            typeof (ref[$childType]) === \"string\" ||\r\n            view.isChangeTreeVisible((ref[$getByIndex](index) ?? ref.deletedItems[index])[$changes])\r\n        );\r\n    }\r\n\r\n    static is(type: any) {\r\n        return type['map'] !== undefined;\r\n    }\r\n\r\n    constructor (initialValues?: Map<K, V> | Record<K, V>) {\r\n        const changeTree = new ChangeTree(this);\r\n        changeTree.indexes = {};\r\n\r\n        Object.defineProperty(this, $changes, {\r\n            value: changeTree,\r\n            enumerable: false,\r\n            writable: true,\r\n        });\r\n\r\n        if (initialValues) {\r\n            if (\r\n                initialValues instanceof Map ||\r\n                initialValues instanceof MapSchema\r\n            ) {\r\n                initialValues.forEach((v, k) => this.set(k, v));\r\n\r\n            } else {\r\n                for (const k in initialValues) {\r\n                    this.set(k, initialValues[k]);\r\n                }\r\n            }\r\n        }\r\n\r\n        Object.defineProperty(this, $childType, {\r\n            value: undefined,\r\n            enumerable: false,\r\n            writable: true,\r\n            configurable: true,\r\n        });\r\n    }\r\n\r\n    /** Iterator */\r\n    [Symbol.iterator](): IterableIterator<[K, V]> { return this.$items[Symbol.iterator](); }\r\n    get [Symbol.toStringTag]() { return this.$items[Symbol.toStringTag] }\r\n\r\n    static get [Symbol.species]() { return MapSchema; }\r\n\r\n    set(key: K, value: V) {\r\n        if (value === undefined || value === null) {\r\n            throw new Error(`MapSchema#set('${key}', ${value}): trying to set ${value} value on '${key}'.`);\r\n\r\n        } else if (typeof(value) === \"object\" && this[$childType]) {\r\n            assertInstanceType(value as any, this[$childType] as typeof Schema, this, key);\r\n        }\r\n\r\n        // Force \"key\" as string\r\n        // See: https://github.com/colyseus/colyseus/issues/561#issuecomment-1646733468\r\n        key = key.toString() as K;\r\n\r\n        const changeTree = this[$changes];\r\n        const isRef = (value[$changes]) !== undefined;\r\n\r\n        let index: number;\r\n        let operation: OPERATION;\r\n\r\n        // IS REPLACE?\r\n        if (typeof(changeTree.indexes[key]) !== \"undefined\") {\r\n            index = changeTree.indexes[key];\r\n            operation = OPERATION.REPLACE;\r\n\r\n            const previousValue = this.$items.get(key);\r\n            if (previousValue === value) {\r\n                // if value is the same, avoid re-encoding it.\r\n                return;\r\n\r\n            } else if (isRef) {\r\n                // if is schema, force ADD operation if value differ from previous one.\r\n                operation = OPERATION.DELETE_AND_ADD;\r\n\r\n                // remove reference from previous value\r\n                if (previousValue !== undefined) {\r\n                    previousValue[$changes].root?.remove(previousValue[$changes]);\r\n                }\r\n            }\r\n\r\n            if (this.deletedItems[index]) {\r\n                delete this.deletedItems[index];\r\n            }\r\n\r\n        } else {\r\n            index = changeTree.indexes[$numFields] ?? 0;\r\n            operation = OPERATION.ADD;\r\n\r\n            this.$indexes.set(index, key);\r\n            changeTree.indexes[key] = index;\r\n            changeTree.indexes[$numFields] = index + 1;\r\n        }\r\n\r\n        this.$items.set(key, value);\r\n\r\n        changeTree.change(index, operation);\r\n\r\n        //\r\n        // set value's parent after the value is set\r\n        // (to avoid encoding \"refId\" operations before parent's \"ADD\" operation)\r\n        //\r\n        if (isRef) {\r\n            value[$changes].setParent(this, changeTree.root, index);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    get(key: K): V | undefined {\r\n        return this.$items.get(key);\r\n    }\r\n\r\n    delete(key: K) {\r\n        if (!this.$items.has(key)) {\r\n            return false;\r\n        }\r\n\r\n        const index = this[$changes].indexes[key];\r\n\r\n        this.deletedItems[index] = this[$changes].delete(index);\r\n\r\n        return this.$items.delete(key);\r\n    }\r\n\r\n    clear() {\r\n        const changeTree = this[$changes];\r\n\r\n        // discard previous operations.\r\n        changeTree.discard(true);\r\n        changeTree.indexes = {};\r\n\r\n        // remove children references\r\n        changeTree.forEachChild((childChangeTree, _) => {\r\n            changeTree.root?.remove(childChangeTree);\r\n        });\r\n\r\n        // clear previous indexes\r\n        this.$indexes.clear();\r\n\r\n        // clear items\r\n        this.$items.clear();\r\n\r\n        changeTree.operation(OPERATION.CLEAR);\r\n    }\r\n\r\n    has (key: K) {\r\n        return this.$items.has(key);\r\n    }\r\n\r\n    forEach(callbackfn: (value: V, key: K, map: Map<K, V>) => void) {\r\n        this.$items.forEach(callbackfn);\r\n    }\r\n\r\n    entries () {\r\n        return this.$items.entries();\r\n    }\r\n\r\n    keys () {\r\n        return this.$items.keys();\r\n    }\r\n\r\n    values() {\r\n        return this.$items.values();\r\n    }\r\n\r\n    get size () {\r\n        return this.$items.size;\r\n    }\r\n\r\n    protected setIndex(index: number, key: K) {\r\n        this.$indexes.set(index, key);\r\n    }\r\n\r\n    protected getIndex(index: number) {\r\n        return this.$indexes.get(index);\r\n    }\r\n\r\n    [$getByIndex](index: number): V | undefined {\r\n        return this.$items.get(this.$indexes.get(index));\r\n    }\r\n\r\n    [$deleteByIndex](index: number): void {\r\n        const key = this.$indexes.get(index);\r\n        this.$items.delete(key);\r\n        this.$indexes.delete(index);\r\n    }\r\n\r\n    protected [$onEncodeEnd]() {\r\n        const changeTree = this[$changes];\r\n\r\n        // - cleanup changeTree.indexes\r\n        // - cleanup $indexes\r\n        for (const indexStr in this.deletedItems) {\r\n            const index = parseInt(indexStr);\r\n            const key = this.$indexes.get(index);\r\n            // TODO: refactor this.\r\n            // it shouldn't be necessary to keep track of indexes both on changeTree and on $indexes\r\n            delete changeTree.indexes[key];\r\n            this.$indexes.delete(index);\r\n        }\r\n\r\n        this.deletedItems = {};\r\n    }\r\n\r\n    toJSON() {\r\n        const map: any = {};\r\n\r\n        this.forEach((value: any, key) => {\r\n            map[key] = (typeof (value['toJSON']) === \"function\")\r\n                ? value['toJSON']()\r\n                : value;\r\n        });\r\n\r\n        return map;\r\n    }\r\n\r\n    //\r\n    // Decoding utilities\r\n    //\r\n    // @ts-ignore\r\n    clone(isDecoding?: boolean): MapSchema<V> {\r\n        let cloned: MapSchema<V>;\r\n\r\n        if (isDecoding) {\r\n            // client-side\r\n            cloned = Object.assign(new MapSchema(), this);\r\n\r\n        } else {\r\n            // server-side\r\n            cloned = new MapSchema();\r\n\r\n            this.forEach((value: any, key) => {\r\n                if (value[$changes]) {\r\n                    cloned.set(key, value['clone']());\r\n                } else {\r\n                    cloned.set(key, value);\r\n                }\r\n            })\r\n\r\n        }\r\n\r\n        return cloned;\r\n    }\r\n\r\n}\r\n\r\nregisterType(\"map\", { constructor: MapSchema });\r\n","import { $changes, $childType, $decoder, $deleteByIndex, $encoder, $filter, $getByIndex, $onEncodeEnd } from \"../symbols\";\r\nimport { ChangeTree, type IRef } from \"../../encoder/ChangeTree\";\r\nimport { OPERATION } from \"../../encoding/spec\";\r\nimport { registerType } from \"../registry\";\r\nimport { Collection } from \"../HelperTypes\";\r\nimport { decodeKeyValueOperation } from \"../../decoder/DecodeOperation\";\r\nimport { encodeKeyValueOperation } from \"../../encoder/EncodeOperation\";\r\nimport type { StateView } from \"../../encoder/StateView\";\r\nimport type { Schema } from \"../../Schema\";\r\n\r\ntype K = number; // TODO: allow to specify K generic on MapSchema.\r\n\r\nexport class CollectionSchema<V=any> implements Collection<K, V>, IRef {\r\n    public [$changes]: ChangeTree;\r\n    protected [$childType]: string | typeof Schema;\r\n\r\n    protected $items: Map<number, V> = new Map<number, V>();\r\n    protected $indexes: Map<number, number> = new Map<number, number>();\r\n    protected deletedItems: { [field: string]: V } = {};\r\n\r\n    protected $refId: number = 0;\r\n\r\n    static [$encoder] = encodeKeyValueOperation;\r\n    static [$decoder] = decodeKeyValueOperation;\r\n\r\n    /**\r\n     * Determine if a property must be filtered.\r\n     * - If returns false, the property is NOT going to be encoded.\r\n     * - If returns true, the property is going to be encoded.\r\n     *\r\n     * Encoding with \"filters\" happens in two steps:\r\n     * - First, the encoder iterates over all \"not owned\" properties and encodes them.\r\n     * - Then, the encoder iterates over all \"owned\" properties per instance and encodes them.\r\n     */\r\n    static [$filter] (ref: CollectionSchema, index: number, view: StateView) {\r\n        return (\r\n            !view ||\r\n            typeof (ref[$childType]) === \"string\" ||\r\n            view.isChangeTreeVisible((ref[$getByIndex](index) ?? ref.deletedItems[index])[$changes])\r\n        );\r\n    }\r\n\r\n    static is(type: any) {\r\n        return type['collection'] !== undefined;\r\n    }\r\n\r\n    constructor (initialValues?: Array<V>) {\r\n        this[$changes] = new ChangeTree(this);\r\n        this[$changes].indexes = {};\r\n\r\n        if (initialValues) {\r\n            initialValues.forEach((v) => this.add(v));\r\n        }\r\n\r\n        Object.defineProperty(this, $childType, {\r\n            value: undefined,\r\n            enumerable: false,\r\n            writable: true,\r\n            configurable: true,\r\n        });\r\n    }\r\n\r\n    add(value: V) {\r\n        // set \"index\" for reference.\r\n        const index = this.$refId++;\r\n\r\n        const isRef = (value[$changes]) !== undefined;\r\n        if (isRef) {\r\n            value[$changes].setParent(this, this[$changes].root, index);\r\n        }\r\n\r\n        this[$changes].indexes[index] = index;\r\n\r\n        this.$indexes.set(index, index);\r\n        this.$items.set(index, value);\r\n\r\n        this[$changes].change(index);\r\n\r\n        return index;\r\n    }\r\n\r\n    at(index: number): V | undefined {\r\n        const key = Array.from(this.$items.keys())[index];\r\n        return this.$items.get(key);\r\n    }\r\n\r\n    entries() {\r\n        return this.$items.entries();\r\n    }\r\n\r\n    delete(item: V) {\r\n        const entries = this.$items.entries();\r\n\r\n        let index: K;\r\n        let entry: IteratorResult<[number, V]>;\r\n        while (entry = entries.next()) {\r\n            if (entry.done) { break; }\r\n\r\n            if (item === entry.value[1]) {\r\n                index = entry.value[0];\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (index === undefined) {\r\n            return false;\r\n        }\r\n\r\n        this.deletedItems[index] = this[$changes].delete(index);\r\n        this.$indexes.delete(index);\r\n\r\n        return this.$items.delete(index);\r\n    }\r\n\r\n    clear() {\r\n        const changeTree = this[$changes];\r\n\r\n        // discard previous operations.\r\n        changeTree.discard(true);\r\n        changeTree.indexes = {};\r\n\r\n        // remove children references\r\n        changeTree.forEachChild((childChangeTree, _) => {\r\n            changeTree.root?.remove(childChangeTree);\r\n        });\r\n\r\n        // clear previous indexes\r\n        this.$indexes.clear();\r\n\r\n        // clear items\r\n        this.$items.clear();\r\n\r\n        changeTree.operation(OPERATION.CLEAR);\r\n    }\r\n\r\n    has (value: V): boolean {\r\n        return Array.from(this.$items.values()).some((v) => v === value);\r\n    }\r\n\r\n    forEach(callbackfn: (value: V, key: K, collection: CollectionSchema<V>) => void) {\r\n        this.$items.forEach((value, key, _) => callbackfn(value, key, this));\r\n    }\r\n\r\n    values() {\r\n        return this.$items.values();\r\n    }\r\n\r\n    get size () {\r\n        return this.$items.size;\r\n    }\r\n\r\n    /** Iterator */\r\n    [Symbol.iterator](): IterableIterator<V> {\r\n        return this.$items.values();\r\n    }\r\n\r\n    protected setIndex(index: number, key: number) {\r\n        this.$indexes.set(index, key);\r\n    }\r\n\r\n    protected getIndex(index: number) {\r\n        return this.$indexes.get(index);\r\n    }\r\n\r\n    [$getByIndex](index: number): any {\r\n        return this.$items.get(this.$indexes.get(index));\r\n    }\r\n\r\n    [$deleteByIndex](index: number): void {\r\n        const key = this.$indexes.get(index);\r\n        this.$items.delete(key);\r\n        this.$indexes.delete(index);\r\n    }\r\n\r\n    protected [$onEncodeEnd]() {\r\n        this.deletedItems = {};\r\n    }\r\n\r\n    toArray() {\r\n        return Array.from(this.$items.values());\r\n    }\r\n\r\n    toJSON() {\r\n        const values: V[] = [];\r\n\r\n        this.forEach((value: any, key: K) => {\r\n            values.push(\r\n                (typeof (value['toJSON']) === \"function\")\r\n                    ? value['toJSON']()\r\n                    : value\r\n            );\r\n        });\r\n\r\n        return values;\r\n    }\r\n\r\n    //\r\n    // Decoding utilities\r\n    //\r\n    clone(isDecoding?: boolean): CollectionSchema<V> {\r\n        let cloned: CollectionSchema;\r\n\r\n        if (isDecoding) {\r\n            // client-side\r\n            cloned = Object.assign(new CollectionSchema(), this);\r\n\r\n        } else {\r\n            // server-side\r\n            cloned = new CollectionSchema();\r\n            this.forEach((value: any) => {\r\n                if (value[$changes]) {\r\n                    cloned.add(value['clone']());\r\n                } else {\r\n                    cloned.add(value);\r\n                }\r\n            })\r\n        }\r\n\r\n        return cloned;\r\n    }\r\n\r\n}\r\n\r\nregisterType(\"collection\", { constructor: CollectionSchema, });\r\n","import { OPERATION } from \"../../encoding/spec\";\r\nimport { registerType } from \"../registry\";\r\nimport { $changes, $childType, $decoder, $deleteByIndex, $encoder, $filter, $getByIndex, $onEncodeEnd } from \"../symbols\";\r\nimport { Collection } from \"../HelperTypes\";\r\nimport { ChangeTree, type IRef } from \"../../encoder/ChangeTree\";\r\nimport { encodeKeyValueOperation } from \"../../encoder/EncodeOperation\";\r\nimport { decodeKeyValueOperation } from \"../../decoder/DecodeOperation\";\r\nimport type { StateView } from \"../../encoder/StateView\";\r\nimport type { Schema } from \"../../Schema\";\r\n\r\nexport class SetSchema<V=any> implements Collection<number, V>, IRef {\r\n    [$changes]: ChangeTree;\r\n    protected [$childType]: string | typeof Schema;\r\n\r\n    protected $items: Map<number, V> = new Map<number, V>();\r\n    protected $indexes: Map<number, number> = new Map<number, number>();\r\n    protected deletedItems: { [field: string]: V } = {};\r\n\r\n    protected $refId: number = 0;\r\n\r\n    static [$encoder] = encodeKeyValueOperation;\r\n    static [$decoder] = decodeKeyValueOperation;\r\n\r\n    /**\r\n     * Determine if a property must be filtered.\r\n     * - If returns false, the property is NOT going to be encoded.\r\n     * - If returns true, the property is going to be encoded.\r\n     *\r\n     * Encoding with \"filters\" happens in two steps:\r\n     * - First, the encoder iterates over all \"not owned\" properties and encodes them.\r\n     * - Then, the encoder iterates over all \"owned\" properties per instance and encodes them.\r\n     */\r\n    static [$filter] (ref: SetSchema, index: number, view: StateView) {\r\n        return (\r\n            !view ||\r\n            typeof (ref[$childType]) === \"string\" ||\r\n            view.visible.has((ref[$getByIndex](index) ?? ref.deletedItems[index])[$changes])\r\n        );\r\n    }\r\n\r\n    static is(type: any) {\r\n        return type['set'] !== undefined;\r\n    }\r\n\r\n    constructor (initialValues?: Array<V>) {\r\n        this[$changes] = new ChangeTree(this);\r\n        this[$changes].indexes = {};\r\n\r\n        if (initialValues) {\r\n            initialValues.forEach((v) => this.add(v));\r\n        }\r\n\r\n        Object.defineProperty(this, $childType, {\r\n            value: undefined,\r\n            enumerable: false,\r\n            writable: true,\r\n            configurable: true,\r\n        });\r\n    }\r\n\r\n    add(value: V) {\r\n        // immediatelly return false if value already added.\r\n        if (this.has(value)) { return false; }\r\n\r\n        // set \"index\" for reference.\r\n        const index = this.$refId++;\r\n\r\n        if ((value[$changes]) !== undefined) {\r\n            value[$changes].setParent(this, this[$changes].root, index);\r\n        }\r\n\r\n        const operation = this[$changes].indexes[index]?.op ?? OPERATION.ADD;\r\n\r\n        this[$changes].indexes[index] = index;\r\n\r\n        this.$indexes.set(index, index);\r\n        this.$items.set(index, value);\r\n\r\n        this[$changes].change(index, operation);\r\n        return index;\r\n    }\r\n\r\n    entries () {\r\n        return this.$items.entries();\r\n    }\r\n\r\n    delete(item: V) {\r\n        const entries = this.$items.entries();\r\n\r\n        let index: number;\r\n        let entry: IteratorResult<[number, V]>;\r\n        while (entry = entries.next()) {\r\n            if (entry.done) { break; }\r\n\r\n            if (item === entry.value[1]) {\r\n                index = entry.value[0];\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (index === undefined) {\r\n            return false;\r\n        }\r\n\r\n        this.deletedItems[index] = this[$changes].delete(index);\r\n        this.$indexes.delete(index);\r\n\r\n        return this.$items.delete(index);\r\n    }\r\n\r\n    clear() {\r\n        const changeTree = this[$changes];\r\n\r\n        // discard previous operations.\r\n        changeTree.discard(true);\r\n        changeTree.indexes = {};\r\n\r\n        // clear previous indexes\r\n        this.$indexes.clear();\r\n\r\n        // clear items\r\n        this.$items.clear();\r\n\r\n        changeTree.operation(OPERATION.CLEAR);\r\n    }\r\n\r\n    has (value: V): boolean {\r\n        const values = this.$items.values();\r\n\r\n        let has = false;\r\n        let entry: IteratorResult<V>;\r\n\r\n        while (entry = values.next()) {\r\n            if (entry.done) { break; }\r\n            if (value === entry.value) {\r\n                has = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        return has;\r\n    }\r\n\r\n    forEach(callbackfn: (value: V, key: number, collection: SetSchema<V>) => void) {\r\n        this.$items.forEach((value, key, _) => callbackfn(value, key, this));\r\n    }\r\n\r\n    values() {\r\n        return this.$items.values();\r\n    }\r\n\r\n    get size () {\r\n        return this.$items.size;\r\n    }\r\n\r\n    /** Iterator */\r\n    [Symbol.iterator](): IterableIterator<V> {\r\n        return this.$items.values();\r\n    }\r\n\r\n    protected setIndex(index: number, key: number) {\r\n        this.$indexes.set(index, key);\r\n    }\r\n\r\n    protected getIndex(index: number) {\r\n        return this.$indexes.get(index);\r\n    }\r\n\r\n    [$getByIndex](index: number): any {\r\n        return this.$items.get(this.$indexes.get(index));\r\n    }\r\n\r\n    [$deleteByIndex](index: number): void {\r\n        const key = this.$indexes.get(index);\r\n        this.$items.delete(key);\r\n        this.$indexes.delete(index);\r\n    }\r\n\r\n    protected [$onEncodeEnd]() {\r\n        this.deletedItems = {};\r\n    }\r\n\r\n    toArray() {\r\n        return Array.from(this.$items.values());\r\n    }\r\n\r\n    toJSON() {\r\n        const values: V[] = [];\r\n\r\n        this.forEach((value: any, key: number) => {\r\n            values.push(\r\n                (typeof (value['toJSON']) === \"function\")\r\n                    ? value['toJSON']()\r\n                    : value\r\n            );\r\n        });\r\n\r\n        return values;\r\n    }\r\n\r\n    //\r\n    // Decoding utilities\r\n    //\r\n    clone(isDecoding?: boolean): SetSchema<V> {\r\n        let cloned: SetSchema;\r\n\r\n        if (isDecoding) {\r\n            // client-side\r\n            cloned = Object.assign(new SetSchema(), this);\r\n\r\n        } else {\r\n            // server-side\r\n            cloned = new SetSchema();\r\n            this.forEach((value: any) => {\r\n                if (value[$changes]) {\r\n                    cloned.add(value['clone']());\r\n                } else {\r\n                    cloned.add(value);\r\n                }\r\n            })\r\n        }\r\n\r\n        return cloned;\r\n    }\r\n\r\n}\r\n\r\nregisterType(\"set\", { constructor: SetSchema });","import \"./symbol.shim\";\r\nimport { Schema } from './Schema';\r\nimport { ArraySchema } from './types/custom/ArraySchema';\r\nimport { MapSchema } from './types/custom/MapSchema';\r\nimport { getNormalizedType, Metadata } from \"./Metadata\";\r\nimport { $changes, $childType, $descriptors, $numFields, $track } from \"./types/symbols\";\r\nimport { TypeDefinition, getType } from \"./types/registry\";\r\nimport { OPERATION } from \"./encoding/spec\";\r\nimport { TypeContext } from \"./types/TypeContext\";\r\nimport { assertInstanceType, assertType } from \"./encoding/assert\";\r\nimport type { InferValueType, InferSchemaInstanceType, AssignableProps, IsNever } from \"./types/HelperTypes\";\r\nimport { CollectionSchema } from \"./types/custom/CollectionSchema\";\r\nimport { SetSchema } from \"./types/custom/SetSchema\";\r\n\r\nexport type RawPrimitiveType = \"string\" |\r\n    \"number\" |\r\n    \"boolean\" |\r\n    \"int8\" |\r\n    \"uint8\" |\r\n    \"int16\" |\r\n    \"uint16\" |\r\n    \"int32\" |\r\n    \"uint32\" |\r\n    \"int64\" |\r\n    \"uint64\" |\r\n    \"float32\" |\r\n    \"float64\" |\r\n    \"bigint64\" |\r\n    \"biguint64\";\r\n\r\nexport type PrimitiveType = RawPrimitiveType | typeof Schema | object;\r\n\r\n// TODO: infer \"default\" value type correctly.\r\nexport type DefinitionType<T extends PrimitiveType = PrimitiveType> = T\r\n    | T[]\r\n    | { type: T, default?: InferValueType<T>, view?: boolean | number }\r\n    | { array: T, default?: ArraySchema<InferValueType<T>>, view?: boolean | number }\r\n    | { map: T, default?: MapSchema<InferValueType<T>>, view?: boolean | number }\r\n    | { collection: T, default?: CollectionSchema<InferValueType<T>>, view?: boolean | number }\r\n    | { set: T, default?: SetSchema<InferValueType<T>>, view?: boolean | number };\r\n\r\nexport type Definition = { [field: string]: DefinitionType };\r\n\r\nexport interface TypeOptions {\r\n    manual?: boolean,\r\n}\r\n\r\nexport const DEFAULT_VIEW_TAG = -1;\r\n\r\nexport function entity(constructor: any): any {\r\n    TypeContext.register(constructor as typeof Schema);\r\n    return constructor;\r\n}\r\n\r\n/**\r\n * [See documentation](https://docs.colyseus.io/state/schema/)\r\n *\r\n * Annotate a Schema property to be serializeable.\r\n * \\@type()'d fields are automatically flagged as \"dirty\" for the next patch.\r\n *\r\n * @example Standard usage, with automatic change tracking.\r\n * ```\r\n * \\@type(\"string\") propertyName: string;\r\n * ```\r\n *\r\n * @example You can provide the \"manual\" option if you'd like to manually control your patches via .setDirty().\r\n * ```\r\n * \\@type(\"string\", { manual: true })\r\n * ```\r\n */\r\n// export function type(type: DefinitionType, options?: TypeOptions) {\r\n//     return function ({ get, set }, context: ClassAccessorDecoratorContext): ClassAccessorDecoratorResult<Schema, any> {\r\n//         if (context.kind !== \"accessor\") {\r\n//             throw new Error(\"@type() is only supported for class accessor properties\");\r\n//         }\r\n\r\n//         const field = context.name.toString();\r\n\r\n//         //\r\n//         // detect index for this field, considering inheritance\r\n//         //\r\n//         const parent = Object.getPrototypeOf(context.metadata);\r\n//         let fieldIndex: number = context.metadata[$numFields] // current structure already has fields defined\r\n//             ?? (parent && parent[$numFields]) // parent structure has fields defined\r\n//             ?? -1; // no fields defined\r\n//         fieldIndex++;\r\n\r\n//         if (\r\n//             !parent && // the parent already initializes the `$changes` property\r\n//             !Metadata.hasFields(context.metadata)\r\n//         ) {\r\n//             context.addInitializer(function (this: Ref) {\r\n//                 Object.defineProperty(this, $changes, {\r\n//                     value: new ChangeTree(this),\r\n//                     enumerable: false,\r\n//                     writable: true\r\n//                 });\r\n//             });\r\n//         }\r\n\r\n//         Metadata.addField(context.metadata, fieldIndex, field, type);\r\n\r\n//         const isArray = ArraySchema.is(type);\r\n//         const isMap = !isArray && MapSchema.is(type);\r\n\r\n//         // if (options && options.manual) {\r\n//         //     // do not declare getter/setter descriptor\r\n//         //     definition.descriptors[field] = {\r\n//         //         enumerable: true,\r\n//         //         configurable: true,\r\n//         //         writable: true,\r\n//         //     };\r\n//         //     return;\r\n//         // }\r\n\r\n//         return {\r\n//             init(value) {\r\n//                 // TODO: may need to convert ArraySchema/MapSchema here\r\n\r\n//                 // do not flag change if value is undefined.\r\n//                 if (value !== undefined) {\r\n//                     this[$changes].change(fieldIndex);\r\n\r\n//                     // automaticallty transform Array into ArraySchema\r\n//                     if (isArray) {\r\n//                         if (!(value instanceof ArraySchema)) {\r\n//                             value = new ArraySchema(...value);\r\n//                         }\r\n//                         value[$childType] = Object.values(type)[0];\r\n//                     }\r\n\r\n//                     // automaticallty transform Map into MapSchema\r\n//                     if (isMap) {\r\n//                         if (!(value instanceof MapSchema)) {\r\n//                             value = new MapSchema(value);\r\n//                         }\r\n//                         value[$childType] = Object.values(type)[0];\r\n//                     }\r\n\r\n//                     // try to turn provided structure into a Proxy\r\n//                     if (value['$proxy'] === undefined) {\r\n//                         if (isMap) {\r\n//                             value = getMapProxy(value);\r\n//                         }\r\n//                     }\r\n\r\n//                 }\r\n\r\n//                 return value;\r\n//             },\r\n\r\n//             get() {\r\n//                 return get.call(this);\r\n//             },\r\n\r\n//             set(value: any) {\r\n//                 /**\r\n//                  * Create Proxy for array or map items\r\n//                  */\r\n\r\n//                 // skip if value is the same as cached.\r\n//                 if (value === get.call(this)) {\r\n//                     return;\r\n//                 }\r\n\r\n//                 if (\r\n//                     value !== undefined &&\r\n//                     value !== null\r\n//                 ) {\r\n//                     // automaticallty transform Array into ArraySchema\r\n//                     if (isArray) {\r\n//                         if (!(value instanceof ArraySchema)) {\r\n//                             value = new ArraySchema(...value);\r\n//                         }\r\n//                         value[$childType] = Object.values(type)[0];\r\n//                     }\r\n\r\n//                     // automaticallty transform Map into MapSchema\r\n//                     if (isMap) {\r\n//                         if (!(value instanceof MapSchema)) {\r\n//                             value = new MapSchema(value);\r\n//                         }\r\n//                         value[$childType] = Object.values(type)[0];\r\n//                     }\r\n\r\n//                     // try to turn provided structure into a Proxy\r\n//                     if (value['$proxy'] === undefined) {\r\n//                         if (isMap) {\r\n//                             value = getMapProxy(value);\r\n//                         }\r\n//                     }\r\n\r\n//                     // flag the change for encoding.\r\n//                     this[$changes].change(fieldIndex);\r\n\r\n//                     //\r\n//                     // call setParent() recursively for this and its child\r\n//                     // structures.\r\n//                     //\r\n//                     if (value[$changes]) {\r\n//                         value[$changes].setParent(\r\n//                             this,\r\n//                             this[$changes].root,\r\n//                             Metadata.getIndex(context.metadata, field),\r\n//                         );\r\n//                     }\r\n\r\n//                 } else if (get.call(this)) {\r\n//                     //\r\n//                     // Setting a field to `null` or `undefined` will delete it.\r\n//                     //\r\n//                     this[$changes].delete(field);\r\n//                 }\r\n\r\n//                 set.call(this, value);\r\n//             },\r\n//         };\r\n//     }\r\n// }\r\n\r\nexport function view<T> (tag: number = DEFAULT_VIEW_TAG) {\r\n    return function(target: T, fieldName: string) {\r\n        const constructor = target.constructor as typeof Schema;\r\n\r\n        const parentClass = Object.getPrototypeOf(constructor);\r\n        const parentMetadata = parentClass[Symbol.metadata];\r\n\r\n        // TODO: use Metadata.initialize()\r\n        const metadata: Metadata = (constructor[Symbol.metadata] ??= Object.assign({}, constructor[Symbol.metadata], parentMetadata ?? Object.create(null)));\r\n        // const fieldIndex = metadata[fieldName];\r\n\r\n        // if (!metadata[fieldIndex]) {\r\n        //     //\r\n        //     // detect index for this field, considering inheritance\r\n        //     //\r\n        //     metadata[fieldIndex] = {\r\n        //         type: undefined,\r\n        //         index: (metadata[$numFields] // current structure already has fields defined\r\n        //             ?? (parentMetadata && parentMetadata[$numFields]) // parent structure has fields defined\r\n        //             ?? -1) + 1 // no fields defined\r\n        //     }\r\n        // }\r\n\r\n        Metadata.setTag(metadata, fieldName, tag);\r\n    }\r\n}\r\n\r\nexport function unreliable<T> (target: T, field: string) {\r\n    //\r\n    // FIXME: the following block of code is repeated across `@type()`, `@deprecated()` and `@unreliable()` decorators.\r\n    //\r\n    const constructor = target.constructor as typeof Schema;\r\n\r\n    const parentClass = Object.getPrototypeOf(constructor);\r\n    const parentMetadata = parentClass[Symbol.metadata];\r\n\r\n    // TODO: use Metadata.initialize()\r\n    const metadata: Metadata = (constructor[Symbol.metadata] ??= Object.assign({}, constructor[Symbol.metadata], parentMetadata ?? Object.create(null)));\r\n\r\n    // if (!metadata[field]) {\r\n    //     //\r\n    //     // detect index for this field, considering inheritance\r\n    //     //\r\n    //     metadata[field] = {\r\n    //         type: undefined,\r\n    //         index: (metadata[$numFields] // current structure already has fields defined\r\n    //             ?? (parentMetadata && parentMetadata[$numFields]) // parent structure has fields defined\r\n    //             ?? -1) + 1 // no fields defined\r\n    //     }\r\n    // }\r\n\r\n    // add owned flag to the field\r\n    metadata[metadata[field]].unreliable = true;\r\n}\r\n\r\nexport function type (\r\n    type: DefinitionType,\r\n    options?: TypeOptions\r\n): PropertyDecorator {\r\n    return function (target: typeof Schema, field: string) {\r\n        const constructor = target.constructor as typeof Schema;\r\n\r\n        if (!type) {\r\n            throw new Error(`${constructor.name}: @type() reference provided for \"${field}\" is undefined. Make sure you don't have any circular dependencies.`);\r\n        }\r\n\r\n        // Normalize type (enum/collection/etc)\r\n        type = getNormalizedType(type);\r\n\r\n        // for inheritance support\r\n        TypeContext.register(constructor);\r\n\r\n        const parentClass = Object.getPrototypeOf(constructor);\r\n        const parentMetadata =  parentClass[Symbol.metadata];\r\n        const metadata = Metadata.initialize(constructor);\r\n\r\n        let fieldIndex: number = metadata[field];\r\n\r\n        /**\r\n         * skip if descriptor already exists for this field (`@deprecated()`)\r\n         */\r\n        if (metadata[fieldIndex] !== undefined) {\r\n            if (metadata[fieldIndex].deprecated) {\r\n                // do not create accessors for deprecated properties.\r\n                return;\r\n\r\n            } else if (metadata[fieldIndex].type !== undefined) {\r\n                // trying to define same property multiple times across inheritance.\r\n                // https://github.com/colyseus/colyseus-unity3d/issues/131#issuecomment-814308572\r\n                try {\r\n                    throw new Error(`@colyseus/schema: Duplicate '${field}' definition on '${constructor.name}'.\\nCheck @type() annotation`);\r\n\r\n                } catch (e) {\r\n                    const definitionAtLine = e.stack.split(\"\\n\")[4].trim();\r\n                    throw new Error(`${e.message} ${definitionAtLine}`);\r\n                }\r\n            }\r\n\r\n        } else {\r\n            //\r\n            // detect index for this field, considering inheritance\r\n            //\r\n            fieldIndex = metadata[$numFields] // current structure already has fields defined\r\n                ?? (parentMetadata && parentMetadata[$numFields]) // parent structure has fields defined\r\n                ?? -1; // no fields defined\r\n            fieldIndex++;\r\n        }\r\n\r\n        if (options && options.manual) {\r\n            Metadata.addField(\r\n                metadata,\r\n                fieldIndex,\r\n                field,\r\n                type,\r\n                {\r\n                    // do not declare getter/setter descriptor\r\n                    enumerable: true,\r\n                    configurable: true,\r\n                    writable: true,\r\n                }\r\n            );\r\n\r\n        } else {\r\n            const complexTypeKlass = typeof(Object.keys(type)[0]) === \"string\" && getType(Object.keys(type)[0]);\r\n\r\n            const childType = (complexTypeKlass)\r\n                ? Object.values(type)[0]\r\n                : type;\r\n\r\n            Metadata.addField(\r\n                metadata,\r\n                fieldIndex,\r\n                field,\r\n                type,\r\n                getPropertyDescriptor(`_${field}`, fieldIndex, childType, complexTypeKlass)\r\n            );\r\n        }\r\n    }\r\n}\r\n\r\nexport function getPropertyDescriptor(\r\n    fieldCached: string,\r\n    fieldIndex: number,\r\n    type: DefinitionType,\r\n    complexTypeKlass: TypeDefinition,\r\n) {\r\n    return {\r\n        get: function (this: Schema) { return this[fieldCached as keyof Schema]; },\r\n        set: function (this: Schema, value: any) {\r\n            const previousValue = this[fieldCached as keyof Schema] ?? undefined;\r\n\r\n            // skip if value is the same as cached.\r\n            if (value === previousValue) { return; }\r\n\r\n            if (\r\n                value !== undefined &&\r\n                value !== null\r\n            ) {\r\n                if (complexTypeKlass) {\r\n                    // automaticallty transform Array into ArraySchema\r\n                    if (complexTypeKlass.constructor === ArraySchema && !(value instanceof ArraySchema)) {\r\n                        value = new ArraySchema(...value);\r\n                    }\r\n\r\n                    // automaticallty transform Map into MapSchema\r\n                    if (complexTypeKlass.constructor === MapSchema && !(value instanceof MapSchema)) {\r\n                        value = new MapSchema(value);\r\n                    }\r\n\r\n                    // // automaticallty transform Array into SetSchema\r\n                    // if (complexTypeKlass.constructor === SetSchema && !(value instanceof SetSchema)) {\r\n                    //     value = new SetSchema(value);\r\n                    // }\r\n\r\n                    value[$childType] = type;\r\n\r\n                } else if (typeof (type) !== \"string\") {\r\n                    assertInstanceType(value, type as typeof Schema, this, fieldCached.substring(1));\r\n\r\n                } else {\r\n                    assertType(value, type, this, fieldCached.substring(1));\r\n                }\r\n\r\n                const changeTree = this[$changes];\r\n\r\n                //\r\n                // Replacing existing \"ref\", remove it from root.\r\n                //\r\n                if (previousValue !== undefined && previousValue[$changes]) {\r\n                    changeTree.root?.remove(previousValue[$changes]);\r\n                    (this.constructor as typeof Schema)[$track](changeTree, fieldIndex, OPERATION.DELETE_AND_ADD);\r\n\r\n                } else {\r\n                    (this.constructor as typeof Schema)[$track](changeTree, fieldIndex, OPERATION.ADD);\r\n                }\r\n\r\n                //\r\n                // call setParent() recursively for this and its child\r\n                // structures.\r\n                //\r\n                value[$changes]?.setParent(this, changeTree.root, fieldIndex);\r\n\r\n            } else if (previousValue !== undefined) {\r\n                //\r\n                // Setting a field to `null` or `undefined` will delete it.\r\n                //\r\n                this[$changes].delete(fieldIndex);\r\n            }\r\n\r\n            this[fieldCached as keyof Schema] = value;\r\n        },\r\n\r\n        enumerable: true,\r\n        configurable: true\r\n    };\r\n}\r\n\r\n/**\r\n * `@deprecated()` flag a field as deprecated.\r\n * The previous `@type()` annotation should remain along with this one.\r\n */\r\n\r\nexport function deprecated(throws: boolean = true): PropertyDecorator {\r\n    return function (klass: typeof Schema, field: string) {\r\n        //\r\n        // FIXME: the following block of code is repeated across `@type()`, `@deprecated()` and `@unreliable()` decorators.\r\n        //\r\n        const constructor = klass.constructor as typeof Schema;\r\n\r\n        const parentClass = Object.getPrototypeOf(constructor);\r\n        const parentMetadata = parentClass[Symbol.metadata];\r\n        const metadata: Metadata = (constructor[Symbol.metadata] ??= Object.assign({}, constructor[Symbol.metadata], parentMetadata ?? Object.create(null)));\r\n        const fieldIndex = metadata[field];\r\n\r\n        // if (!metadata[field]) {\r\n        //     //\r\n        //     // detect index for this field, considering inheritance\r\n        //     //\r\n        //     metadata[field] = {\r\n        //         type: undefined,\r\n        //         index: (metadata[$numFields] // current structure already has fields defined\r\n        //             ?? (parentMetadata && parentMetadata[$numFields]) // parent structure has fields defined\r\n        //             ?? -1) + 1 // no fields defined\r\n        //     }\r\n        // }\r\n\r\n        metadata[fieldIndex].deprecated = true;\r\n\r\n        if (throws) {\r\n            metadata[$descriptors] ??= {};\r\n            metadata[$descriptors][field] = {\r\n                get: function () { throw new Error(`${field} is deprecated.`); },\r\n                set: function (this: Schema, value: any) { /* throw new Error(`${field} is deprecated.`); */ },\r\n                enumerable: false,\r\n                configurable: true\r\n            };\r\n        }\r\n\r\n        // flag metadata[field] as non-enumerable\r\n        Object.defineProperty(metadata, fieldIndex, {\r\n            value: metadata[fieldIndex],\r\n            enumerable: false,\r\n            configurable: true\r\n        });\r\n    }\r\n}\r\n\r\nexport function defineTypes(\r\n    target: typeof Schema,\r\n    fields: Definition,\r\n    options?: TypeOptions\r\n) {\r\n    for (let field in fields) {\r\n        type(fields[field], options)(target.prototype, field);\r\n    }\r\n    return target;\r\n}\r\n\r\n// Helper type to extract InitProps from initialize method\r\n// Supports both single object parameter and multiple parameters\r\n// If no initialize method is specified, use AssignableProps for field initialization\r\ntype ExtractInitProps<T> = T extends { initialize: (...args: infer P) => void }\r\n    ? P extends readonly []\r\n        ? never\r\n        : P extends readonly [infer First]\r\n            ? First extends object\r\n                ? First\r\n                : P\r\n            : P\r\n    : T extends Definition\r\n        ? AssignableProps<InferSchemaInstanceType<T>>\r\n        : never;\r\n\r\n// Helper type to determine if InitProps should be required\r\ntype IsInitPropsRequired<T> = T extends { initialize: (props: any) => void }\r\n    ? true\r\n    : T extends { initialize: (...args: infer P) => void }\r\n        ? P extends readonly []\r\n            ? false\r\n            : true\r\n        : false;\r\n\r\nexport interface SchemaWithExtends<T extends Definition, P extends typeof Schema, > {\r\n    extends: <T2 extends Definition = Definition>(\r\n        fields: T2 & ThisType<InferSchemaInstanceType<T & T2>>,\r\n        name?: string\r\n    ) => SchemaWithExtendsConstructor<T & T2, ExtractInitProps<T2>, P>;\r\n}\r\n\r\n/**\r\n * Get the type of the schema defined via `schema({...})` method.\r\n *\r\n * @example\r\n * const Entity = schema({\r\n *     x: \"number\",\r\n *     y: \"number\",\r\n * });\r\n * type Entity = SchemaType<typeof Entity>;\r\n */\r\nexport type SchemaType<T extends {'~type': any}> = T['~type'];\r\n\r\nexport interface SchemaWithExtendsConstructor<\r\n    T extends Definition,\r\n    InitProps,\r\n    P extends typeof Schema\r\n> extends SchemaWithExtends<T, P> {\r\n    '~type': InferSchemaInstanceType<T>;\r\n    new (...args: [InitProps] extends [never] ? [] : InitProps extends readonly any[] ? InitProps : IsInitPropsRequired<T> extends true ? [InitProps] : [InitProps?]): InferSchemaInstanceType<T> & InstanceType<P>;\r\n    prototype: InferSchemaInstanceType<T> & InstanceType<P> & {\r\n        initialize(...args: [InitProps] extends [never] ? [] : InitProps extends readonly any[] ? InitProps : [InitProps]): void;\r\n    };\r\n}\r\n\r\nexport function schema<\r\n    T extends Record<string, DefinitionType>,\r\n    P extends typeof Schema = typeof Schema\r\n>(\r\n    fieldsAndMethods: T & ThisType<InferSchemaInstanceType<T>>,\r\n    name?: string,\r\n    inherits: P = Schema as P\r\n): SchemaWithExtendsConstructor<T, ExtractInitProps<T>, P> {\r\n    const fields: any = {};\r\n    const methods: any = {};\r\n\r\n    const defaultValues: any = {};\r\n    const viewTagFields: any = {};\r\n\r\n    for (let fieldName in fieldsAndMethods) {\r\n        const value: any = fieldsAndMethods[fieldName] as DefinitionType;\r\n        if (typeof (value) === \"object\") {\r\n            if (value['view'] !== undefined) {\r\n                viewTagFields[fieldName] = (typeof (value['view']) === \"boolean\")\r\n                    ? DEFAULT_VIEW_TAG\r\n                    : value['view'];\r\n            }\r\n\r\n            fields[fieldName] = getNormalizedType(value);\r\n\r\n            // If no explicit default provided, handle automatic instantiation for collection types\r\n            if (!Object.prototype.hasOwnProperty.call(value, 'default')) {\r\n                // TODO: remove Array.isArray() check. Use ['array'] !== undefined only.\r\n                if (Array.isArray(value) || value['array'] !== undefined) {\r\n                    // Collection: Array  new ArraySchema()\r\n                    defaultValues[fieldName] = new ArraySchema();\r\n\r\n                } else if (value['map'] !== undefined) {\r\n                    // Collection: Map  new MapSchema()\r\n                    defaultValues[fieldName] = new MapSchema();\r\n\r\n                } else if (value['collection'] !== undefined) {\r\n                    // Collection: Collection  new CollectionSchema()\r\n                    defaultValues[fieldName] = new CollectionSchema();\r\n\r\n                } else if (value['set'] !== undefined) {\r\n                    // Collection: Set  new SetSchema()\r\n                    defaultValues[fieldName] = new SetSchema();\r\n\r\n                } else if (value['type'] !== undefined && Schema.is(value['type'])) {\r\n                    // Direct Schema type: Type  new Type()\r\n                    if (!value['type'].prototype.initialize || value['type'].prototype.initialize.length === 0) {\r\n                        // only auto-initialize Schema instances if:\r\n                        // - they don't have an initialize method\r\n                        // - or initialize method doesn't accept any parameters\r\n                        defaultValues[fieldName] = new value['type']();\r\n                    }\r\n                }\r\n            } else {\r\n                defaultValues[fieldName] = value['default'];\r\n            }\r\n\r\n\r\n        } else if (typeof (value) === \"function\") {\r\n            if (Schema.is(value)) {\r\n                // Direct Schema type: Type  new Type()\r\n                if (!value.prototype.initialize || value.prototype.initialize.length === 0) {\r\n                    // only auto-initialize Schema instances if:\r\n                    // - they don't have an initialize method\r\n                    // - or initialize method doesn't accept any parameters\r\n                    defaultValues[fieldName] = new value();\r\n                }\r\n                fields[fieldName] = getNormalizedType(value);\r\n            } else {\r\n                methods[fieldName] = value;\r\n            }\r\n\r\n        } else {\r\n            fields[fieldName] = getNormalizedType(value);\r\n        }\r\n    }\r\n\r\n    const getDefaultValues = () => {\r\n        const defaults: any = {};\r\n\r\n        // use current class default values\r\n        for (const fieldName in defaultValues) {\r\n            const defaultValue = defaultValues[fieldName];\r\n            if (defaultValue && typeof defaultValue.clone === 'function') {\r\n                // complex, cloneable values, e.g. Schema, ArraySchema, MapSchema, CollectionSchema, SetSchema\r\n                defaults[fieldName] = defaultValue.clone();\r\n            } else {\r\n                // primitives and non-cloneable values\r\n                defaults[fieldName] = defaultValue;\r\n            }\r\n        }\r\n        return defaults;\r\n    };\r\n\r\n    const getParentProps = (props: any) => {\r\n        const fieldNames = Object.keys(fields);\r\n        const parentProps: any = {};\r\n        for (const key in props) {\r\n            if (!fieldNames.includes(key)) {\r\n                parentProps[key] = props[key];\r\n            }\r\n        }\r\n        return parentProps;\r\n    }\r\n\r\n    /** @codegen-ignore */\r\n    const klass = Metadata.setFields<any>(class extends (inherits as any) {\r\n        constructor(...args: any[]) {\r\n            // call initialize method\r\n            if (methods.initialize && typeof methods.initialize === 'function') {\r\n                super(Object.assign({}, getDefaultValues(), getParentProps(args[0] || {})));\r\n                /**\r\n                 * only call initialize() in the current class, not the parent ones.\r\n                 * see \"should not call initialize automatically when creating an instance of inherited Schema\"\r\n                 */\r\n                if (new.target === klass) {\r\n                    methods.initialize.apply(this, args);\r\n                }\r\n\r\n            } else {\r\n                super(Object.assign({}, getDefaultValues(), args[0] || {}));\r\n            }\r\n        }\r\n    }, fields) as SchemaWithExtendsConstructor<T, ExtractInitProps<T>, P>;\r\n\r\n    // Store the getDefaultValues function on the class for inheritance\r\n    (klass as any)._getDefaultValues = getDefaultValues;\r\n\r\n    // Add methods to the prototype\r\n    Object.assign(klass.prototype, methods);\r\n\r\n    for (let fieldName in viewTagFields) {\r\n        view(viewTagFields[fieldName])(klass.prototype, fieldName);\r\n    }\r\n\r\n    if (name) {\r\n        Object.defineProperty(klass, \"name\", { value: name });\r\n    }\r\n\r\n    klass.extends = <T2 extends Definition = Definition>(fields: T2, name?: string) =>\r\n        schema<T2>(fields, name, klass as any) as SchemaWithExtendsConstructor<T & T2, ExtractInitProps<T2>, P>;\r\n\r\n    return klass;\r\n}\r\n","import type { Schema } from \"./Schema\";\r\nimport { OPERATION } from \"./encoding/spec\";\r\nimport { $changes } from \"./types/symbols\";\r\n\r\ninterface ChangeDump {\r\n    ops: {\r\n        ADD?: number;\r\n        REMOVE?: number;\r\n        REPLACE?: number;\r\n    },\r\n    refs: string[],\r\n}\r\n\r\nexport function getIndent(level: number) {\r\n    return (new Array(level).fill(0)).map((_, i) =>\r\n        (i === level - 1) ? ` ` : `   `\r\n    ).join(\"\");\r\n}\r\n\r\nexport function dumpChanges(schema: Schema) {\r\n    const $root = schema[$changes].root;\r\n\r\n    const dump: ChangeDump = {\r\n        ops: {},\r\n        refs: []\r\n    };\r\n\r\n    // for (const refId in $root.changes) {\r\n    let current = $root.changes.next;\r\n    while (current) {\r\n        const changeTree = current.changeTree;\r\n        // skip if ChangeTree is undefined\r\n        if (changeTree === undefined)  {\r\n            current = current.next;\r\n            continue;\r\n        }\r\n\r\n        const changes = changeTree.indexedOperations;\r\n\r\n        dump.refs.push(`refId#${changeTree.refId}`);\r\n        for (const index in changes) {\r\n            const op = changes[index];\r\n            const opName = OPERATION[op];\r\n            if (!dump.ops[opName as keyof ChangeDump['ops']]) { dump.ops[opName as keyof ChangeDump['ops']] = 0; }\r\n            dump.ops[OPERATION[op] as keyof ChangeDump['ops']]++;\r\n        }\r\n        current = current.next;\r\n    }\r\n\r\n    return dump;\r\n}\r\n\r\nexport function getNextPowerOf2(number: number) {\r\n    // If number is already a power of 2, return it\r\n    if ((number & (number - 1)) === 0) {\r\n        return number;\r\n    }\r\n\r\n    // Find the position of the most significant bit\r\n    let msbPosition = 0;\r\n    while (number > 0) {\r\n        number >>= 1;\r\n        msbPosition++;\r\n    }\r\n\r\n    // Return the next power of 2\r\n    return 1 << msbPosition;\r\n}","import { OPERATION } from './encoding/spec';\r\nimport { DEFAULT_VIEW_TAG, type DefinitionType } from \"./annotations\";\r\n\r\nimport { AssignableProps, NonFunctionPropNames, ToJSON } from './types/HelperTypes';\r\n\r\nimport { ChangeSet, ChangeSetName, ChangeTree, IRef, Ref } from './encoder/ChangeTree';\r\nimport { $changes, $decoder, $deleteByIndex, $descriptors, $encoder, $filter, $getByIndex, $track } from './types/symbols';\r\nimport { StateView } from './encoder/StateView';\r\n\r\nimport { encodeSchemaOperation } from './encoder/EncodeOperation';\r\nimport { decodeSchemaOperation } from './decoder/DecodeOperation';\r\n\r\nimport type { Decoder } from './decoder/Decoder';\r\nimport type { Metadata, MetadataField } from './Metadata';\r\nimport { getIndent } from './utils';\r\n\r\n/**\r\n * Schema encoder / decoder\r\n */\r\nexport class Schema<C = any> implements IRef {\r\n    static [Symbol.metadata]: Metadata;\r\n    static [$encoder] = encodeSchemaOperation;\r\n    static [$decoder] = decodeSchemaOperation;\r\n\r\n    /**\r\n     * Assign the property descriptors required to track changes on this instance.\r\n     * @param instance\r\n     */\r\n    static initialize(instance: any) {\r\n        Object.defineProperty(instance, $changes, {\r\n            value: new ChangeTree(instance),\r\n            enumerable: false,\r\n            writable: true\r\n        });\r\n\r\n        Object.defineProperties(instance, instance.constructor[Symbol.metadata]?.[$descriptors] || {});\r\n    }\r\n\r\n    static is(type: DefinitionType) {\r\n        return typeof((type as typeof Schema)[Symbol.metadata]) === \"object\";\r\n    }\r\n\r\n    /**\r\n     * Track property changes\r\n     */\r\n    static [$track] (changeTree: ChangeTree, index: number, operation: OPERATION = OPERATION.ADD) {\r\n        changeTree.change(index, operation);\r\n    }\r\n\r\n    /**\r\n     * Determine if a property must be filtered.\r\n     * - If returns false, the property is NOT going to be encoded.\r\n     * - If returns true, the property is going to be encoded.\r\n     *\r\n     * Encoding with \"filters\" happens in two steps:\r\n     * - First, the encoder iterates over all \"not owned\" properties and encodes them.\r\n     * - Then, the encoder iterates over all \"owned\" properties per instance and encodes them.\r\n     */\r\n    static [$filter] (ref: Schema, index: number, view: StateView) {\r\n        const metadata: Metadata = (ref.constructor as typeof Schema)[Symbol.metadata];\r\n        const tag = metadata[index]?.tag;\r\n\r\n        if (view === undefined) {\r\n            // shared pass/encode: encode if doesn't have a tag\r\n            return tag === undefined;\r\n\r\n        } else if (tag === undefined) {\r\n            // view pass: no tag\r\n            return true;\r\n\r\n        } else if (tag === DEFAULT_VIEW_TAG) {\r\n            // view pass: default tag\r\n            return view.isChangeTreeVisible(ref[$changes]);\r\n\r\n        } else {\r\n            // view pass: custom tag\r\n            const tags = view.tags?.get(ref[$changes]);\r\n            return tags && tags.has(tag);\r\n        }\r\n    }\r\n\r\n    // allow inherited classes to have a constructor\r\n    constructor(arg?: C) {\r\n        //\r\n        // inline\r\n        // Schema.initialize(this);\r\n        //\r\n        Schema.initialize(this);\r\n\r\n        //\r\n        // Assign initial values\r\n        //\r\n        if (arg) {\r\n            Object.assign(this, arg);\r\n        }\r\n    }\r\n\r\n    public assign<T extends Partial<this>>(\r\n        props: AssignableProps<T>,\r\n    ): this {\r\n        Object.assign(this, props);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * (Server-side): Flag a property to be encoded for the next patch.\r\n     * @param instance Schema instance\r\n     * @param property string representing the property name, or number representing the index of the property.\r\n     * @param operation OPERATION to perform (detected automatically)\r\n     */\r\n    public setDirty<K extends NonFunctionPropNames<this>>(property: K | number, operation?: OPERATION) {\r\n        const metadata: Metadata = (this.constructor as typeof Schema)[Symbol.metadata];\r\n        this[$changes].change(\r\n            metadata[metadata[property as string]].index,\r\n            operation\r\n        );\r\n    }\r\n\r\n    clone (): this {\r\n        // Create instance without calling custom constructor\r\n        const cloned = Object.create(this.constructor.prototype);\r\n        Schema.initialize(cloned);\r\n\r\n        const metadata: Metadata = (this.constructor as typeof Schema)[Symbol.metadata];\r\n\r\n        //\r\n        // TODO: clone all properties, not only annotated ones\r\n        //\r\n        // for (const field in this) {\r\n        for (const fieldIndex in metadata) {\r\n            const field = metadata[fieldIndex as any as number].name as keyof this;\r\n\r\n            if (\r\n                typeof (this[field]) === \"object\" &&\r\n                typeof ((this[field] as any)?.clone) === \"function\"\r\n            ) {\r\n                // deep clone\r\n                cloned[field] = (this[field] as any).clone();\r\n\r\n            } else {\r\n                // primitive values\r\n                cloned[field] = this[field];\r\n            }\r\n        }\r\n\r\n        return cloned;\r\n    }\r\n\r\n    toJSON (this: any): ToJSON<this> {\r\n        const obj: any = {};\r\n        const metadata = this.constructor[Symbol.metadata];\r\n        for (const index in metadata) {\r\n            const field = metadata[index] as MetadataField;\r\n            const fieldName = field.name;\r\n            if (!field.deprecated && this[fieldName] !== null && typeof (this[fieldName]) !== \"undefined\") {\r\n                obj[fieldName] = (typeof (this[fieldName]['toJSON']) === \"function\")\r\n                    ? this[fieldName]['toJSON']()\r\n                    : this[fieldName];\r\n            }\r\n        }\r\n        return obj;\r\n    }\r\n\r\n    /**\r\n     * Used in tests only\r\n     * @internal\r\n     */\r\n    discardAllChanges() {\r\n        this[$changes].discardAll();\r\n    }\r\n\r\n    [$getByIndex](index: number): any {\r\n        const metadata: Metadata = (this.constructor as typeof Schema)[Symbol.metadata];\r\n        return this[metadata[index].name as keyof this];\r\n    }\r\n\r\n    [$deleteByIndex](index: number): void {\r\n        const metadata: Metadata = (this.constructor as typeof Schema)[Symbol.metadata];\r\n        this[metadata[index].name as keyof this] = undefined;\r\n    }\r\n\r\n    /**\r\n     * Inspect the `refId` of all Schema instances in the tree. Optionally display the contents of the instance.\r\n     *\r\n     * @param ref Schema instance\r\n     * @param showContents display JSON contents of the instance\r\n     * @returns\r\n     */\r\n    static debugRefIds<T extends Schema>(ref: T, showContents: boolean = false, level: number = 0, decoder?: Decoder, keyPrefix: string = \"\") {\r\n        const contents = (showContents) ? ` - ${JSON.stringify(ref.toJSON())}` : \"\";\r\n        const changeTree: ChangeTree = ref[$changes];\r\n\r\n        const refId = (decoder) ? decoder.root.refIds.get(ref) : changeTree.refId;\r\n        const root = (decoder) ? decoder.root : changeTree.root;\r\n\r\n         // log reference count if > 1\r\n        const refCount = (root?.refCount?.[refId] > 1)\r\n            ? ` [${root.refCount[refId]}]`\r\n            : '';\r\n\r\n        let output = `${getIndent(level)}${keyPrefix}${ref.constructor.name} (refId: ${refId})${refCount}${contents}\\n`;\r\n\r\n        changeTree.forEachChild((childChangeTree, indexOrKey) => {\r\n            let key = indexOrKey;\r\n            if (typeof indexOrKey === 'number' && (ref as any)['$indexes']) {\r\n                // MapSchema\r\n                key = (ref as any)['$indexes'].get(indexOrKey) ?? indexOrKey;\r\n            }\r\n            const keyPrefix = ((ref as any)['forEach'] !== undefined && key !== undefined) ? `[\"${key}\"]: ` : \"\";\r\n            output += this.debugRefIds(childChangeTree.ref, showContents, level + 1, decoder, keyPrefix);\r\n        });\r\n\r\n        return output;\r\n    }\r\n\r\n    static debugRefIdEncodingOrder<T extends Ref>(ref: T, changeSet: ChangeSetName = 'allChanges') {\r\n        let encodeOrder: number[] = [];\r\n        let current = ref[$changes].root[changeSet].next;\r\n        while (current) {\r\n            if (current.changeTree) {\r\n                encodeOrder.push(current.changeTree.refId);\r\n            }\r\n            current = current.next;\r\n        }\r\n        return encodeOrder;\r\n    }\r\n\r\n    static debugRefIdsFromDecoder(decoder: Decoder) {\r\n        return this.debugRefIds(decoder.state, false, 0, decoder);\r\n    }\r\n\r\n    /**\r\n     * Return a string representation of the changes on a Schema instance.\r\n     * The list of changes is cleared after each encode.\r\n     *\r\n     * @param instance Schema instance\r\n     * @param isEncodeAll Return \"full encode\" instead of current change set.\r\n     * @returns\r\n     */\r\n    static debugChanges<T extends Ref>(instance: T, isEncodeAll: boolean = false) {\r\n        const changeTree: ChangeTree = instance[$changes];\r\n\r\n        const changeSet = (isEncodeAll) ? changeTree.allChanges : changeTree.changes;\r\n        const changeSetName = (isEncodeAll) ? \"allChanges\" : \"changes\";\r\n\r\n        let output = `${instance.constructor.name} (${changeTree.refId}) -> .${changeSetName}:\\n`;\r\n\r\n        function dumpChangeSet(changeSet: ChangeSet) {\r\n            changeSet.operations\r\n                .filter(op => op)\r\n                .forEach((index) => {\r\n                    const operation = changeTree.indexedOperations[index];\r\n                    output += `- [${index}]: ${OPERATION[operation]} (${JSON.stringify(changeTree.getValue(Number(index), isEncodeAll))})\\n`\r\n                });\r\n        }\r\n\r\n        dumpChangeSet(changeSet);\r\n\r\n        // display filtered changes\r\n        if (\r\n            !isEncodeAll &&\r\n            changeTree.filteredChanges &&\r\n            (changeTree.filteredChanges.operations).filter(op => op).length > 0\r\n        ) {\r\n            output += `${instance.constructor.name} (${changeTree.refId}) -> .filteredChanges:\\n`;\r\n            dumpChangeSet(changeTree.filteredChanges);\r\n        }\r\n\r\n        // display filtered changes\r\n        if (\r\n            isEncodeAll &&\r\n            changeTree.allFilteredChanges &&\r\n            (changeTree.allFilteredChanges.operations).filter(op => op).length > 0\r\n        ) {\r\n            output += `${instance.constructor.name} (${changeTree.refId}) -> .allFilteredChanges:\\n`;\r\n            dumpChangeSet(changeTree.allFilteredChanges);\r\n        }\r\n\r\n        return output;\r\n    }\r\n\r\n    static debugChangesDeep<T extends Schema>(ref: T, changeSetName: \"changes\" | \"allChanges\" | \"allFilteredChanges\" | \"filteredChanges\" = \"changes\") {\r\n        let output = \"\";\r\n\r\n        const rootChangeTree: ChangeTree = ref[$changes];\r\n        const root = rootChangeTree.root;\r\n        const changeTrees: Map<ChangeTree, ChangeTree[]> = new Map();\r\n\r\n        const instanceRefIds = [];\r\n        let totalOperations = 0;\r\n\r\n        // TODO: FIXME: this method is not working as expected\r\n        for (const [refId, changes] of Object.entries(root[changeSetName])) {\r\n            const changeTree = root.changeTrees[refId as any as number];\r\n            if (!changeTree) { continue; }\r\n\r\n            let includeChangeTree = false;\r\n            let parentChangeTrees: ChangeTree[] = [];\r\n            let parentChangeTree = changeTree.parent?.[$changes];\r\n\r\n            if (changeTree === rootChangeTree) {\r\n                includeChangeTree = true;\r\n\r\n            } else {\r\n                while (parentChangeTree !== undefined) {\r\n                    parentChangeTrees.push(parentChangeTree);\r\n                    if (parentChangeTree.ref === ref) {\r\n                        includeChangeTree = true;\r\n                        break;\r\n                    }\r\n                    parentChangeTree = parentChangeTree.parent?.[$changes];\r\n                }\r\n            }\r\n\r\n            if (includeChangeTree) {\r\n                instanceRefIds.push(changeTree.refId);\r\n                totalOperations += Object.keys(changes).length;\r\n                changeTrees.set(changeTree, parentChangeTrees.reverse());\r\n            }\r\n        }\r\n\r\n        output += \"---\\n\"\r\n        output += `root refId: ${rootChangeTree.refId}\\n`;\r\n        output += `Total instances: ${instanceRefIds.length} (refIds: ${instanceRefIds.join(\", \")})\\n`;\r\n        output += `Total changes: ${totalOperations}\\n`;\r\n        output += \"---\\n\"\r\n\r\n        // based on root.changes, display a tree of changes that has the \"ref\" instance as parent\r\n        const visitedParents = new WeakSet<ChangeTree>();\r\n        for (const [changeTree, parentChangeTrees] of changeTrees.entries()) {\r\n            parentChangeTrees.forEach((parentChangeTree, level) => {\r\n                if (!visitedParents.has(parentChangeTree)) {\r\n                    output += `${getIndent(level)}${parentChangeTree.ref.constructor.name} (refId: ${parentChangeTree.refId})\\n`;\r\n                    visitedParents.add(parentChangeTree);\r\n                }\r\n            });\r\n\r\n            const changes = changeTree.indexedOperations;\r\n            const level = parentChangeTrees.length;\r\n            const indent = getIndent(level);\r\n\r\n            const parentIndex = (level > 0) ? `(${changeTree.parentIndex}) ` : \"\";\r\n            output += `${indent}${parentIndex}${changeTree.ref.constructor.name} (refId: ${changeTree.refId}) - changes: ${Object.keys(changes).length}\\n`;\r\n\r\n            for (const index in changes) {\r\n                const operation = changes[index];\r\n                output += `${getIndent(level + 1)}${OPERATION[operation]}: ${index}\\n`;\r\n            }\r\n        }\r\n\r\n        return `${output}`;\r\n    }\r\n\r\n\r\n}\r\n\r\n","/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise, SuppressedError, Symbol, Iterator */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\r\n    function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\r\n    var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\r\n    var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\r\n    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\r\n    var _, done = false;\r\n    for (var i = decorators.length - 1; i >= 0; i--) {\r\n        var context = {};\r\n        for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\r\n        for (var p in contextIn.access) context.access[p] = contextIn.access[p];\r\n        context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\r\n        var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\r\n        if (kind === \"accessor\") {\r\n            if (result === void 0) continue;\r\n            if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\r\n            if (_ = accept(result.get)) descriptor.get = _;\r\n            if (_ = accept(result.set)) descriptor.set = _;\r\n            if (_ = accept(result.init)) initializers.unshift(_);\r\n        }\r\n        else if (_ = accept(result)) {\r\n            if (kind === \"field\") initializers.unshift(_);\r\n            else descriptor[key] = _;\r\n        }\r\n    }\r\n    if (target) Object.defineProperty(target, contextIn.name, descriptor);\r\n    done = true;\r\n};\r\n\r\nexport function __runInitializers(thisArg, initializers, value) {\r\n    var useValue = arguments.length > 2;\r\n    for (var i = 0; i < initializers.length; i++) {\r\n        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\r\n    }\r\n    return useValue ? value : void 0;\r\n};\r\n\r\nexport function __propKey(x) {\r\n    return typeof x === \"symbol\" ? x : \"\".concat(x);\r\n};\r\n\r\nexport function __setFunctionName(f, name, prefix) {\r\n    if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\r\n    return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\r\n};\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === \"function\" ? Iterator : Object).prototype);\r\n    return g.next = verb(0), g[\"throw\"] = verb(1), g[\"return\"] = verb(2), typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n        desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = Object.create((typeof AsyncIterator === \"function\" ? AsyncIterator : Object).prototype), verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\r\n    function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nvar ownKeys = function(o) {\r\n    ownKeys = Object.getOwnPropertyNames || function (o) {\r\n        var ar = [];\r\n        for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\r\n        return ar;\r\n    };\r\n    return ownKeys(o);\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\r\nexport function __classPrivateFieldIn(state, receiver) {\r\n    if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\r\n    return typeof state === \"function\" ? receiver === state : state.has(receiver);\r\n}\r\n\r\nexport function __addDisposableResource(env, value, async) {\r\n    if (value !== null && value !== void 0) {\r\n        if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\r\n        var dispose, inner;\r\n        if (async) {\r\n            if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\r\n            dispose = value[Symbol.asyncDispose];\r\n        }\r\n        if (dispose === void 0) {\r\n            if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\r\n            dispose = value[Symbol.dispose];\r\n            if (async) inner = dispose;\r\n        }\r\n        if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\r\n        if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };\r\n        env.stack.push({ value: value, dispose: dispose, async: async });\r\n    }\r\n    else if (async) {\r\n        env.stack.push({ async: true });\r\n    }\r\n    return value;\r\n\r\n}\r\n\r\nvar _SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\r\n\r\nexport function __disposeResources(env) {\r\n    function fail(e) {\r\n        env.error = env.hasError ? new _SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\r\n        env.hasError = true;\r\n    }\r\n    var r, s = 0;\r\n    function next() {\r\n        while (r = env.stack.pop()) {\r\n            try {\r\n                if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);\r\n                if (r.dispose) {\r\n                    var result = r.dispose.call(r.value);\r\n                    if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });\r\n                }\r\n                else s |= 1;\r\n            }\r\n            catch (e) {\r\n                fail(e);\r\n            }\r\n        }\r\n        if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();\r\n        if (env.hasError) throw env.error;\r\n    }\r\n    return next();\r\n}\r\n\r\nexport function __rewriteRelativeImportExtension(path, preserveJsx) {\r\n    if (typeof path === \"string\" && /^\\.\\.?\\//.test(path)) {\r\n        return path.replace(/\\.(tsx)$|((?:\\.d)?)((?:\\.[^./]+?)?)\\.([cm]?)ts$/i, function (m, tsx, d, ext, cm) {\r\n            return tsx ? preserveJsx ? \".jsx\" : \".js\" : d && (!ext || !cm) ? m : (d + ext + \".\" + cm.toLowerCase() + \"js\");\r\n        });\r\n    }\r\n    return path;\r\n}\r\n\r\nexport default {\r\n    __extends: __extends,\r\n    __assign: __assign,\r\n    __rest: __rest,\r\n    __decorate: __decorate,\r\n    __param: __param,\r\n    __esDecorate: __esDecorate,\r\n    __runInitializers: __runInitializers,\r\n    __propKey: __propKey,\r\n    __setFunctionName: __setFunctionName,\r\n    __metadata: __metadata,\r\n    __awaiter: __awaiter,\r\n    __generator: __generator,\r\n    __createBinding: __createBinding,\r\n    __exportStar: __exportStar,\r\n    __values: __values,\r\n    __read: __read,\r\n    __spread: __spread,\r\n    __spreadArrays: __spreadArrays,\r\n    __spreadArray: __spreadArray,\r\n    __await: __await,\r\n    __asyncGenerator: __asyncGenerator,\r\n    __asyncDelegator: __asyncDelegator,\r\n    __asyncValues: __asyncValues,\r\n    __makeTemplateObject: __makeTemplateObject,\r\n    __importStar: __importStar,\r\n    __importDefault: __importDefault,\r\n    __classPrivateFieldGet: __classPrivateFieldGet,\r\n    __classPrivateFieldSet: __classPrivateFieldSet,\r\n    __classPrivateFieldIn: __classPrivateFieldIn,\r\n    __addDisposableResource: __addDisposableResource,\r\n    __disposeResources: __disposeResources,\r\n    __rewriteRelativeImportExtension: __rewriteRelativeImportExtension,\r\n};\r\n","import { OPERATION } from \"../encoding/spec\";\r\nimport { TypeContext } from \"../types/TypeContext\";\r\nimport { ChangeTree, setOperationAtIndex, ChangeTreeList, createChangeTreeList, ChangeSetName, type ChangeTreeNode } from \"./ChangeTree\";\r\nimport { $changes } from \"../types/symbols\";\r\n\r\nexport class Root {\r\n    protected nextUniqueId: number = 0;\r\n\r\n    refCount: {[id: number]: number} = {};\r\n    changeTrees: {[refId: number]: ChangeTree} = {};\r\n\r\n    // all changes\r\n    allChanges: ChangeTreeList = createChangeTreeList();\r\n    allFilteredChanges: ChangeTreeList = createChangeTreeList();// TODO: do not initialize it if filters are not used\r\n\r\n    // pending changes to be encoded\r\n    changes: ChangeTreeList = createChangeTreeList();\r\n    filteredChanges: ChangeTreeList = createChangeTreeList();// TODO: do not initialize it if filters are not used\r\n\r\n    constructor(public types: TypeContext) { }\r\n\r\n    getNextUniqueId() {\r\n        return this.nextUniqueId++;\r\n    }\r\n\r\n    add(changeTree: ChangeTree) {\r\n        // Assign unique `refId` to changeTree if it doesn't have one yet.\r\n        if (changeTree.refId === undefined) {\r\n            changeTree.refId = this.getNextUniqueId();\r\n        }\r\n\r\n        const isNewChangeTree = (this.changeTrees[changeTree.refId] === undefined);\r\n        if (isNewChangeTree) { this.changeTrees[changeTree.refId] = changeTree; }\r\n\r\n        const previousRefCount = this.refCount[changeTree.refId];\r\n        if (previousRefCount === 0) {\r\n            //\r\n            // When a ChangeTree is re-added, it means that it was previously removed.\r\n            // We need to re-add all changes to the `changes` map.\r\n            //\r\n            const ops = changeTree.allChanges.operations;\r\n            let len = ops.length;\r\n            while (len--) {\r\n                changeTree.indexedOperations[ops[len]] = OPERATION.ADD;\r\n                setOperationAtIndex(changeTree.changes, len);\r\n            }\r\n        }\r\n\r\n        this.refCount[changeTree.refId] = (previousRefCount || 0) + 1;\r\n\r\n        // console.log(\"ADD\", { refId: changeTree.refId, ref: changeTree.ref.constructor.name, refCount: this.refCount[changeTree.refId], isNewChangeTree });\r\n\r\n        return isNewChangeTree;\r\n    }\r\n\r\n    remove(changeTree: ChangeTree) {\r\n        const refCount = (this.refCount[changeTree.refId]) - 1;\r\n\r\n        // console.log(\"REMOVE\", { refId: changeTree.refId, ref: changeTree.ref.constructor.name, refCount, needRemove: refCount <= 0 });\r\n\r\n        if (refCount <= 0) {\r\n            //\r\n            // Only remove \"root\" reference if it's the last reference\r\n            //\r\n            changeTree.root = undefined;\r\n            delete this.changeTrees[changeTree.refId];\r\n\r\n            this.removeChangeFromChangeSet(\"allChanges\", changeTree);\r\n            this.removeChangeFromChangeSet(\"changes\", changeTree);\r\n\r\n            if (changeTree.filteredChanges) {\r\n                this.removeChangeFromChangeSet(\"allFilteredChanges\", changeTree);\r\n                this.removeChangeFromChangeSet(\"filteredChanges\", changeTree);\r\n            }\r\n\r\n            this.refCount[changeTree.refId] = 0;\r\n\r\n            changeTree.forEachChild((child, _) => {\r\n                if (child.removeParent(changeTree.ref)) {\r\n                    if ((\r\n                        child.parentChain === undefined || // no parent, remove it\r\n                        (child.parentChain && this.refCount[child.refId] > 0) // parent is still in use, but has more than one reference, remove it\r\n                    )) {\r\n                        this.remove(child);\r\n\r\n                    } else if (child.parentChain) {\r\n                        // re-assigning a child of the same root, move it next to parent\r\n                        this.moveNextToParent(child);\r\n                    }\r\n                }\r\n            });\r\n\r\n        } else {\r\n            this.refCount[changeTree.refId] = refCount;\r\n\r\n            //\r\n            // When losing a reference to an instance, it is best to move the\r\n            // ChangeTree next to its parent in the encoding queue.\r\n            //\r\n            // This way, at decoding time, the instance that contains the\r\n            // ChangeTree will be available before the ChangeTree itself. If the\r\n            // containing instance is not available, the Decoder will throw\r\n            // \"refId not found\" error.\r\n            //\r\n            this.recursivelyMoveNextToParent(changeTree);\r\n        }\r\n\r\n        return refCount;\r\n    }\r\n\r\n    recursivelyMoveNextToParent(changeTree: ChangeTree) {\r\n        this.moveNextToParent(changeTree);\r\n        changeTree.forEachChild((child, _) => this.recursivelyMoveNextToParent(child));\r\n    }\r\n\r\n    moveNextToParent(changeTree: ChangeTree) {\r\n        if (changeTree.filteredChanges) {\r\n            this.moveNextToParentInChangeTreeList(\"filteredChanges\", changeTree);\r\n            this.moveNextToParentInChangeTreeList(\"allFilteredChanges\", changeTree);\r\n        } else {\r\n            this.moveNextToParentInChangeTreeList(\"changes\", changeTree);\r\n            this.moveNextToParentInChangeTreeList(\"allChanges\", changeTree);\r\n        }\r\n    }\r\n\r\n    moveNextToParentInChangeTreeList(changeSetName: ChangeSetName, changeTree: ChangeTree): void {\r\n        const changeSet = this[changeSetName];\r\n        const node = changeTree[changeSetName].queueRootNode;\r\n        if (!node) return;\r\n\r\n        // Find the parent in the linked list\r\n        const parent = changeTree.parent;\r\n        if (!parent || !parent[$changes]) return;\r\n\r\n        const parentNode = parent[$changes][changeSetName]?.queueRootNode;\r\n        if (!parentNode || parentNode === node) return;\r\n\r\n        // Use cached positions - no iteration needed!\r\n        const parentPosition = parentNode.position;\r\n        const childPosition = node.position;\r\n\r\n        // If child is already after parent, no need to move\r\n        if (childPosition > parentPosition) return;\r\n\r\n        // Child is before parent, so we need to move it after parent\r\n        // This maintains decoding order (parent before child)\r\n\r\n        // Remove node from current position\r\n        if (node.prev) {\r\n            node.prev.next = node.next;\r\n        } else {\r\n            changeSet.next = node.next;\r\n        }\r\n\r\n        if (node.next) {\r\n            node.next.prev = node.prev;\r\n        } else {\r\n            changeSet.tail = node.prev;\r\n        }\r\n\r\n        // Insert node right after parent\r\n        node.prev = parentNode;\r\n        node.next = parentNode.next;\r\n\r\n        if (parentNode.next) {\r\n            parentNode.next.prev = node;\r\n        } else {\r\n            changeSet.tail = node;\r\n        }\r\n\r\n        parentNode.next = node;\r\n\r\n        // Update positions after the move\r\n        this.updatePositionsAfterMove(changeSet, node, parentPosition + 1);\r\n    }\r\n\r\n    public enqueueChangeTree(\r\n        changeTree: ChangeTree,\r\n        changeSet: 'changes' | 'filteredChanges' | 'allFilteredChanges' | 'allChanges',\r\n        queueRootNode = changeTree[changeSet].queueRootNode\r\n    ) {\r\n        // skip\r\n        if (queueRootNode) { return; }\r\n\r\n        // Add to linked list if not already present\r\n        changeTree[changeSet].queueRootNode = this.addToChangeTreeList(this[changeSet], changeTree);\r\n    }\r\n\r\n    protected addToChangeTreeList(list: ChangeTreeList, changeTree: ChangeTree): ChangeTreeNode {\r\n        const node: ChangeTreeNode = {\r\n            changeTree,\r\n            next: undefined,\r\n            prev: undefined,\r\n            position: list.tail ? list.tail.position + 1 : 0\r\n        };\r\n\r\n        if (!list.next) {\r\n            list.next = node;\r\n            list.tail = node;\r\n        } else {\r\n            node.prev = list.tail;\r\n            list.tail!.next = node;\r\n            list.tail = node;\r\n        }\r\n\r\n        return node;\r\n    }\r\n\r\n    protected updatePositionsAfterRemoval(list: ChangeTreeList, removedPosition: number) {\r\n        // Update positions for all nodes after the removed position\r\n        let current = list.next;\r\n        let position = 0;\r\n\r\n        while (current) {\r\n            if (position >= removedPosition) {\r\n                current.position = position;\r\n            }\r\n            current = current.next;\r\n            position++;\r\n        }\r\n    }\r\n\r\n    protected updatePositionsAfterMove(list: ChangeTreeList, node: ChangeTreeNode, newPosition: number) {\r\n        // Recalculate all positions - this is more reliable than trying to be clever\r\n        let current = list.next;\r\n        let position = 0;\r\n\r\n        while (current) {\r\n            current.position = position;\r\n            current = current.next;\r\n            position++;\r\n        }\r\n    }\r\n\r\n    public removeChangeFromChangeSet(changeSetName: ChangeSetName, changeTree: ChangeTree) {\r\n        const changeSet = this[changeSetName];\r\n        const node = changeTree[changeSetName].queueRootNode;\r\n\r\n        if (node && node.changeTree === changeTree) {\r\n            const removedPosition = node.position;\r\n\r\n            // Remove the node from the linked list\r\n            if (node.prev) {\r\n                node.prev.next = node.next;\r\n            } else {\r\n                changeSet.next = node.next;\r\n            }\r\n\r\n            if (node.next) {\r\n                node.next.prev = node.prev;\r\n            } else {\r\n                changeSet.tail = node.prev;\r\n            }\r\n\r\n            // Update positions for nodes that came after the removed node\r\n            this.updatePositionsAfterRemoval(changeSet, removedPosition);\r\n\r\n            // Clear ChangeTree reference\r\n            changeTree[changeSetName].queueRootNode = undefined;\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n}\r\n","import type { Schema } from \"../Schema\";\r\nimport { TypeContext } from \"../types/TypeContext\";\r\nimport { $changes, $encoder, $filter, $getByIndex } from \"../types/symbols\";\r\n\r\nimport { encode } from \"../encoding/encode\";\r\nimport type { Iterator } from \"../encoding/decode\";\r\n\r\nimport { OPERATION, SWITCH_TO_STRUCTURE, TYPE_ID } from '../encoding/spec';\r\nimport { Root } from \"./Root\";\r\n\r\nimport type { StateView } from \"./StateView\";\r\nimport type { Metadata } from \"../Metadata\";\r\nimport type { ChangeSetName, ChangeTree, ChangeTreeList, ChangeTreeNode } from \"./ChangeTree\";\r\nimport { createChangeTreeList } from \"./ChangeTree\";\r\n\r\nexport class Encoder<T extends Schema = any> {\r\n    static BUFFER_SIZE = (typeof(Buffer) !== \"undefined\") && Buffer.poolSize || 8 * 1024; // 8KB\r\n    sharedBuffer = Buffer.allocUnsafe(Encoder.BUFFER_SIZE);\r\n\r\n    context: TypeContext;\r\n    state: T;\r\n\r\n    root: Root;\r\n\r\n    constructor(state: T) {\r\n        //\r\n        // Use .cache() here to avoid re-creating a new context for every new room instance.\r\n        //\r\n        // We may need to make this optional in case of dynamically created\r\n        // schemas - which would lead to memory leaks\r\n        //\r\n        this.context = TypeContext.cache(state.constructor as typeof Schema);\r\n        this.root = new Root(this.context);\r\n\r\n        this.setState(state);\r\n\r\n        // console.log(\">>>>>>>>>>>>>>>> Encoder types\");\r\n        // this.context.schemas.forEach((id, schema) => {\r\n        //     console.log(\"type:\", id, schema.name, Object.keys(schema[Symbol.metadata]));\r\n        // });\r\n    }\r\n\r\n    protected setState(state: T) {\r\n        this.state = state;\r\n        this.state[$changes].setRoot(this.root);\r\n    }\r\n\r\n    encode(\r\n        it: Iterator = { offset: 0 },\r\n        view?: StateView,\r\n        buffer = this.sharedBuffer,\r\n        changeSetName: ChangeSetName = \"changes\",\r\n        isEncodeAll = changeSetName === \"allChanges\",\r\n        initialOffset = it.offset // cache current offset in case we need to resize the buffer\r\n    ): Buffer {\r\n        const hasView = (view !== undefined);\r\n        const rootChangeTree = this.state[$changes];\r\n\r\n        let current: ChangeTreeList | ChangeTreeNode = this.root[changeSetName];\r\n\r\n        while (current = current.next) {\r\n            const changeTree = (current as ChangeTreeNode).changeTree;\r\n\r\n            if (hasView) {\r\n                if (!view.isChangeTreeVisible(changeTree)) {\r\n                    // console.log(\"MARK AS INVISIBLE:\", { ref: changeTree.ref.constructor.name, refId: changeTree.refId, raw: changeTree.ref.toJSON() });\r\n                    view.invisible.add(changeTree);\r\n                    continue; // skip this change tree\r\n                }\r\n                view.invisible.delete(changeTree); // remove from invisible list\r\n            }\r\n\r\n            const changeSet = changeTree[changeSetName];\r\n            const ref = changeTree.ref;\r\n\r\n            // TODO: avoid iterating over change tree if no changes were made\r\n            const numChanges = changeSet.operations.length;\r\n            if (numChanges === 0) { continue; }\r\n\r\n            const ctor = ref.constructor;\r\n            const encoder = ctor[$encoder];\r\n            const filter = ctor[$filter];\r\n            const metadata = ctor[Symbol.metadata];\r\n\r\n            // skip root `refId` if it's the first change tree\r\n            // (unless it \"hasView\", which will need to revisit the root)\r\n            if (hasView || it.offset > initialOffset || changeTree !== rootChangeTree) {\r\n                buffer[it.offset++] = SWITCH_TO_STRUCTURE & 255;\r\n                encode.number(buffer, changeTree.refId, it);\r\n            }\r\n\r\n            for (let j = 0; j < numChanges; j++) {\r\n                const fieldIndex = changeSet.operations[j];\r\n\r\n                if (fieldIndex < 0) {\r\n                    // \"pure\" operation without fieldIndex (e.g. CLEAR, REVERSE, etc.)\r\n                    // encode and continue early - no need to reach $filter check\r\n                    buffer[it.offset++] = Math.abs(fieldIndex) & 255;\r\n                    continue;\r\n                }\r\n\r\n                const operation = (isEncodeAll)\r\n                    ? OPERATION.ADD\r\n                    : changeTree.indexedOperations[fieldIndex];\r\n\r\n                //\r\n                // first pass (encodeAll), identify \"filtered\" operations without encoding them\r\n                // they will be encoded per client, based on their view.\r\n                //\r\n                // TODO: how can we optimize filtering out \"encode all\" operations?\r\n                // TODO: avoid checking if no view tags were defined\r\n                //\r\n                if (fieldIndex === undefined || operation === undefined || (filter && !filter(ref, fieldIndex, view))) {\r\n                    // console.log(\"ADD AS INVISIBLE:\", fieldIndex, changeTree.ref.constructor.name)\r\n                    // view?.invisible.add(changeTree);\r\n                    continue;\r\n                }\r\n\r\n                encoder(this, buffer, changeTree, fieldIndex, operation, it, isEncodeAll, hasView, metadata);\r\n            }\r\n        }\r\n\r\n        if (it.offset > buffer.byteLength) {\r\n            // we can assume that n + 1 poolSize will suffice given that we are likely done with encoding at this point\r\n            // multiples of poolSize are faster to allocate than arbitrary sizes\r\n            // if we are on an older platform that doesn't implement pooling use 8kb as poolSize (that's the default for node)\r\n            const newSize = Math.ceil(it.offset / (Buffer.poolSize ?? 8 * 1024)) * (Buffer.poolSize ?? 8 * 1024);\r\n\r\n            console.warn(`@colyseus/schema buffer overflow. Encoded state is higher than default BUFFER_SIZE. Use the following to increase default BUFFER_SIZE:\r\n\r\n    import { Encoder } from \"@colyseus/schema\";\r\n    Encoder.BUFFER_SIZE = ${Math.round(newSize / 1024)} * 1024; // ${Math.round(newSize / 1024)} KB\r\n`);\r\n\r\n            //\r\n            // resize buffer and re-encode (TODO: can we avoid re-encoding here?)\r\n            // -> No we probably can't unless we catch the need for resize before encoding which is likely more computationally expensive than resizing on demand\r\n            //\r\n            buffer = Buffer.alloc(newSize, buffer); // fill with buffer here to memcpy previous encoding steps beyond the initialOffset\r\n\r\n            // assign resized buffer to local sharedBuffer\r\n            if (buffer === this.sharedBuffer) {\r\n                this.sharedBuffer = buffer;\r\n            }\r\n\r\n            return this.encode({ offset: initialOffset }, view, buffer, changeSetName, isEncodeAll);\r\n\r\n        } else {\r\n\r\n            return buffer.subarray(0, it.offset);\r\n        }\r\n    }\r\n\r\n    encodeAll(it: Iterator = { offset: 0 }, buffer: Buffer = this.sharedBuffer) {\r\n        return this.encode(it, undefined, buffer, \"allChanges\", true);\r\n    }\r\n\r\n    encodeAllView(view: StateView, sharedOffset: number, it: Iterator, bytes = this.sharedBuffer) {\r\n        const viewOffset = it.offset;\r\n\r\n        // try to encode \"filtered\" changes\r\n        this.encode(it, view, bytes, \"allFilteredChanges\", true, viewOffset);\r\n\r\n        return Buffer.concat([\r\n            bytes.subarray(0, sharedOffset),\r\n            bytes.subarray(viewOffset, it.offset)\r\n        ]);\r\n    }\r\n\r\n    encodeView(view: StateView, sharedOffset: number, it: Iterator, bytes = this.sharedBuffer) {\r\n        const viewOffset = it.offset;\r\n\r\n        // encode visibility changes (add/remove for this view)\r\n        for (const [refId, changes] of view.changes) {\r\n            const changeTree: ChangeTree = this.root.changeTrees[refId];\r\n\r\n            if (changeTree === undefined) {\r\n                // detached instance, remove from view and skip.\r\n                // console.log(\"detached instance, remove from view and skip.\", refId);\r\n                view.changes.delete(refId);\r\n                continue;\r\n            }\r\n\r\n            const keys = Object.keys(changes);\r\n            if (keys.length === 0) {\r\n                // FIXME: avoid having empty changes if no changes were made\r\n                // console.log(\"changes.size === 0, skip\", refId, changeTree.ref.constructor.name);\r\n                continue;\r\n            }\r\n\r\n            const ref = changeTree.ref;\r\n\r\n            const ctor = ref.constructor;\r\n            const encoder = ctor[$encoder];\r\n            const metadata = ctor[Symbol.metadata];\r\n\r\n            bytes[it.offset++] = SWITCH_TO_STRUCTURE & 255;\r\n            encode.number(bytes, changeTree.refId, it);\r\n\r\n            for (let i = 0, numChanges = keys.length; i < numChanges; i++) {\r\n                const index = Number(keys[i]);\r\n                // workaround when using view.add() on item that has been deleted from state (see test \"adding to view item that has been removed from state\")\r\n                const value = changeTree.ref[$getByIndex](index);\r\n                const operation = (value !== undefined && changes[index]) || OPERATION.DELETE;\r\n\r\n                // isEncodeAll = false\r\n                // hasView = true\r\n                encoder(this, bytes, changeTree, index, operation, it, false, true, metadata);\r\n            }\r\n        }\r\n\r\n        //\r\n        // TODO: only clear view changes after all views are encoded\r\n        // (to allow re-using StateView's for multiple clients)\r\n        //\r\n        // clear \"view\" changes after encoding\r\n        view.changes.clear();\r\n\r\n        // try to encode \"filtered\" changes\r\n        this.encode(it, view, bytes, \"filteredChanges\", false, viewOffset);\r\n\r\n        return Buffer.concat([\r\n            bytes.subarray(0, sharedOffset),\r\n            bytes.subarray(viewOffset, it.offset)\r\n        ]);\r\n    }\r\n\r\n    discardChanges() {\r\n        // discard shared changes\r\n        let current = this.root.changes.next;\r\n        while (current) {\r\n            current.changeTree.endEncode('changes');\r\n            current = current.next;\r\n        }\r\n        this.root.changes = createChangeTreeList();\r\n\r\n        // discard filtered changes\r\n        current = this.root.filteredChanges.next;\r\n        while (current) {\r\n            current.changeTree.endEncode('filteredChanges');\r\n            current = current.next;\r\n        }\r\n        this.root.filteredChanges = createChangeTreeList();\r\n    }\r\n\r\n    tryEncodeTypeId (bytes: Buffer, baseType: typeof Schema, targetType: typeof Schema, it: Iterator) {\r\n        const baseTypeId = this.context.getTypeId(baseType);\r\n        const targetTypeId = this.context.getTypeId(targetType);\r\n\r\n        if (targetTypeId === undefined) {\r\n            console.warn(`@colyseus/schema WARNING: Class \"${targetType.name}\" is not registered on TypeRegistry - Please either tag the class with @entity or define a @type() field.`);\r\n            return;\r\n        }\r\n\r\n        if (baseTypeId !== targetTypeId) {\r\n            bytes[it.offset++] = TYPE_ID & 255;\r\n            encode.number(bytes, targetTypeId, it);\r\n        }\r\n    }\r\n\r\n    get hasChanges() {\r\n        return (\r\n            this.root.changes.next !== undefined ||\r\n            this.root.filteredChanges.next !== undefined\r\n        );\r\n    }\r\n}\r\n","export function spliceOne(arr: any[], index: number): boolean {\r\n    // manually splice an array\r\n    if (index === -1 || index >= arr.length) {\r\n        return false;\r\n    }\r\n\r\n    const len = arr.length - 1;\r\n\r\n    for (let i = index; i < len; i++) {\r\n        arr[i] = arr[i + 1];\r\n    }\r\n\r\n    arr.length = len;\r\n\r\n    return true;\r\n}","import { Metadata } from \"../Metadata\";\r\nimport { $childType } from \"../types/symbols\";\r\nimport { Ref } from \"../encoder/ChangeTree\";\r\nimport { spliceOne } from \"../types/utils\";\r\nimport { OPERATION } from \"../encoding/spec\";\r\n\r\nimport type { MapSchema } from \"../types/custom/MapSchema\";\r\nimport type { Schema } from \"../Schema\";\r\n\r\nclass DecodingWarning extends Error {\r\n    constructor(message: string) {\r\n        super(message);\r\n        this.name = \"DecodingWarning\";\r\n    }\r\n}\r\n\r\n/**\r\n * Used for decoding only.\r\n */\r\n\r\nexport type SchemaCallbacks = { [field: string | number]: Function[] };\r\n\r\nexport class ReferenceTracker {\r\n    //\r\n    // Relation of refId => Schema structure\r\n    // For direct access of structures during decoding time.\r\n    //\r\n    public refs = new Map<number, Ref>();\r\n    public refIds = new WeakMap<Ref, number>();\r\n\r\n    public refCount: { [refId: number]: number; } = {};\r\n    public deletedRefs = new Set<number>();\r\n\r\n    public callbacks: { [refId: number]: SchemaCallbacks } = {};\r\n    protected nextUniqueId: number = 0;\r\n\r\n    getNextUniqueId() {\r\n        return this.nextUniqueId++;\r\n    }\r\n\r\n    // for decoding\r\n    addRef(refId: number, ref: Ref, incrementCount: boolean = true) {\r\n        this.refs.set(refId, ref);\r\n        this.refIds.set(ref, refId);\r\n\r\n        if (incrementCount) {\r\n            this.refCount[refId] = (this.refCount[refId] || 0) + 1;\r\n        }\r\n\r\n        if (this.deletedRefs.has(refId)) {\r\n            this.deletedRefs.delete(refId);\r\n        }\r\n    }\r\n\r\n    // for decoding\r\n    removeRef(refId: number) {\r\n        const refCount = this.refCount[refId];\r\n\r\n        if (refCount === undefined) {\r\n            try {\r\n                throw new DecodingWarning(\"trying to remove refId that doesn't exist: \" + refId);\r\n            } catch (e) {\r\n                console.warn(e);\r\n            }\r\n            return;\r\n        }\r\n\r\n        if (refCount === 0) {\r\n            try {\r\n                const ref = this.refs.get(refId);\r\n                throw new DecodingWarning(`trying to remove refId '${refId}' with 0 refCount (${ref.constructor.name}: ${JSON.stringify(ref)})`);\r\n            } catch (e) {\r\n                console.warn(e);\r\n            }\r\n            return;\r\n        }\r\n\r\n        if ((this.refCount[refId] = refCount - 1) <= 0) {\r\n            this.deletedRefs.add(refId);\r\n        }\r\n    }\r\n\r\n    clearRefs() {\r\n        this.refs.clear();\r\n        this.deletedRefs.clear();\r\n        this.callbacks = {};\r\n        this.refCount = {};\r\n    }\r\n\r\n    // for decoding\r\n    garbageCollectDeletedRefs() {\r\n        this.deletedRefs.forEach((refId) => {\r\n            //\r\n            // Skip active references.\r\n            //\r\n            if (this.refCount[refId] > 0) { return; }\r\n\r\n            const ref = this.refs.get(refId);\r\n\r\n            //\r\n            // Ensure child schema instances have their references removed as well.\r\n            //\r\n            if ((ref.constructor as typeof Schema)[Symbol.metadata] !== undefined) {\r\n                const metadata: Metadata = (ref.constructor as typeof Schema)[Symbol.metadata];\r\n                for (const index in metadata) {\r\n                    const field = metadata[index as any as number].name;\r\n                    const childRefId = typeof(ref[field as keyof Ref]) === \"object\" && this.refIds.get((ref as any)[field]);\r\n                    if (childRefId && !this.deletedRefs.has(childRefId)) {\r\n                        this.removeRef(childRefId);\r\n                    }\r\n                }\r\n\r\n            } else {\r\n                if (typeof ((ref as any)[$childType]) === \"function\") {\r\n                    Array.from((ref as MapSchema).values())\r\n                        .forEach((child) => {\r\n                            const childRefId = this.refIds.get(child);\r\n                            if (!this.deletedRefs.has(childRefId)) {\r\n                                this.removeRef(childRefId);\r\n                            }\r\n                        });\r\n                }\r\n            }\r\n\r\n            this.refs.delete(refId); // remove ref\r\n            delete this.refCount[refId]; // remove ref count\r\n            delete this.callbacks[refId]; // remove callbacks\r\n        });\r\n\r\n        // clear deleted refs.\r\n        this.deletedRefs.clear();\r\n    }\r\n\r\n    addCallback(refId: number, fieldOrOperation: string | number, callback: Function) {\r\n        if (refId === undefined) {\r\n            const name = (typeof(fieldOrOperation) === \"number\")\r\n                    ? OPERATION[fieldOrOperation]\r\n                    : fieldOrOperation\r\n            throw new Error(\r\n                `Can't addCallback on '${name}' (refId is undefined)`\r\n            );\r\n        }\r\n        if (!this.callbacks[refId]) {\r\n            this.callbacks[refId] = {};\r\n        }\r\n        if (!this.callbacks[refId][fieldOrOperation]) {\r\n            this.callbacks[refId][fieldOrOperation] = [];\r\n        }\r\n        this.callbacks[refId][fieldOrOperation].push(callback);\r\n        return () => this.removeCallback(refId, fieldOrOperation, callback);\r\n    }\r\n\r\n    removeCallback(refId: number, field: string | number, callback: Function) {\r\n        const index: number | undefined = this.callbacks?.[refId]?.[field]?.indexOf(callback);\r\n        if (index !== undefined && index !== -1) {\r\n            spliceOne(this.callbacks[refId][field], index);\r\n        }\r\n    }\r\n\r\n}\r\n","import { TypeContext } from \"../types/TypeContext\";\r\nimport { $changes, $childType, $decoder, $onDecodeEnd } from \"../types/symbols\";\r\nimport { Schema } from \"../Schema\";\r\n\r\nimport { decode } from \"../encoding/decode\";\r\nimport { OPERATION, SWITCH_TO_STRUCTURE, TYPE_ID } from '../encoding/spec';\r\nimport type { Ref } from \"../encoder/ChangeTree\";\r\nimport type { Iterator } from \"../encoding/decode\";\r\nimport { ReferenceTracker } from \"./ReferenceTracker\";\r\nimport { DEFINITION_MISMATCH, type DataChange, type DecodeOperation } from \"./DecodeOperation\";\r\nimport { Collection } from \"../types/HelperTypes\";\r\n\r\nexport class Decoder<T extends Schema = any> {\r\n    context: TypeContext;\r\n\r\n    state: T;\r\n    root: ReferenceTracker;\r\n\r\n    currentRefId: number = 0;\r\n\r\n    triggerChanges?: (allChanges: DataChange[]) => void;\r\n\r\n    constructor(root: T, context?: TypeContext) {\r\n        this.setState(root);\r\n\r\n        this.context = context || new TypeContext(root.constructor as typeof Schema);\r\n\r\n        // console.log(\">>>>>>>>>>>>>>>> Decoder types\");\r\n        // this.context.schemas.forEach((id, schema) => {\r\n        //     console.log(\"type:\", id, schema.name, Object.keys(schema[Symbol.metadata]));\r\n        // });\r\n    }\r\n\r\n    protected setState(root: T) {\r\n        this.state = root;\r\n        this.root = new ReferenceTracker();\r\n        this.root.addRef(0, root);\r\n    }\r\n\r\n    decode(\r\n        bytes: Buffer,\r\n        it: Iterator = { offset: 0 },\r\n        ref: Ref = this.state,\r\n    ) {\r\n        const allChanges: DataChange[] = [];\r\n\r\n        const $root = this.root;\r\n        const totalBytes = bytes.byteLength;\r\n\r\n        let decoder: DecodeOperation = ref['constructor'][$decoder];\r\n\r\n        this.currentRefId = 0;\r\n\r\n        while (it.offset < totalBytes) {\r\n            //\r\n            // Peek ahead, check if it's a switch to a different structure\r\n            //\r\n            if (bytes[it.offset] == SWITCH_TO_STRUCTURE) {\r\n                it.offset++;\r\n\r\n                (ref as any)[$onDecodeEnd]?.()\r\n\r\n                const nextRefId = decode.number(bytes, it);\r\n                const nextRef = $root.refs.get(nextRefId);\r\n\r\n                //\r\n                // Trying to access a reference that haven't been decoded yet.\r\n                //\r\n                if (!nextRef) {\r\n                    // throw new Error(`\"refId\" not found: ${nextRefId}`);\r\n                    console.error(`\"refId\" not found: ${nextRefId}`, { previousRef: ref, previousRefId: this.currentRefId });\r\n                    console.warn(\"Please report this issue to the developers.\");\r\n                    this.skipCurrentStructure(bytes, it, totalBytes);\r\n\r\n                } else {\r\n                    ref = nextRef;\r\n                    decoder = ref.constructor[$decoder];\r\n                    this.currentRefId = nextRefId;\r\n                }\r\n\r\n                continue;\r\n            }\r\n\r\n            const result = decoder(this, bytes, it, ref, allChanges);\r\n\r\n            if (result === DEFINITION_MISMATCH) {\r\n                console.warn(\"@colyseus/schema: definition mismatch\");\r\n                this.skipCurrentStructure(bytes, it, totalBytes);\r\n                continue;\r\n            }\r\n        }\r\n\r\n        // FIXME: DRY with SWITCH_TO_STRUCTURE block.\r\n        (ref as any)[$onDecodeEnd]?.()\r\n\r\n        // trigger changes\r\n        this.triggerChanges?.(allChanges);\r\n\r\n        // drop references of unused schemas\r\n        $root.garbageCollectDeletedRefs();\r\n\r\n        return allChanges;\r\n    }\r\n\r\n    skipCurrentStructure(bytes: Buffer, it: Iterator, totalBytes: number) {\r\n        //\r\n        // keep skipping next bytes until reaches a known structure\r\n        // by local decoder.\r\n        //\r\n        const nextIterator: Iterator = { offset: it.offset };\r\n        while (it.offset < totalBytes) {\r\n            if (bytes[it.offset] === SWITCH_TO_STRUCTURE) {\r\n                nextIterator.offset = it.offset + 1;\r\n                if (this.root.refs.has(decode.number(bytes, nextIterator))) {\r\n                    break;\r\n                }\r\n            }\r\n            it.offset++;\r\n        }\r\n    }\r\n\r\n    getInstanceType(bytes: Buffer, it: Iterator, defaultType: typeof Schema): typeof Schema {\r\n        let type: typeof Schema;\r\n\r\n        if (bytes[it.offset] === TYPE_ID) {\r\n            it.offset++;\r\n            const type_id = decode.number(bytes, it);\r\n            type = this.context.get(type_id);\r\n        }\r\n\r\n        return type || defaultType;\r\n    }\r\n\r\n    createInstanceOfType (type: typeof Schema): Schema {\r\n        return new (type as any)();\r\n    }\r\n\r\n    removeChildRefs(ref: Collection, allChanges: DataChange[]) {\r\n        const needRemoveRef = typeof ((ref as any)[$childType]) !== \"string\";\r\n        const refId = this.root.refIds.get(ref as Ref);\r\n\r\n        ref.forEach((value: any, key: any) => {\r\n            allChanges.push({\r\n                ref: ref as Ref,\r\n                refId,\r\n                op: OPERATION.DELETE,\r\n                field: key,\r\n                value: undefined,\r\n                previousValue: value\r\n            });\r\n\r\n            if (needRemoveRef) {\r\n                this.root.removeRef(this.root.refIds.get(value));\r\n            }\r\n        });\r\n    }\r\n\r\n}\r\n","import { type, PrimitiveType } from \"./annotations\";\r\nimport { TypeContext } from \"./types/TypeContext\";\r\nimport { Metadata } from \"./Metadata\";\r\nimport { ArraySchema } from \"./types/custom/ArraySchema\";\r\nimport { Iterator } from \"./encoding/decode\";\r\nimport { Encoder } from \"./encoder/Encoder\";\r\nimport { Decoder } from \"./decoder/Decoder\";\r\nimport { Schema } from \"./Schema\";\r\n\r\n/**\r\n * Reflection\r\n */\r\nexport class ReflectionField extends Schema {\r\n    @type(\"string\") name: string;\r\n    @type(\"string\") type: string;\r\n    @type(\"number\") referencedType: number;\r\n}\r\n\r\nexport class ReflectionType extends Schema {\r\n    @type(\"number\") id: number;\r\n    @type(\"number\") extendsId: number;\r\n    @type([ ReflectionField ]) fields = new ArraySchema<ReflectionField>();\r\n}\r\n\r\nexport class Reflection extends Schema {\r\n    @type([ReflectionType]) types: ArraySchema<ReflectionType> = new ArraySchema<ReflectionType>();\r\n    @type(\"number\") rootType: number;\r\n\r\n    /**\r\n     * Encodes the TypeContext of an Encoder into a buffer.\r\n     *\r\n     * @param encoder Encoder instance\r\n     * @param it\r\n     * @returns\r\n     */\r\n    static encode(encoder: Encoder, it: Iterator = { offset: 0 }) {\r\n        const context = encoder.context;\r\n\r\n        const reflection = new Reflection();\r\n        const reflectionEncoder = new Encoder(reflection);\r\n\r\n        // rootType is usually the first schema passed to the Encoder\r\n        // (unless it inherits from another schema)\r\n        const rootType = context.schemas.get(encoder.state.constructor);\r\n        if (rootType > 0) { reflection.rootType = rootType; }\r\n\r\n        const includedTypeIds = new Set<number>();\r\n        const pendingReflectionTypes: { [typeid: number]: ReflectionType[] } = {};\r\n\r\n        // add type to reflection in a way that respects inheritance\r\n        // (parent types should be added before their children)\r\n        const addType = (type: ReflectionType) => {\r\n            if (type.extendsId === undefined || includedTypeIds.has(type.extendsId)) {\r\n                includedTypeIds.add(type.id);\r\n\r\n                reflection.types.push(type);\r\n\r\n                const deps = pendingReflectionTypes[type.id];\r\n                if (deps !== undefined) {\r\n                    delete pendingReflectionTypes[type.id];\r\n                    deps.forEach((childType) => addType(childType));\r\n                }\r\n            } else {\r\n                if (pendingReflectionTypes[type.extendsId] === undefined) {\r\n                    pendingReflectionTypes[type.extendsId] = [];\r\n                }\r\n                pendingReflectionTypes[type.extendsId].push(type);\r\n            }\r\n        };\r\n\r\n        context.schemas.forEach((typeid, klass) => {\r\n            const type = new ReflectionType();\r\n            type.id = Number(typeid);\r\n\r\n            // support inheritance\r\n            const inheritFrom = Object.getPrototypeOf(klass);\r\n            if (inheritFrom !== Schema) {\r\n                type.extendsId = context.schemas.get(inheritFrom);\r\n            }\r\n\r\n            const metadata = klass[Symbol.metadata];\r\n\r\n            //\r\n            // FIXME: this is a workaround for inherited types without additional fields\r\n            // if metadata is the same reference as the parent class - it means the class has no own metadata\r\n            //\r\n            if (metadata !== inheritFrom[Symbol.metadata]) {\r\n                for (const fieldIndex in metadata) {\r\n                    const index = Number(fieldIndex);\r\n                    const fieldName = metadata[index].name;\r\n\r\n                    // skip fields from parent classes\r\n                    if (!Object.prototype.hasOwnProperty.call(metadata, fieldName)) {\r\n                        continue;\r\n                    }\r\n\r\n                    const reflectionField = new ReflectionField();\r\n                    reflectionField.name = fieldName;\r\n\r\n                    let fieldType: string;\r\n\r\n                    const field = metadata[index];\r\n\r\n                    if (typeof (field.type) === \"string\") {\r\n                        fieldType = field.type;\r\n\r\n                    } else {\r\n                        let childTypeSchema: typeof Schema;\r\n\r\n                        //\r\n                        // TODO: refactor below.\r\n                        //\r\n                        if (Schema.is(field.type)) {\r\n                            fieldType = \"ref\";\r\n                            childTypeSchema = field.type as typeof Schema;\r\n\r\n                        } else {\r\n                            fieldType = Object.keys(field.type)[0];\r\n\r\n                            if (typeof (field.type[fieldType as keyof typeof field.type]) === \"string\") {\r\n                                fieldType += \":\" + field.type[fieldType as keyof typeof field.type]; // array:string\r\n\r\n                            } else {\r\n                                childTypeSchema = field.type[fieldType as keyof typeof field.type];\r\n                            }\r\n                        }\r\n\r\n                        reflectionField.referencedType = (childTypeSchema)\r\n                            ? context.getTypeId(childTypeSchema)\r\n                            : -1;\r\n                    }\r\n\r\n                    reflectionField.type = fieldType;\r\n                    type.fields.push(reflectionField);\r\n                }\r\n            }\r\n\r\n            addType(type);\r\n        });\r\n\r\n        // in case there are types that were not added due to inheritance\r\n        for (const typeid in pendingReflectionTypes) {\r\n            pendingReflectionTypes[typeid].forEach((type) =>\r\n                reflection.types.push(type))\r\n        }\r\n\r\n        const buf = reflectionEncoder.encodeAll(it);\r\n        return buf.slice(0, it.offset)\r\n        // return Buffer.from(buf, 0, it.offset);\r\n    }\r\n\r\n    /**\r\n     * Decodes the TypeContext from a buffer into a Decoder instance.\r\n     *\r\n     * @param bytes Reflection.encode() output\r\n     * @param it\r\n     * @returns Decoder instance\r\n     */\r\n    static decode<T extends Schema = Schema>(bytes: Buffer, it?: Iterator): Decoder<T> {\r\n        const reflection = new Reflection();\r\n\r\n        const reflectionDecoder = new Decoder(reflection);\r\n        reflectionDecoder.decode(bytes, it);\r\n\r\n        const typeContext = new TypeContext();\r\n\r\n        // 1st pass, initialize metadata + inheritance\r\n        reflection.types.forEach((reflectionType) => {\r\n            const parentClass: typeof Schema = typeContext.get(reflectionType.extendsId) ?? Schema;\r\n            const schema: typeof Schema = class _ extends parentClass {};\r\n\r\n            // register for inheritance support\r\n            TypeContext.register(schema);\r\n\r\n            // // for inheritance support\r\n            // Metadata.initialize(schema);\r\n\r\n            typeContext.add(schema, reflectionType.id);\r\n        }, {});\r\n\r\n        // define fields\r\n        const addFields = (metadata: Metadata, reflectionType: ReflectionType, parentFieldIndex: number) => {\r\n            reflectionType.fields.forEach((field, i) => {\r\n                const fieldIndex = parentFieldIndex + i;\r\n\r\n                if (field.referencedType !== undefined) {\r\n                    let fieldType = field.type;\r\n                    let refType: PrimitiveType = typeContext.get(field.referencedType);\r\n\r\n                    // map or array of primitive type (-1)\r\n                    if (!refType) {\r\n                        const typeInfo = field.type.split(\":\");\r\n                        fieldType = typeInfo[0];\r\n                        refType = typeInfo[1] as PrimitiveType; // string\r\n                    }\r\n\r\n                    if (fieldType === \"ref\") {\r\n                        Metadata.addField(metadata, fieldIndex, field.name, refType);\r\n\r\n                    } else {\r\n                        Metadata.addField(metadata, fieldIndex, field.name, { [fieldType]: refType });\r\n                    }\r\n\r\n                } else {\r\n                    Metadata.addField(metadata, fieldIndex, field.name, field.type as PrimitiveType);\r\n                }\r\n            });\r\n        };\r\n\r\n        // 2nd pass, set fields\r\n        reflection.types.forEach((reflectionType) => {\r\n            const schema = typeContext.get(reflectionType.id);\r\n\r\n            // for inheritance support\r\n            const metadata = Metadata.initialize(schema);\r\n\r\n            const inheritedTypes: ReflectionType[] = [];\r\n\r\n            let parentType: ReflectionType = reflectionType;\r\n            do {\r\n                inheritedTypes.push(parentType);\r\n                parentType = reflection.types.find((t) => t.id === parentType.extendsId);\r\n            } while (parentType);\r\n\r\n            let parentFieldIndex = 0;\r\n\r\n            inheritedTypes.reverse().forEach((reflectionType) => {\r\n                // add fields from all inherited classes\r\n                // TODO: refactor this to avoid adding fields from parent classes\r\n                addFields(metadata, reflectionType, parentFieldIndex);\r\n                parentFieldIndex += reflectionType.fields.length;\r\n            });\r\n        });\r\n\r\n        const state: T = new (typeContext.get(reflection.rootType || 0) as unknown as any)();\r\n\r\n        return new Decoder<T>(state, typeContext);\r\n    }\r\n}\r\n","import { Metadata } from \"../../Metadata\";\r\nimport { Collection, NonFunctionNonPrimitivePropNames, NonFunctionPropNames } from \"../../types/HelperTypes\";\r\nimport { Ref } from \"../../encoder/ChangeTree\";\r\nimport { Decoder } from \"../Decoder\";\r\nimport { DataChange } from \"../DecodeOperation\";\r\nimport { OPERATION } from \"../../encoding/spec\";\r\nimport { Schema } from \"../../Schema\";\r\nimport type { DefinitionType } from \"../../annotations\";\r\nimport type { CollectionSchema } from \"../../types/custom/CollectionSchema\";\r\n\r\n//\r\n// Discussion: https://github.com/colyseus/schema/issues/155\r\n//\r\n// Main points:\r\n// - Decouple structures from their callbacks.\r\n// - Registering deep callbacks can be confusing.\r\n// - Avoid closures by allowing to pass a context. (https://github.com/colyseus/schema/issues/155#issuecomment-1804694081)\r\n//\r\n\r\n/**\r\n * TODO: define a schema interface, which even having duplicate definitions, it could be used to get the callback proxy.\r\n *\r\n * ```ts\r\n *     export type SchemaCallbackProxy<RoomState> = (<T extends Schema>(instance: T) => CallbackProxy<T>);\r\n * ```\r\n */\r\nexport type SchemaCallbackProxy<RoomState> = (<T>(instance: T) => CallbackProxy<T>);\r\nexport type GetCallbackProxy = SchemaCallbackProxy<any>; // workaround for compatibility for < colyseus.js0.16.6. Remove me on next major release.\r\n\r\nexport type CallbackProxy<T> = unknown extends T // is \"any\"?\r\n    ? SchemaCallback<T> & CollectionCallback<any, any>\r\n    : T extends Collection<infer K, infer V, infer _>\r\n        ? CollectionCallback<K, V>\r\n        : SchemaCallback<T>;\r\n\r\nexport type SchemaCallback<T> = {\r\n    /**\r\n     * Trigger callback when value of a property changes.\r\n     *\r\n     * @param prop name of the property\r\n     * @param callback callback to be triggered on property change\r\n     * @param immediate trigger immediatelly if property has been already set.\r\n     * @return callback to detach the listener\r\n     */\r\n    listen<K extends NonFunctionPropNames<T>>(\r\n        prop: K,\r\n        callback: (value: T[K], previousValue: T[K]) => void,\r\n        immediate?: boolean,\r\n    ): () => void;\r\n\r\n    /**\r\n     * Trigger callback whenever any property changed within this instance.\r\n     *\r\n     * @param prop name of the property\r\n     * @param callback callback to be triggered on property change\r\n     * @param immediate trigger immediatelly if property has been already set.\r\n     * @return callback to detach the listener\r\n     */\r\n    onChange(callback: () => void): () => void;\r\n\r\n    /**\r\n     * Bind properties to another object. Changes on the properties will be reflected on the target object.\r\n     *\r\n     * @param targetObject object to bind properties to\r\n     * @param properties list of properties to bind. If not provided, all properties will be bound.\r\n     */\r\n    bindTo(targetObject: any, properties?: Array<NonFunctionPropNames<T>>): void;\r\n} & {\r\n    [K in NonFunctionNonPrimitivePropNames<T>]: CallbackProxy<T[K]>;\r\n}\r\n\r\nexport type CollectionCallback<K, V> = {\r\n    /**\r\n     * Trigger callback when an item has been added to the collection.\r\n     *\r\n     * @param callback\r\n     * @param immediate\r\n     * @return callback to detach the onAdd listener\r\n     */\r\n    onAdd(callback: (item: V, index: K) => void, immediate?: boolean): () => void;\r\n\r\n    /**\r\n     * Trigger callback when an item has been removed to the collection.\r\n     *\r\n     * @param callback\r\n     * @return callback to detach the onRemove listener\r\n     */\r\n    onRemove(callback: (item: V, index: K) => void): () => void;\r\n\r\n    /**\r\n     * Trigger callback when the value on a key has changed.\r\n     *\r\n     * THIS METHOD IS NOT RECURSIVE!\r\n     * If you want to listen to changes on individual items, you need to attach callbacks to the them directly inside the `onAdd` callback.\r\n     *\r\n     * @param callback\r\n     * @return callback to detach the onChange listener\r\n     */\r\n    onChange(callback: (item: V, index: K) => void): () => void;\r\n};\r\n\r\ntype OnInstanceAvailableCallback = (callback: (ref: Ref, existing: boolean) => void) => void;\r\n\r\ntype CallContext = {\r\n    instance?: any,\r\n    parentInstance?: any,\r\n    onInstanceAvailable?: OnInstanceAvailableCallback,\r\n}\r\n\r\n\r\nexport function getDecoderStateCallbacks<T extends Schema>(decoder: Decoder<T>): SchemaCallbackProxy<T> {\r\n    const $root = decoder.root;\r\n    const callbacks = $root.callbacks;\r\n\r\n    const onAddCalls: WeakMap<Function, boolean> = new WeakMap();\r\n    let currentOnAddCallback: Function | undefined;\r\n\r\n    decoder.triggerChanges = function (allChanges: DataChange[]) {\r\n        const uniqueRefIds = new Set<number>();\r\n\r\n        for (let i = 0, l = allChanges.length; i < l; i++) {\r\n            const change = allChanges[i];\r\n            const refId = change.refId;\r\n            const ref = change.ref;\r\n            const $callbacks = callbacks[refId];\r\n\r\n            if (!$callbacks) { continue; }\r\n\r\n            //\r\n            // trigger onRemove on child structure.\r\n            //\r\n            if (\r\n                (change.op & OPERATION.DELETE) === OPERATION.DELETE &&\r\n                change.previousValue instanceof Schema\r\n            ) {\r\n                const deleteCallbacks = callbacks[$root.refIds.get(change.previousValue)]?.[OPERATION.DELETE];\r\n                for (let i = deleteCallbacks?.length - 1; i >= 0; i--) {\r\n                    deleteCallbacks[i]();\r\n                }\r\n            }\r\n\r\n            if (ref instanceof Schema) {\r\n                //\r\n                // Handle schema instance\r\n                //\r\n\r\n                if (!uniqueRefIds.has(refId)) {\r\n                    // trigger onChange\r\n                    const replaceCallbacks = $callbacks?.[OPERATION.REPLACE];\r\n                    for (let i = replaceCallbacks?.length - 1; i >= 0; i--) {\r\n                        replaceCallbacks[i]();\r\n                        // try {\r\n                        // } catch (e) {\r\n                        //     console.error(e);\r\n                        // }\r\n                    }\r\n                }\r\n\r\n                if ($callbacks.hasOwnProperty(change.field)) {\r\n                    const fieldCallbacks = $callbacks[change.field];\r\n                    for (let i = fieldCallbacks?.length - 1; i >= 0; i--) {\r\n                        fieldCallbacks[i](change.value, change.previousValue);\r\n                        // try {\r\n                        // } catch (e) {\r\n                        //     console.error(e);\r\n                        // }\r\n                    }\r\n                }\r\n\r\n\r\n            } else {\r\n                //\r\n                // Handle collection of items\r\n                //\r\n\r\n                if ((change.op & OPERATION.DELETE) === OPERATION.DELETE) {\r\n                    //\r\n                    // FIXME: `previousValue` should always be available.\r\n                    //\r\n                    if (change.previousValue !== undefined) {\r\n                        // triger onRemove\r\n                        const deleteCallbacks = $callbacks[OPERATION.DELETE];\r\n                        for (let i = deleteCallbacks?.length - 1; i >= 0; i--) {\r\n                            deleteCallbacks[i](change.previousValue, change.dynamicIndex ?? change.field);\r\n                        }\r\n                    }\r\n\r\n                    // Handle DELETE_AND_ADD operations\r\n                    if ((change.op & OPERATION.ADD) === OPERATION.ADD) {\r\n                        const addCallbacks = $callbacks[OPERATION.ADD];\r\n                        for (let i = addCallbacks?.length - 1; i >= 0; i--) {\r\n                            addCallbacks[i](change.value, change.dynamicIndex ?? change.field);\r\n                        }\r\n                    }\r\n\r\n                } else if (\r\n                    (change.op & OPERATION.ADD) === OPERATION.ADD &&\r\n                    change.previousValue !== change.value\r\n                ) {\r\n                    // triger onAdd\r\n                    const addCallbacks = $callbacks[OPERATION.ADD];\r\n                    for (let i = addCallbacks?.length - 1; i >= 0; i--) {\r\n                        addCallbacks[i](change.value, change.dynamicIndex ?? change.field);\r\n                    }\r\n                }\r\n\r\n                // trigger onChange\r\n                if (\r\n                    change.value !== change.previousValue &&\r\n                    // FIXME: see \"should not encode item if added and removed at the same patch\" test case.\r\n                    // some \"ADD\" + \"DELETE\" operations on same patch are being encoded as \"DELETE\"\r\n                    (change.value !== undefined || change.previousValue !== undefined)\r\n                ) {\r\n                    const replaceCallbacks = $callbacks[OPERATION.REPLACE];\r\n                    for (let i = replaceCallbacks?.length - 1; i >= 0; i--) {\r\n                        replaceCallbacks[i](change.value, change.dynamicIndex ?? change.field);\r\n                    }\r\n                }\r\n            }\r\n\r\n            uniqueRefIds.add(refId);\r\n        }\r\n    };\r\n\r\n    function getProxy(\r\n        metadataOrType: Metadata | DefinitionType,\r\n        context: CallContext\r\n    ) {\r\n        let metadata: Metadata = context.instance?.constructor[Symbol.metadata] || metadataOrType;\r\n        let isCollection = (\r\n            (context.instance && typeof (context.instance['forEach']) === \"function\") ||\r\n            (metadataOrType && typeof ((metadataOrType as typeof Schema)[Symbol.metadata]) === \"undefined\")\r\n        );\r\n\r\n        if (metadata && !isCollection) {\r\n\r\n            const onAddListen = function (\r\n                ref: Ref,\r\n                prop: string,\r\n                callback: (value: any, previousValue: any) => void, immediate: boolean\r\n            ) {\r\n                // immediate trigger\r\n                if (\r\n                    immediate &&\r\n                    context.instance[prop] !== undefined &&\r\n                    !onAddCalls.has(currentOnAddCallback) // Workaround for https://github.com/colyseus/schema/issues/147\r\n                ) {\r\n                    callback(context.instance[prop], undefined);\r\n                }\r\n                return $root.addCallback($root.refIds.get(ref), prop, callback);\r\n            }\r\n\r\n            /**\r\n             * Schema instances\r\n             */\r\n            return new Proxy({\r\n                listen: function listen(prop: string, callback: (value: any, previousValue: any) => void, immediate: boolean = true) {\r\n                    if (context.instance) {\r\n                        return onAddListen(context.instance, prop, callback, immediate);\r\n\r\n                    } else {\r\n                        // collection instance not received yet\r\n                        let detachCallback = () => {};\r\n\r\n                        context.onInstanceAvailable((ref: Ref, existing: boolean) => {\r\n                            detachCallback = onAddListen(ref, prop, callback, immediate && existing && !onAddCalls.has(currentOnAddCallback))\r\n                        });\r\n\r\n                        return () => detachCallback();\r\n                    }\r\n                },\r\n\r\n                onChange: function onChange(callback: () => void) {\r\n                    return $root.addCallback(\r\n                        $root.refIds.get(context.instance),\r\n                        OPERATION.REPLACE,\r\n                        callback\r\n                    );\r\n                },\r\n\r\n                //\r\n                // TODO: refactor `bindTo()` implementation.\r\n                // There is room for improvement.\r\n                //\r\n                bindTo: function bindTo(targetObject: any, properties?: string[]) {\r\n                    if (!properties) {\r\n                        properties = Object.keys(metadata).map((index) => metadata[index as any as number].name);\r\n                    }\r\n                    return $root.addCallback(\r\n                        $root.refIds.get(context.instance),\r\n                        OPERATION.REPLACE,\r\n                        () => {\r\n                            properties.forEach((prop) =>\r\n                                targetObject[prop] = context.instance[prop])\r\n                        }\r\n                    );\r\n                }\r\n            }, {\r\n                get(target, prop: string) {\r\n                    const metadataField = metadata[metadata[prop]];\r\n                    if (metadataField) {\r\n                        const instance = context.instance?.[prop];\r\n                        const onInstanceAvailable: OnInstanceAvailableCallback = (\r\n                            (callback: (ref: Ref, existing: boolean) => void) => {\r\n                                const unbind = $(context.instance).listen(prop, (value, _) => {\r\n                                    callback(value, false);\r\n\r\n                                    // FIXME: by \"unbinding\" the callback here,\r\n                                    // it will not support when the server\r\n                                    // re-instantiates the instance.\r\n                                    //\r\n                                    unbind?.();\r\n                                }, false);\r\n\r\n                                // has existing value\r\n                                if ($root.refIds.get(instance) !== undefined) {\r\n                                    callback(instance, true);\r\n                                }\r\n                            }\r\n                        );\r\n\r\n                        return getProxy(metadataField.type, {\r\n                            // make sure refId is available, otherwise need to wait for the instance to be available.\r\n                            instance: ($root.refIds.get(instance) && instance),\r\n                            parentInstance: context.instance,\r\n                            onInstanceAvailable,\r\n                        });\r\n\r\n                    } else {\r\n                        // accessing the function\r\n                        return target[prop as keyof typeof target];\r\n                    }\r\n                },\r\n                has(target, prop: string) { return metadata[prop] !== undefined; },\r\n                set(_, _1, _2) { throw new Error(\"not allowed\"); },\r\n                deleteProperty(_, _1) { throw new Error(\"not allowed\"); },\r\n            });\r\n\r\n        } else {\r\n            /**\r\n             * Collection instances\r\n             */\r\n\r\n            const onAdd = function (ref: Ref, callback: (value: any, key: any) => void, immediate: boolean) {\r\n                // Trigger callback on existing items\r\n                if (immediate) {\r\n                    (ref as CollectionSchema).forEach((v, k) => callback(v, k));\r\n                }\r\n\r\n                return $root.addCallback($root.refIds.get(ref), OPERATION.ADD, (value: any, key: any) => {\r\n                    onAddCalls.set(callback, true);\r\n                    currentOnAddCallback = callback;\r\n                    callback(value, key);\r\n                    onAddCalls.delete(callback)\r\n                    currentOnAddCallback = undefined;\r\n                });\r\n            };\r\n\r\n            const onRemove = function (ref: Ref, callback: (value: any, key: any) => void) {\r\n                return $root.addCallback($root.refIds.get(ref), OPERATION.DELETE, callback);\r\n            };\r\n\r\n            const onChange = function (ref: Ref, callback: (value: any, key: any) => void) {\r\n                return $root.addCallback($root.refIds.get(ref), OPERATION.REPLACE, callback);\r\n            };\r\n\r\n            return new Proxy({\r\n                onAdd: function(callback: (value: any, key: any) => void, immediate: boolean = true) {\r\n                    //\r\n                    // https://github.com/colyseus/schema/issues/147\r\n                    // If parent instance has \"onAdd\" registered, avoid triggering immediate callback.\r\n                    //\r\n\r\n                    if (context.instance) {\r\n                        return onAdd(context.instance, callback, immediate && !onAddCalls.has(currentOnAddCallback));\r\n\r\n                    } else if (context.onInstanceAvailable) {\r\n                        // collection instance not received yet\r\n                        let detachCallback = () => {};\r\n\r\n                        context.onInstanceAvailable((ref: Ref, existing: boolean) => {\r\n                            detachCallback = onAdd(ref, callback, immediate && existing && !onAddCalls.has(currentOnAddCallback));\r\n                        });\r\n\r\n                        return () => detachCallback();\r\n                    }\r\n                },\r\n                onRemove: function(callback: (value: any, key: any) => void) {\r\n                    if (context.instance) {\r\n                        return onRemove(context.instance, callback);\r\n\r\n                    } else if (context.onInstanceAvailable) {\r\n                        // collection instance not received yet\r\n                        let detachCallback = () => {};\r\n\r\n                        context.onInstanceAvailable((ref: Ref) => {\r\n                            detachCallback = onRemove(ref, callback)\r\n                        });\r\n\r\n                        return () => detachCallback();\r\n                    }\r\n                },\r\n                onChange: function(callback: (value: any, key: any) => void) {\r\n                    if (context.instance) {\r\n                        return onChange(context.instance, callback);\r\n\r\n                    } else if (context.onInstanceAvailable) {\r\n                        // collection instance not received yet\r\n                        let detachCallback = () => {};\r\n\r\n                        context.onInstanceAvailable((ref: Ref) => {\r\n                            detachCallback = onChange(ref, callback)\r\n                        });\r\n\r\n                        return () => detachCallback();\r\n                    }\r\n                },\r\n            }, {\r\n                get(target, prop: string) {\r\n                    if (!target[prop as keyof typeof target]) {\r\n                        throw new Error(`Can't access '${prop}' through callback proxy. access the instance directly.`);\r\n                    }\r\n                    return target[prop as keyof typeof target];\r\n                },\r\n                has(target, prop) { return target[prop as keyof typeof target] !== undefined; },\r\n                set(_, _1, _2) { throw new Error(\"not allowed\"); },\r\n                deleteProperty(_, _1) { throw new Error(\"not allowed\"); },\r\n            });\r\n        }\r\n    }\r\n\r\n    function $<T>(instance: T): CallbackProxy<T> {\r\n        return getProxy(undefined, { instance }) as unknown as CallbackProxy<T>;\r\n    }\r\n\r\n    return $;\r\n}\r\n","import { DataChange } from \"../DecodeOperation\";\r\nimport { Decoder } from \"../Decoder\";\r\n\r\nexport function getRawChangesCallback(\r\n    decoder: Decoder,\r\n    callback: (changes: DataChange[]) => void\r\n) {\r\n    decoder.triggerChanges = callback;\r\n}","import { ChangeTree, IndexedOperations, Ref } from \"./ChangeTree\";\r\nimport { $changes, $fieldIndexesByViewTag, $viewFieldIndexes } from \"../types/symbols\";\r\nimport { DEFAULT_VIEW_TAG } from \"../annotations\";\r\nimport { OPERATION } from \"../encoding/spec\";\r\nimport { Metadata } from \"../Metadata\";\r\nimport { spliceOne } from \"../types/utils\";\r\nimport type { Schema } from \"../Schema\";\r\n\r\nexport function createView(iterable: boolean = false) {\r\n    return new StateView(iterable);\r\n}\r\n\r\nexport class StateView {\r\n    /**\r\n     * Iterable list of items that are visible to this view\r\n     * (Available only if constructed with `iterable: true`)\r\n     */\r\n    items: Ref[];\r\n\r\n    /**\r\n     * List of ChangeTree's that are visible to this view\r\n     */\r\n    visible: WeakSet<ChangeTree> = new WeakSet<ChangeTree>();\r\n\r\n    /**\r\n     * List of ChangeTree's that are invisible to this view\r\n     */\r\n    invisible: WeakSet<ChangeTree> = new WeakSet<ChangeTree>();\r\n\r\n    tags?: WeakMap<ChangeTree, Set<number>>; // TODO: use bit manipulation instead of Set<number> ()\r\n\r\n    /**\r\n     * Manual \"ADD\" operations for changes per ChangeTree, specific to this view.\r\n     * (This is used to force encoding a property, even if it was not changed)\r\n     */\r\n    changes = new Map<number, IndexedOperations>();\r\n\r\n    constructor(public iterable: boolean = false) {\r\n        if (iterable) {\r\n            this.items = [];\r\n        }\r\n    }\r\n\r\n    // TODO: allow to set multiple tags at once\r\n    add(obj: Ref, tag: number = DEFAULT_VIEW_TAG, checkIncludeParent: boolean = true) {\r\n        const changeTree: ChangeTree = obj?.[$changes];\r\n        const parentChangeTree = changeTree.parent;\r\n\r\n        if (!changeTree) {\r\n            console.warn(\"StateView#add(), invalid object:\", obj);\r\n            return false;\r\n\r\n        } else if (\r\n            !parentChangeTree &&\r\n            changeTree.refId !== 0 // allow root object\r\n        ) {\r\n            /**\r\n             * TODO: can we avoid this?\r\n             *\r\n             * When the \"parent\" structure has the @view() tag, it is currently\r\n             * not possible to identify it has to be added to the view as well\r\n             * (this.addParentOf() is not called).\r\n             */\r\n            throw new Error(\r\n                `Cannot add a detached instance to the StateView. Make sure to assign the \"${changeTree.ref.constructor.name}\" instance to the state before calling view.add()`\r\n            );\r\n        }\r\n\r\n        // FIXME: ArraySchema/MapSchema do not have metadata\r\n        const metadata: Metadata = (obj.constructor as typeof Schema)[Symbol.metadata];\r\n        this.visible.add(changeTree);\r\n\r\n        // add to iterable list (only the explicitly added items)\r\n        if (this.iterable && checkIncludeParent) {\r\n            this.items.push(obj);\r\n        }\r\n\r\n        // add parent ChangeTree's\r\n        // - if it was invisible to this view\r\n        // - if it were previously filtered out\r\n        if (checkIncludeParent && parentChangeTree) {\r\n            this.addParentOf(changeTree, tag);\r\n        }\r\n\r\n        let changes = this.changes.get(changeTree.refId);\r\n        if (changes === undefined) {\r\n            changes = {};\r\n            // FIXME / OPTIMIZE: do not add if no changes are needed\r\n            this.changes.set(changeTree.refId, changes);\r\n        }\r\n\r\n        let isChildAdded = false;\r\n\r\n        //\r\n        // Add children of this ChangeTree first.\r\n        // If successful, we must link the current ChangeTree to the child.\r\n        //\r\n        changeTree.forEachChild((change, index) => {\r\n            // Do not ADD children that don't have the same tag\r\n            if (\r\n                metadata &&\r\n                metadata[index].tag !== undefined &&\r\n                metadata[index].tag !== tag\r\n            ) {\r\n                return;\r\n            }\r\n\r\n            if (this.add(change.ref, tag, false)) {\r\n                isChildAdded = true;\r\n            }\r\n        });\r\n\r\n        // set tag\r\n        if (tag !== DEFAULT_VIEW_TAG) {\r\n            if (!this.tags) {\r\n                this.tags = new WeakMap<ChangeTree, Set<number>>();\r\n            }\r\n            let tags: Set<number>;\r\n            if (!this.tags.has(changeTree)) {\r\n                tags = new Set<number>();\r\n                this.tags.set(changeTree, tags);\r\n            } else {\r\n                tags = this.tags.get(changeTree);\r\n            }\r\n            tags.add(tag);\r\n\r\n            // Ref: add tagged properties\r\n            metadata?.[$fieldIndexesByViewTag]?.[tag]?.forEach((index) => {\r\n                if (changeTree.getChange(index) !== OPERATION.DELETE) {\r\n                    changes[index] = OPERATION.ADD;\r\n                }\r\n            });\r\n\r\n        } else if (!changeTree.isNew || isChildAdded) {\r\n            // new structures will be added as part of .encode() call, no need to force it to .encodeView()\r\n            const changeSet = (changeTree.filteredChanges !== undefined)\r\n                ? changeTree.allFilteredChanges\r\n                : changeTree.allChanges;\r\n\r\n            const isInvisible = this.invisible.has(changeTree);\r\n\r\n            for (let i = 0, len = changeSet.operations.length; i < len; i++) {\r\n                const index = changeSet.operations[i];\r\n                if (index === undefined) { continue; } // skip \"undefined\" indexes\r\n\r\n                const op = changeTree.indexedOperations[index] ?? OPERATION.ADD;\r\n                const tagAtIndex = metadata?.[index].tag;\r\n                if (\r\n                    op !== OPERATION.DELETE &&\r\n                    (\r\n                        isInvisible || // if \"invisible\", include all\r\n                        tagAtIndex === undefined || // \"all change\" with no tag\r\n                        tagAtIndex === tag // tagged property\r\n                    )\r\n                ) {\r\n                    changes[index] = op;\r\n                    isChildAdded = true; // FIXME: assign only once\r\n                }\r\n            }\r\n        }\r\n\r\n        return isChildAdded;\r\n    }\r\n\r\n    protected addParentOf(childChangeTree: ChangeTree, tag: number) {\r\n        const changeTree = childChangeTree.parent[$changes];\r\n        const parentIndex = childChangeTree.parentIndex;\r\n\r\n        if (!this.visible.has(changeTree)) {\r\n            // view must have all \"changeTree\" parent tree\r\n            this.visible.add(changeTree);\r\n\r\n            // add parent's parent\r\n            const parentChangeTree: ChangeTree = changeTree.parent?.[$changes];\r\n            if (parentChangeTree && (parentChangeTree.filteredChanges !== undefined)) {\r\n                this.addParentOf(changeTree, tag);\r\n            }\r\n\r\n            // // parent is already available, no need to add it!\r\n            // if (!this.invisible.has(changeTree)) { return; }\r\n        }\r\n\r\n        // add parent's tag properties\r\n        if (changeTree.getChange(parentIndex) !== OPERATION.DELETE) {\r\n            let changes = this.changes.get(changeTree.refId);\r\n            if (changes === undefined) {\r\n                changes = {};\r\n                this.changes.set(changeTree.refId, changes);\r\n            }\r\n\r\n            if (!this.tags) {\r\n                this.tags = new WeakMap<ChangeTree, Set<number>>();\r\n            }\r\n\r\n            let tags: Set<number>;\r\n            if (!this.tags.has(changeTree)) {\r\n                tags = new Set<number>();\r\n                this.tags.set(changeTree, tags);\r\n            } else {\r\n                tags = this.tags.get(changeTree);\r\n            }\r\n            tags.add(tag);\r\n\r\n            changes[parentIndex] = OPERATION.ADD;\r\n        }\r\n    }\r\n\r\n    remove(obj: Ref, tag?: number): this; // hide _isClear parameter from public API\r\n    remove(obj: Ref, tag?: number, _isClear?: boolean): this;\r\n    remove(obj: Ref, tag: number = DEFAULT_VIEW_TAG, _isClear: boolean = false): this {\r\n        const changeTree: ChangeTree = obj[$changes];\r\n        if (!changeTree) {\r\n            console.warn(\"StateView#remove(), invalid object:\", obj);\r\n            return this;\r\n        }\r\n\r\n        this.visible.delete(changeTree);\r\n\r\n        // remove from iterable list\r\n        if (\r\n            this.iterable &&\r\n            !_isClear // no need to remove during clear(), as it will be cleared entirely\r\n        ) {\r\n            spliceOne(this.items, this.items.indexOf(obj));\r\n        }\r\n\r\n        const ref = changeTree.ref;\r\n        const metadata: Metadata = ref.constructor[Symbol.metadata]; // ArraySchema/MapSchema do not have metadata\r\n\r\n        let changes = this.changes.get(changeTree.refId);\r\n        if (changes === undefined) {\r\n            changes = {};\r\n            this.changes.set(changeTree.refId, changes);\r\n        }\r\n\r\n        if (tag === DEFAULT_VIEW_TAG) {\r\n            // parent is collection (Map/Array)\r\n            const parent = changeTree.parent;\r\n            if (parent && !Metadata.isValidInstance(parent) && changeTree.isFiltered) {\r\n                const parentChangeTree = parent[$changes];\r\n                let changes = this.changes.get(parentChangeTree.refId);\r\n                if (changes === undefined) {\r\n                    changes = {};\r\n                    this.changes.set(parentChangeTree.refId, changes);\r\n\r\n                } else if (changes[changeTree.parentIndex] === OPERATION.ADD) {\r\n                    //\r\n                    // SAME PATCH ADD + REMOVE:\r\n                    // The 'changes' of deleted structure should be ignored.\r\n                    //\r\n                    this.changes.delete(changeTree.refId);\r\n                }\r\n\r\n                // DELETE / DELETE BY REF ID\r\n                changes[changeTree.parentIndex] = OPERATION.DELETE;\r\n\r\n                // Remove child schema from visible set\r\n                this._recursiveDeleteVisibleChangeTree(changeTree);\r\n\r\n            } else {\r\n                // delete all \"tagged\" properties.\r\n                metadata?.[$viewFieldIndexes]?.forEach((index) =>\r\n                    changes[index] = OPERATION.DELETE);\r\n            }\r\n\r\n        } else {\r\n            // delete only tagged properties\r\n            metadata?.[$fieldIndexesByViewTag][tag].forEach((index) =>\r\n                changes[index] = OPERATION.DELETE);\r\n        }\r\n\r\n        // remove tag\r\n        if (this.tags && this.tags.has(changeTree)) {\r\n            const tags = this.tags.get(changeTree);\r\n            if (tag === undefined) {\r\n                // delete all tags\r\n                this.tags.delete(changeTree);\r\n            } else {\r\n                // delete specific tag\r\n                tags.delete(tag);\r\n\r\n                // if tag set is empty, delete it entirely\r\n                if (tags.size === 0) {\r\n                    this.tags.delete(changeTree);\r\n                }\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    has(obj: Ref) {\r\n        return this.visible.has(obj[$changes]);\r\n    }\r\n\r\n    hasTag(ob: Ref, tag: number = DEFAULT_VIEW_TAG) {\r\n        const tags = this.tags?.get(ob[$changes]);\r\n        return tags?.has(tag) ?? false;\r\n    }\r\n\r\n    clear() {\r\n        if (!this.iterable) {\r\n            throw new Error(\"StateView#clear() is only available for iterable StateView's. Use StateView(iterable: true) constructor.\");\r\n        }\r\n\r\n        for (let i = 0, l = this.items.length; i < l; i++) {\r\n            this.remove(this.items[i], DEFAULT_VIEW_TAG, true);\r\n        }\r\n\r\n        // clear items array\r\n        this.items.length = 0;\r\n    }\r\n\r\n    isChangeTreeVisible(changeTree: ChangeTree) {\r\n        let isVisible = this.visible.has(changeTree);\r\n\r\n        //\r\n        // TODO: avoid checking for parent visibility, most of the time it's not needed\r\n        // See test case: 'should not be required to manually call view.add() items to child arrays without @view() tag'\r\n        //\r\n        if (!isVisible && changeTree.isVisibilitySharedWithParent){\r\n\r\n            // console.log(\"CHECK AGAINST PARENT...\", {\r\n            //     ref: changeTree.ref.constructor.name,\r\n            //     refId: changeTree.refId,\r\n            //     parent: changeTree.parent.constructor.name,\r\n            // });\r\n\r\n            if (this.visible.has(changeTree.parent[$changes])) {\r\n                this.visible.add(changeTree);\r\n                isVisible = true;\r\n            }\r\n        }\r\n\r\n        return isVisible;\r\n    }\r\n\r\n    protected _recursiveDeleteVisibleChangeTree(changeTree: ChangeTree) {\r\n        changeTree.forEachChild((childChangeTree) => {\r\n            this.visible.delete(childChangeTree);\r\n            this._recursiveDeleteVisibleChangeTree(childChangeTree);\r\n        });\r\n    }\r\n}\r\n","export { Schema } from \"./Schema\";\r\nexport type { DataChange } from \"./decoder/DecodeOperation\";\r\nexport type { ToJSON } from \"./types/HelperTypes\";\r\n\r\nimport { MapSchema } from \"./types/custom/MapSchema\"\r\nexport { MapSchema };\r\n\r\nimport { ArraySchema } from \"./types/custom/ArraySchema\";\r\nexport { ArraySchema };\r\n\r\nimport { CollectionSchema } from \"./types/custom/CollectionSchema\";\r\nexport { CollectionSchema };\r\n\r\nimport { SetSchema } from \"./types/custom/SetSchema\";\r\nexport { SetSchema };\r\n\r\nimport { registerType, defineCustomTypes } from \"./types/registry\";\r\nexport { registerType, defineCustomTypes };\r\n\r\nregisterType(\"map\", { constructor: MapSchema });\r\nregisterType(\"array\", { constructor: ArraySchema });\r\nregisterType(\"set\", { constructor: SetSchema });\r\nregisterType(\"collection\", { constructor: CollectionSchema, });\r\n\r\n// Utils\r\nexport { dumpChanges } from \"./utils\";\r\n\r\n// Encoder / Decoder\r\nexport { $track, $encoder, $decoder, $filter, $getByIndex, $deleteByIndex, $changes, $childType } from \"./types/symbols\";\r\nexport { encode } from \"./encoding/encode\";\r\nexport { decode, type Iterator } from \"./encoding/decode\";\r\n\r\n// Reflection\r\nexport {\r\n    Reflection,\r\n    ReflectionType,\r\n    ReflectionField,\r\n} from \"./Reflection\";\r\n\r\n// Annotations, Metadata and TypeContext\r\nexport { Metadata } from \"./Metadata\";\r\n\r\n// Schema definition types\r\nexport {\r\n    type,\r\n    deprecated,\r\n    defineTypes,\r\n    view,\r\n    schema,\r\n    entity,\r\n    type DefinitionType,\r\n    type PrimitiveType,\r\n    type Definition,\r\n    // Raw schema() return types\r\n    type SchemaWithExtendsConstructor,\r\n    type SchemaWithExtends,\r\n    type SchemaType,\r\n} from \"./annotations\";\r\n\r\nexport { TypeContext } from \"./types/TypeContext\";\r\n\r\n// Helper types for type inference\r\nexport type { InferValueType, InferSchemaInstanceType, AssignableProps } from \"./types/HelperTypes\";\r\n\r\nexport { getDecoderStateCallbacks, CallbackProxy, SchemaCallback, CollectionCallback, SchemaCallbackProxy } from \"./decoder/strategy/StateCallbacks\";\r\nexport { getRawChangesCallback } from \"./decoder/strategy/RawChanges\";\r\n\r\nexport { Encoder } from \"./encoder/Encoder\";\r\nexport { encodeSchemaOperation, encodeArray, encodeKeyValueOperation } from \"./encoder/EncodeOperation\";\r\nexport { ChangeTree, Ref, IRef, type ChangeSetName, type ChangeSet} from \"./encoder/ChangeTree\";\r\nexport { StateView } from \"./encoder/StateView\";\r\n\r\nexport { Decoder } from \"./decoder/Decoder\";\r\nexport { decodeSchemaOperation, decodeKeyValueOperation } from \"./decoder/DecodeOperation\";\r\n\r\nexport { OPERATION } from \"./encoding/spec\";"],"names":["OPERATION","_convoBuffer","_int32","_float32","_float64","_int64","int8","uint8","int16","uint16","int32","uint32","int64","uint64","bigint64","biguint64","float32","float64","boolean","string","number","_a","_b"],"mappings":"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","x_google_ignoreList":[19]}