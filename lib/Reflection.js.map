{"version":3,"file":"Reflection.js","sourceRoot":"","sources":["../src/Reflection.ts"],"names":[],"mappings":"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","sourcesContent":["import { type, PrimitiveType } from \"./annotations\";\r\nimport { TypeContext } from \"./types/TypeContext\";\r\nimport { Metadata } from \"./Metadata\";\r\nimport { ArraySchema } from \"./types/custom/ArraySchema\";\r\nimport { Iterator } from \"./encoding/decode\";\r\nimport { Encoder } from \"./encoder/Encoder\";\r\nimport { Decoder } from \"./decoder/Decoder\";\r\nimport { Schema } from \"./Schema\";\r\n\r\n/**\r\n * Reflection\r\n */\r\nexport class ReflectionField extends Schema {\r\n    @type(\"string\") name: string;\r\n    @type(\"string\") type: string;\r\n    @type(\"number\") referencedType: number;\r\n}\r\n\r\nexport class ReflectionType extends Schema {\r\n    @type(\"number\") id: number;\r\n    @type(\"number\") extendsId: number;\r\n    @type([ ReflectionField ]) fields = new ArraySchema<ReflectionField>();\r\n}\r\n\r\nexport class Reflection extends Schema {\r\n    @type([ReflectionType]) types: ArraySchema<ReflectionType> = new ArraySchema<ReflectionType>();\r\n    @type(\"number\") rootType: number;\r\n\r\n    /**\r\n     * Encodes the TypeContext of an Encoder into a buffer.\r\n     *\r\n     * @param encoder Encoder instance\r\n     * @param it\r\n     * @returns\r\n     */\r\n    static encode(encoder: Encoder, it: Iterator = { offset: 0 }) {\r\n        const context = encoder.context;\r\n\r\n        const reflection = new Reflection();\r\n        const reflectionEncoder = new Encoder(reflection);\r\n\r\n        // rootType is usually the first schema passed to the Encoder\r\n        // (unless it inherits from another schema)\r\n        const rootType = context.schemas.get(encoder.state.constructor);\r\n        if (rootType > 0) { reflection.rootType = rootType; }\r\n\r\n        const includedTypeIds = new Set<number>();\r\n        const pendingReflectionTypes: { [typeid: number]: ReflectionType[] } = {};\r\n\r\n        // add type to reflection in a way that respects inheritance\r\n        // (parent types should be added before their children)\r\n        const addType = (type: ReflectionType) => {\r\n            if (type.extendsId === undefined || includedTypeIds.has(type.extendsId)) {\r\n                includedTypeIds.add(type.id);\r\n\r\n                reflection.types.push(type);\r\n\r\n                const deps = pendingReflectionTypes[type.id];\r\n                if (deps !== undefined) {\r\n                    delete pendingReflectionTypes[type.id];\r\n                    deps.forEach((childType) => addType(childType));\r\n                }\r\n            } else {\r\n                if (pendingReflectionTypes[type.extendsId] === undefined) {\r\n                    pendingReflectionTypes[type.extendsId] = [];\r\n                }\r\n                pendingReflectionTypes[type.extendsId].push(type);\r\n            }\r\n        };\r\n\r\n        context.schemas.forEach((typeid, klass) => {\r\n            const type = new ReflectionType();\r\n            type.id = Number(typeid);\r\n\r\n            // support inheritance\r\n            const inheritFrom = Object.getPrototypeOf(klass);\r\n            if (inheritFrom !== Schema) {\r\n                type.extendsId = context.schemas.get(inheritFrom);\r\n            }\r\n\r\n            const metadata = klass[Symbol.metadata];\r\n\r\n            //\r\n            // FIXME: this is a workaround for inherited types without additional fields\r\n            // if metadata is the same reference as the parent class - it means the class has no own metadata\r\n            //\r\n            if (metadata !== inheritFrom[Symbol.metadata]) {\r\n                for (const fieldIndex in metadata) {\r\n                    const index = Number(fieldIndex);\r\n                    const fieldName = metadata[index].name;\r\n\r\n                    // skip fields from parent classes\r\n                    if (!Object.prototype.hasOwnProperty.call(metadata, fieldName)) {\r\n                        continue;\r\n                    }\r\n\r\n                    const reflectionField = new ReflectionField();\r\n                    reflectionField.name = fieldName;\r\n\r\n                    let fieldType: string;\r\n\r\n                    const field = metadata[index];\r\n\r\n                    if (typeof (field.type) === \"string\") {\r\n                        fieldType = field.type;\r\n\r\n                    } else {\r\n                        let childTypeSchema: typeof Schema;\r\n\r\n                        //\r\n                        // TODO: refactor below.\r\n                        //\r\n                        if (Schema.is(field.type)) {\r\n                            fieldType = \"ref\";\r\n                            childTypeSchema = field.type as typeof Schema;\r\n\r\n                        } else {\r\n                            fieldType = Object.keys(field.type)[0];\r\n\r\n                            if (typeof (field.type[fieldType as keyof typeof field.type]) === \"string\") {\r\n                                fieldType += \":\" + field.type[fieldType as keyof typeof field.type]; // array:string\r\n\r\n                            } else {\r\n                                childTypeSchema = field.type[fieldType as keyof typeof field.type];\r\n                            }\r\n                        }\r\n\r\n                        reflectionField.referencedType = (childTypeSchema)\r\n                            ? context.getTypeId(childTypeSchema)\r\n                            : -1;\r\n                    }\r\n\r\n                    reflectionField.type = fieldType;\r\n                    type.fields.push(reflectionField);\r\n                }\r\n            }\r\n\r\n            addType(type);\r\n        });\r\n\r\n        // in case there are types that were not added due to inheritance\r\n        for (const typeid in pendingReflectionTypes) {\r\n            pendingReflectionTypes[typeid].forEach((type) =>\r\n                reflection.types.push(type))\r\n        }\r\n\r\n        const buf = reflectionEncoder.encodeAll(it);\r\n        return buf.slice(0, it.offset)\r\n        // return Buffer.from(buf, 0, it.offset);\r\n    }\r\n\r\n    /**\r\n     * Decodes the TypeContext from a buffer into a Decoder instance.\r\n     *\r\n     * @param bytes Reflection.encode() output\r\n     * @param it\r\n     * @returns Decoder instance\r\n     */\r\n    static decode<T extends Schema = Schema>(bytes: Buffer, it?: Iterator): Decoder<T> {\r\n        const reflection = new Reflection();\r\n\r\n        const reflectionDecoder = new Decoder(reflection);\r\n        reflectionDecoder.decode(bytes, it);\r\n\r\n        const typeContext = new TypeContext();\r\n\r\n        // 1st pass, initialize metadata + inheritance\r\n        reflection.types.forEach((reflectionType) => {\r\n            const parentClass: typeof Schema = typeContext.get(reflectionType.extendsId) ?? Schema;\r\n            const schema: typeof Schema = class _ extends parentClass {};\r\n\r\n            // register for inheritance support\r\n            TypeContext.register(schema);\r\n\r\n            // // for inheritance support\r\n            // Metadata.initialize(schema);\r\n\r\n            typeContext.add(schema, reflectionType.id);\r\n        }, {});\r\n\r\n        // define fields\r\n        const addFields = (metadata: Metadata, reflectionType: ReflectionType, parentFieldIndex: number) => {\r\n            reflectionType.fields.forEach((field, i) => {\r\n                const fieldIndex = parentFieldIndex + i;\r\n\r\n                if (field.referencedType !== undefined) {\r\n                    let fieldType = field.type;\r\n                    let refType: PrimitiveType = typeContext.get(field.referencedType);\r\n\r\n                    // map or array of primitive type (-1)\r\n                    if (!refType) {\r\n                        const typeInfo = field.type.split(\":\");\r\n                        fieldType = typeInfo[0];\r\n                        refType = typeInfo[1] as PrimitiveType; // string\r\n                    }\r\n\r\n                    if (fieldType === \"ref\") {\r\n                        Metadata.addField(metadata, fieldIndex, field.name, refType);\r\n\r\n                    } else {\r\n                        Metadata.addField(metadata, fieldIndex, field.name, { [fieldType]: refType });\r\n                    }\r\n\r\n                } else {\r\n                    Metadata.addField(metadata, fieldIndex, field.name, field.type as PrimitiveType);\r\n                }\r\n            });\r\n        };\r\n\r\n        // 2nd pass, set fields\r\n        reflection.types.forEach((reflectionType) => {\r\n            const schema = typeContext.get(reflectionType.id);\r\n\r\n            // for inheritance support\r\n            const metadata = Metadata.initialize(schema);\r\n\r\n            const inheritedTypes: ReflectionType[] = [];\r\n\r\n            let parentType: ReflectionType = reflectionType;\r\n            do {\r\n                inheritedTypes.push(parentType);\r\n                parentType = reflection.types.find((t) => t.id === parentType.extendsId);\r\n            } while (parentType);\r\n\r\n            let parentFieldIndex = 0;\r\n\r\n            inheritedTypes.reverse().forEach((reflectionType) => {\r\n                // add fields from all inherited classes\r\n                // TODO: refactor this to avoid adding fields from parent classes\r\n                addFields(metadata, reflectionType, parentFieldIndex);\r\n                parentFieldIndex += reflectionType.fields.length;\r\n            });\r\n        });\r\n\r\n        const state: T = new (typeContext.get(reflection.rootType || 0) as unknown as any)();\r\n\r\n        return new Decoder<T>(state, typeContext);\r\n    }\r\n}\r\n"]}