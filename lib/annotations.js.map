{"version":3,"file":"annotations.js","sourceRoot":"","sources":["../src/annotations.ts"],"names":[],"mappings":"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","sourcesContent":["import \"./symbol.shim\";\r\nimport { Schema } from './Schema';\r\nimport { ArraySchema } from './types/custom/ArraySchema';\r\nimport { MapSchema } from './types/custom/MapSchema';\r\nimport { getNormalizedType, Metadata } from \"./Metadata\";\r\nimport { $changes, $childType, $descriptors, $numFields, $track } from \"./types/symbols\";\r\nimport { TypeDefinition, getType } from \"./types/registry\";\r\nimport { OPERATION } from \"./encoding/spec\";\r\nimport { TypeContext } from \"./types/TypeContext\";\r\nimport { assertInstanceType, assertType } from \"./encoding/assert\";\r\nimport type { InferValueType, InferSchemaInstanceType, AssignableProps, IsNever } from \"./types/HelperTypes\";\r\nimport { CollectionSchema } from \"./types/custom/CollectionSchema\";\r\nimport { SetSchema } from \"./types/custom/SetSchema\";\r\n\r\nexport type RawPrimitiveType = \"string\" |\r\n    \"number\" |\r\n    \"boolean\" |\r\n    \"int8\" |\r\n    \"uint8\" |\r\n    \"int16\" |\r\n    \"uint16\" |\r\n    \"int32\" |\r\n    \"uint32\" |\r\n    \"int64\" |\r\n    \"uint64\" |\r\n    \"float32\" |\r\n    \"float64\" |\r\n    \"bigint64\" |\r\n    \"biguint64\";\r\n\r\nexport type PrimitiveType = RawPrimitiveType | typeof Schema | object;\r\n\r\n// TODO: infer \"default\" value type correctly.\r\nexport type DefinitionType<T extends PrimitiveType = PrimitiveType> = T\r\n    | T[]\r\n    | { type: T, default?: InferValueType<T>, view?: boolean | number }\r\n    | { array: T, default?: ArraySchema<InferValueType<T>>, view?: boolean | number }\r\n    | { map: T, default?: MapSchema<InferValueType<T>>, view?: boolean | number }\r\n    | { collection: T, default?: CollectionSchema<InferValueType<T>>, view?: boolean | number }\r\n    | { set: T, default?: SetSchema<InferValueType<T>>, view?: boolean | number };\r\n\r\nexport type Definition = { [field: string]: DefinitionType };\r\n\r\nexport interface TypeOptions {\r\n    manual?: boolean,\r\n}\r\n\r\nexport const DEFAULT_VIEW_TAG = -1;\r\n\r\nexport function entity(constructor: any): any {\r\n    TypeContext.register(constructor as typeof Schema);\r\n    return constructor;\r\n}\r\n\r\n/**\r\n * [See documentation](https://docs.colyseus.io/state/schema/)\r\n *\r\n * Annotate a Schema property to be serializeable.\r\n * \\@type()'d fields are automatically flagged as \"dirty\" for the next patch.\r\n *\r\n * @example Standard usage, with automatic change tracking.\r\n * ```\r\n * \\@type(\"string\") propertyName: string;\r\n * ```\r\n *\r\n * @example You can provide the \"manual\" option if you'd like to manually control your patches via .setDirty().\r\n * ```\r\n * \\@type(\"string\", { manual: true })\r\n * ```\r\n */\r\n// export function type(type: DefinitionType, options?: TypeOptions) {\r\n//     return function ({ get, set }, context: ClassAccessorDecoratorContext): ClassAccessorDecoratorResult<Schema, any> {\r\n//         if (context.kind !== \"accessor\") {\r\n//             throw new Error(\"@type() is only supported for class accessor properties\");\r\n//         }\r\n\r\n//         const field = context.name.toString();\r\n\r\n//         //\r\n//         // detect index for this field, considering inheritance\r\n//         //\r\n//         const parent = Object.getPrototypeOf(context.metadata);\r\n//         let fieldIndex: number = context.metadata[$numFields] // current structure already has fields defined\r\n//             ?? (parent && parent[$numFields]) // parent structure has fields defined\r\n//             ?? -1; // no fields defined\r\n//         fieldIndex++;\r\n\r\n//         if (\r\n//             !parent && // the parent already initializes the `$changes` property\r\n//             !Metadata.hasFields(context.metadata)\r\n//         ) {\r\n//             context.addInitializer(function (this: Ref) {\r\n//                 Object.defineProperty(this, $changes, {\r\n//                     value: new ChangeTree(this),\r\n//                     enumerable: false,\r\n//                     writable: true\r\n//                 });\r\n//             });\r\n//         }\r\n\r\n//         Metadata.addField(context.metadata, fieldIndex, field, type);\r\n\r\n//         const isArray = ArraySchema.is(type);\r\n//         const isMap = !isArray && MapSchema.is(type);\r\n\r\n//         // if (options && options.manual) {\r\n//         //     // do not declare getter/setter descriptor\r\n//         //     definition.descriptors[field] = {\r\n//         //         enumerable: true,\r\n//         //         configurable: true,\r\n//         //         writable: true,\r\n//         //     };\r\n//         //     return;\r\n//         // }\r\n\r\n//         return {\r\n//             init(value) {\r\n//                 // TODO: may need to convert ArraySchema/MapSchema here\r\n\r\n//                 // do not flag change if value is undefined.\r\n//                 if (value !== undefined) {\r\n//                     this[$changes].change(fieldIndex);\r\n\r\n//                     // automaticallty transform Array into ArraySchema\r\n//                     if (isArray) {\r\n//                         if (!(value instanceof ArraySchema)) {\r\n//                             value = new ArraySchema(...value);\r\n//                         }\r\n//                         value[$childType] = Object.values(type)[0];\r\n//                     }\r\n\r\n//                     // automaticallty transform Map into MapSchema\r\n//                     if (isMap) {\r\n//                         if (!(value instanceof MapSchema)) {\r\n//                             value = new MapSchema(value);\r\n//                         }\r\n//                         value[$childType] = Object.values(type)[0];\r\n//                     }\r\n\r\n//                     // try to turn provided structure into a Proxy\r\n//                     if (value['$proxy'] === undefined) {\r\n//                         if (isMap) {\r\n//                             value = getMapProxy(value);\r\n//                         }\r\n//                     }\r\n\r\n//                 }\r\n\r\n//                 return value;\r\n//             },\r\n\r\n//             get() {\r\n//                 return get.call(this);\r\n//             },\r\n\r\n//             set(value: any) {\r\n//                 /**\r\n//                  * Create Proxy for array or map items\r\n//                  */\r\n\r\n//                 // skip if value is the same as cached.\r\n//                 if (value === get.call(this)) {\r\n//                     return;\r\n//                 }\r\n\r\n//                 if (\r\n//                     value !== undefined &&\r\n//                     value !== null\r\n//                 ) {\r\n//                     // automaticallty transform Array into ArraySchema\r\n//                     if (isArray) {\r\n//                         if (!(value instanceof ArraySchema)) {\r\n//                             value = new ArraySchema(...value);\r\n//                         }\r\n//                         value[$childType] = Object.values(type)[0];\r\n//                     }\r\n\r\n//                     // automaticallty transform Map into MapSchema\r\n//                     if (isMap) {\r\n//                         if (!(value instanceof MapSchema)) {\r\n//                             value = new MapSchema(value);\r\n//                         }\r\n//                         value[$childType] = Object.values(type)[0];\r\n//                     }\r\n\r\n//                     // try to turn provided structure into a Proxy\r\n//                     if (value['$proxy'] === undefined) {\r\n//                         if (isMap) {\r\n//                             value = getMapProxy(value);\r\n//                         }\r\n//                     }\r\n\r\n//                     // flag the change for encoding.\r\n//                     this[$changes].change(fieldIndex);\r\n\r\n//                     //\r\n//                     // call setParent() recursively for this and its child\r\n//                     // structures.\r\n//                     //\r\n//                     if (value[$changes]) {\r\n//                         value[$changes].setParent(\r\n//                             this,\r\n//                             this[$changes].root,\r\n//                             Metadata.getIndex(context.metadata, field),\r\n//                         );\r\n//                     }\r\n\r\n//                 } else if (get.call(this)) {\r\n//                     //\r\n//                     // Setting a field to `null` or `undefined` will delete it.\r\n//                     //\r\n//                     this[$changes].delete(field);\r\n//                 }\r\n\r\n//                 set.call(this, value);\r\n//             },\r\n//         };\r\n//     }\r\n// }\r\n\r\nexport function view<T> (tag: number = DEFAULT_VIEW_TAG) {\r\n    return function(target: T, fieldName: string) {\r\n        const constructor = target.constructor as typeof Schema;\r\n\r\n        const parentClass = Object.getPrototypeOf(constructor);\r\n        const parentMetadata = parentClass[Symbol.metadata];\r\n\r\n        // TODO: use Metadata.initialize()\r\n        const metadata: Metadata = (constructor[Symbol.metadata] ??= Object.assign({}, constructor[Symbol.metadata], parentMetadata ?? Object.create(null)));\r\n        // const fieldIndex = metadata[fieldName];\r\n\r\n        // if (!metadata[fieldIndex]) {\r\n        //     //\r\n        //     // detect index for this field, considering inheritance\r\n        //     //\r\n        //     metadata[fieldIndex] = {\r\n        //         type: undefined,\r\n        //         index: (metadata[$numFields] // current structure already has fields defined\r\n        //             ?? (parentMetadata && parentMetadata[$numFields]) // parent structure has fields defined\r\n        //             ?? -1) + 1 // no fields defined\r\n        //     }\r\n        // }\r\n\r\n        Metadata.setTag(metadata, fieldName, tag);\r\n    }\r\n}\r\n\r\nexport function unreliable<T> (target: T, field: string) {\r\n    //\r\n    // FIXME: the following block of code is repeated across `@type()`, `@deprecated()` and `@unreliable()` decorators.\r\n    //\r\n    const constructor = target.constructor as typeof Schema;\r\n\r\n    const parentClass = Object.getPrototypeOf(constructor);\r\n    const parentMetadata = parentClass[Symbol.metadata];\r\n\r\n    // TODO: use Metadata.initialize()\r\n    const metadata: Metadata = (constructor[Symbol.metadata] ??= Object.assign({}, constructor[Symbol.metadata], parentMetadata ?? Object.create(null)));\r\n\r\n    // if (!metadata[field]) {\r\n    //     //\r\n    //     // detect index for this field, considering inheritance\r\n    //     //\r\n    //     metadata[field] = {\r\n    //         type: undefined,\r\n    //         index: (metadata[$numFields] // current structure already has fields defined\r\n    //             ?? (parentMetadata && parentMetadata[$numFields]) // parent structure has fields defined\r\n    //             ?? -1) + 1 // no fields defined\r\n    //     }\r\n    // }\r\n\r\n    // add owned flag to the field\r\n    metadata[metadata[field]].unreliable = true;\r\n}\r\n\r\nexport function type (\r\n    type: DefinitionType,\r\n    options?: TypeOptions\r\n): PropertyDecorator {\r\n    return function (target: typeof Schema, field: string) {\r\n        const constructor = target.constructor as typeof Schema;\r\n\r\n        if (!type) {\r\n            throw new Error(`${constructor.name}: @type() reference provided for \"${field}\" is undefined. Make sure you don't have any circular dependencies.`);\r\n        }\r\n\r\n        // Normalize type (enum/collection/etc)\r\n        type = getNormalizedType(type);\r\n\r\n        // for inheritance support\r\n        TypeContext.register(constructor);\r\n\r\n        const parentClass = Object.getPrototypeOf(constructor);\r\n        const parentMetadata =  parentClass[Symbol.metadata];\r\n        const metadata = Metadata.initialize(constructor);\r\n\r\n        let fieldIndex: number = metadata[field];\r\n\r\n        /**\r\n         * skip if descriptor already exists for this field (`@deprecated()`)\r\n         */\r\n        if (metadata[fieldIndex] !== undefined) {\r\n            if (metadata[fieldIndex].deprecated) {\r\n                // do not create accessors for deprecated properties.\r\n                return;\r\n\r\n            } else if (metadata[fieldIndex].type !== undefined) {\r\n                // trying to define same property multiple times across inheritance.\r\n                // https://github.com/colyseus/colyseus-unity3d/issues/131#issuecomment-814308572\r\n                try {\r\n                    throw new Error(`@colyseus/schema: Duplicate '${field}' definition on '${constructor.name}'.\\nCheck @type() annotation`);\r\n\r\n                } catch (e) {\r\n                    const definitionAtLine = e.stack.split(\"\\n\")[4].trim();\r\n                    throw new Error(`${e.message} ${definitionAtLine}`);\r\n                }\r\n            }\r\n\r\n        } else {\r\n            //\r\n            // detect index for this field, considering inheritance\r\n            //\r\n            fieldIndex = metadata[$numFields] // current structure already has fields defined\r\n                ?? (parentMetadata && parentMetadata[$numFields]) // parent structure has fields defined\r\n                ?? -1; // no fields defined\r\n            fieldIndex++;\r\n        }\r\n\r\n        if (options && options.manual) {\r\n            Metadata.addField(\r\n                metadata,\r\n                fieldIndex,\r\n                field,\r\n                type,\r\n                {\r\n                    // do not declare getter/setter descriptor\r\n                    enumerable: true,\r\n                    configurable: true,\r\n                    writable: true,\r\n                }\r\n            );\r\n\r\n        } else {\r\n            const complexTypeKlass = typeof(Object.keys(type)[0]) === \"string\" && getType(Object.keys(type)[0]);\r\n\r\n            const childType = (complexTypeKlass)\r\n                ? Object.values(type)[0]\r\n                : type;\r\n\r\n            Metadata.addField(\r\n                metadata,\r\n                fieldIndex,\r\n                field,\r\n                type,\r\n                getPropertyDescriptor(`_${field}`, fieldIndex, childType, complexTypeKlass)\r\n            );\r\n        }\r\n    }\r\n}\r\n\r\nexport function getPropertyDescriptor(\r\n    fieldCached: string,\r\n    fieldIndex: number,\r\n    type: DefinitionType,\r\n    complexTypeKlass: TypeDefinition,\r\n) {\r\n    return {\r\n        get: function (this: Schema) { return this[fieldCached as keyof Schema]; },\r\n        set: function (this: Schema, value: any) {\r\n            const previousValue = this[fieldCached as keyof Schema] ?? undefined;\r\n\r\n            // skip if value is the same as cached.\r\n            if (value === previousValue) { return; }\r\n\r\n            if (\r\n                value !== undefined &&\r\n                value !== null\r\n            ) {\r\n                if (complexTypeKlass) {\r\n                    // automaticallty transform Array into ArraySchema\r\n                    if (complexTypeKlass.constructor === ArraySchema && !(value instanceof ArraySchema)) {\r\n                        value = new ArraySchema(...value);\r\n                    }\r\n\r\n                    // automaticallty transform Map into MapSchema\r\n                    if (complexTypeKlass.constructor === MapSchema && !(value instanceof MapSchema)) {\r\n                        value = new MapSchema(value);\r\n                    }\r\n\r\n                    // // automaticallty transform Array into SetSchema\r\n                    // if (complexTypeKlass.constructor === SetSchema && !(value instanceof SetSchema)) {\r\n                    //     value = new SetSchema(value);\r\n                    // }\r\n\r\n                    value[$childType] = type;\r\n\r\n                } else if (typeof (type) !== \"string\") {\r\n                    assertInstanceType(value, type as typeof Schema, this, fieldCached.substring(1));\r\n\r\n                } else {\r\n                    assertType(value, type, this, fieldCached.substring(1));\r\n                }\r\n\r\n                const changeTree = this[$changes];\r\n\r\n                //\r\n                // Replacing existing \"ref\", remove it from root.\r\n                //\r\n                if (previousValue !== undefined && previousValue[$changes]) {\r\n                    changeTree.root?.remove(previousValue[$changes]);\r\n                    (this.constructor as typeof Schema)[$track](changeTree, fieldIndex, OPERATION.DELETE_AND_ADD);\r\n\r\n                } else {\r\n                    (this.constructor as typeof Schema)[$track](changeTree, fieldIndex, OPERATION.ADD);\r\n                }\r\n\r\n                //\r\n                // call setParent() recursively for this and its child\r\n                // structures.\r\n                //\r\n                value[$changes]?.setParent(this, changeTree.root, fieldIndex);\r\n\r\n            } else if (previousValue !== undefined) {\r\n                //\r\n                // Setting a field to `null` or `undefined` will delete it.\r\n                //\r\n                this[$changes].delete(fieldIndex);\r\n            }\r\n\r\n            this[fieldCached as keyof Schema] = value;\r\n        },\r\n\r\n        enumerable: true,\r\n        configurable: true\r\n    };\r\n}\r\n\r\n/**\r\n * `@deprecated()` flag a field as deprecated.\r\n * The previous `@type()` annotation should remain along with this one.\r\n */\r\n\r\nexport function deprecated(throws: boolean = true): PropertyDecorator {\r\n    return function (klass: typeof Schema, field: string) {\r\n        //\r\n        // FIXME: the following block of code is repeated across `@type()`, `@deprecated()` and `@unreliable()` decorators.\r\n        //\r\n        const constructor = klass.constructor as typeof Schema;\r\n\r\n        const parentClass = Object.getPrototypeOf(constructor);\r\n        const parentMetadata = parentClass[Symbol.metadata];\r\n        const metadata: Metadata = (constructor[Symbol.metadata] ??= Object.assign({}, constructor[Symbol.metadata], parentMetadata ?? Object.create(null)));\r\n        const fieldIndex = metadata[field];\r\n\r\n        // if (!metadata[field]) {\r\n        //     //\r\n        //     // detect index for this field, considering inheritance\r\n        //     //\r\n        //     metadata[field] = {\r\n        //         type: undefined,\r\n        //         index: (metadata[$numFields] // current structure already has fields defined\r\n        //             ?? (parentMetadata && parentMetadata[$numFields]) // parent structure has fields defined\r\n        //             ?? -1) + 1 // no fields defined\r\n        //     }\r\n        // }\r\n\r\n        metadata[fieldIndex].deprecated = true;\r\n\r\n        if (throws) {\r\n            metadata[$descriptors] ??= {};\r\n            metadata[$descriptors][field] = {\r\n                get: function () { throw new Error(`${field} is deprecated.`); },\r\n                set: function (this: Schema, value: any) { /* throw new Error(`${field} is deprecated.`); */ },\r\n                enumerable: false,\r\n                configurable: true\r\n            };\r\n        }\r\n\r\n        // flag metadata[field] as non-enumerable\r\n        Object.defineProperty(metadata, fieldIndex, {\r\n            value: metadata[fieldIndex],\r\n            enumerable: false,\r\n            configurable: true\r\n        });\r\n    }\r\n}\r\n\r\nexport function defineTypes(\r\n    target: typeof Schema,\r\n    fields: Definition,\r\n    options?: TypeOptions\r\n) {\r\n    for (let field in fields) {\r\n        type(fields[field], options)(target.prototype, field);\r\n    }\r\n    return target;\r\n}\r\n\r\n// Helper type to extract InitProps from initialize method\r\n// Supports both single object parameter and multiple parameters\r\n// If no initialize method is specified, use AssignableProps for field initialization\r\ntype ExtractInitProps<T> = T extends { initialize: (...args: infer P) => void }\r\n    ? P extends readonly []\r\n        ? never\r\n        : P extends readonly [infer First]\r\n            ? First extends object\r\n                ? First\r\n                : P\r\n            : P\r\n    : T extends Definition\r\n        ? AssignableProps<InferSchemaInstanceType<T>>\r\n        : never;\r\n\r\n// Helper type to determine if InitProps should be required\r\ntype IsInitPropsRequired<T> = T extends { initialize: (props: any) => void }\r\n    ? true\r\n    : T extends { initialize: (...args: infer P) => void }\r\n        ? P extends readonly []\r\n            ? false\r\n            : true\r\n        : false;\r\n\r\nexport interface SchemaWithExtends<T extends Definition, P extends typeof Schema, > {\r\n    extends: <T2 extends Definition = Definition>(\r\n        fields: T2 & ThisType<InferSchemaInstanceType<T & T2>>,\r\n        name?: string\r\n    ) => SchemaWithExtendsConstructor<T & T2, ExtractInitProps<T2>, P>;\r\n}\r\n\r\n/**\r\n * Get the type of the schema defined via `schema({...})` method.\r\n *\r\n * @example\r\n * const Entity = schema({\r\n *     x: \"number\",\r\n *     y: \"number\",\r\n * });\r\n * type Entity = SchemaType<typeof Entity>;\r\n */\r\nexport type SchemaType<T extends {'~type': any}> = T['~type'];\r\n\r\nexport interface SchemaWithExtendsConstructor<\r\n    T extends Definition,\r\n    InitProps,\r\n    P extends typeof Schema\r\n> extends SchemaWithExtends<T, P> {\r\n    '~type': InferSchemaInstanceType<T>;\r\n    new (...args: [InitProps] extends [never] ? [] : InitProps extends readonly any[] ? InitProps : IsInitPropsRequired<T> extends true ? [InitProps] : [InitProps?]): InferSchemaInstanceType<T> & InstanceType<P>;\r\n    prototype: InferSchemaInstanceType<T> & InstanceType<P> & {\r\n        initialize(...args: [InitProps] extends [never] ? [] : InitProps extends readonly any[] ? InitProps : [InitProps]): void;\r\n    };\r\n}\r\n\r\nexport function schema<\r\n    T extends Record<string, DefinitionType>,\r\n    P extends typeof Schema = typeof Schema\r\n>(\r\n    fieldsAndMethods: T & ThisType<InferSchemaInstanceType<T>>,\r\n    name?: string,\r\n    inherits: P = Schema as P\r\n): SchemaWithExtendsConstructor<T, ExtractInitProps<T>, P> {\r\n    const fields: any = {};\r\n    const methods: any = {};\r\n\r\n    const defaultValues: any = {};\r\n    const viewTagFields: any = {};\r\n\r\n    for (let fieldName in fieldsAndMethods) {\r\n        const value: any = fieldsAndMethods[fieldName] as DefinitionType;\r\n        if (typeof (value) === \"object\") {\r\n            if (value['view'] !== undefined) {\r\n                viewTagFields[fieldName] = (typeof (value['view']) === \"boolean\")\r\n                    ? DEFAULT_VIEW_TAG\r\n                    : value['view'];\r\n            }\r\n\r\n            fields[fieldName] = getNormalizedType(value);\r\n\r\n            // If no explicit default provided, handle automatic instantiation for collection types\r\n            if (!Object.prototype.hasOwnProperty.call(value, 'default')) {\r\n                // TODO: remove Array.isArray() check. Use ['array'] !== undefined only.\r\n                if (Array.isArray(value) || value['array'] !== undefined) {\r\n                    // Collection: Array → new ArraySchema()\r\n                    defaultValues[fieldName] = new ArraySchema();\r\n\r\n                } else if (value['map'] !== undefined) {\r\n                    // Collection: Map → new MapSchema()\r\n                    defaultValues[fieldName] = new MapSchema();\r\n\r\n                } else if (value['collection'] !== undefined) {\r\n                    // Collection: Collection → new CollectionSchema()\r\n                    defaultValues[fieldName] = new CollectionSchema();\r\n\r\n                } else if (value['set'] !== undefined) {\r\n                    // Collection: Set → new SetSchema()\r\n                    defaultValues[fieldName] = new SetSchema();\r\n\r\n                } else if (value['type'] !== undefined && Schema.is(value['type'])) {\r\n                    // Direct Schema type: Type → new Type()\r\n                    if (!value['type'].prototype.initialize || value['type'].prototype.initialize.length === 0) {\r\n                        // only auto-initialize Schema instances if:\r\n                        // - they don't have an initialize method\r\n                        // - or initialize method doesn't accept any parameters\r\n                        defaultValues[fieldName] = new value['type']();\r\n                    }\r\n                }\r\n            } else {\r\n                defaultValues[fieldName] = value['default'];\r\n            }\r\n\r\n\r\n        } else if (typeof (value) === \"function\") {\r\n            if (Schema.is(value)) {\r\n                // Direct Schema type: Type → new Type()\r\n                if (!value.prototype.initialize || value.prototype.initialize.length === 0) {\r\n                    // only auto-initialize Schema instances if:\r\n                    // - they don't have an initialize method\r\n                    // - or initialize method doesn't accept any parameters\r\n                    defaultValues[fieldName] = new value();\r\n                }\r\n                fields[fieldName] = getNormalizedType(value);\r\n            } else {\r\n                methods[fieldName] = value;\r\n            }\r\n\r\n        } else {\r\n            fields[fieldName] = getNormalizedType(value);\r\n        }\r\n    }\r\n\r\n    const getDefaultValues = () => {\r\n        const defaults: any = {};\r\n\r\n        // use current class default values\r\n        for (const fieldName in defaultValues) {\r\n            const defaultValue = defaultValues[fieldName];\r\n            if (defaultValue && typeof defaultValue.clone === 'function') {\r\n                // complex, cloneable values, e.g. Schema, ArraySchema, MapSchema, CollectionSchema, SetSchema\r\n                defaults[fieldName] = defaultValue.clone();\r\n            } else {\r\n                // primitives and non-cloneable values\r\n                defaults[fieldName] = defaultValue;\r\n            }\r\n        }\r\n        return defaults;\r\n    };\r\n\r\n    const getParentProps = (props: any) => {\r\n        const fieldNames = Object.keys(fields);\r\n        const parentProps: any = {};\r\n        for (const key in props) {\r\n            if (!fieldNames.includes(key)) {\r\n                parentProps[key] = props[key];\r\n            }\r\n        }\r\n        return parentProps;\r\n    }\r\n\r\n    /** @codegen-ignore */\r\n    const klass = Metadata.setFields<any>(class extends (inherits as any) {\r\n        constructor(...args: any[]) {\r\n            // call initialize method\r\n            if (methods.initialize && typeof methods.initialize === 'function') {\r\n                super(Object.assign({}, getDefaultValues(), getParentProps(args[0] || {})));\r\n                /**\r\n                 * only call initialize() in the current class, not the parent ones.\r\n                 * see \"should not call initialize automatically when creating an instance of inherited Schema\"\r\n                 */\r\n                if (new.target === klass) {\r\n                    methods.initialize.apply(this, args);\r\n                }\r\n\r\n            } else {\r\n                super(Object.assign({}, getDefaultValues(), args[0] || {}));\r\n            }\r\n        }\r\n    }, fields) as SchemaWithExtendsConstructor<T, ExtractInitProps<T>, P>;\r\n\r\n    // Store the getDefaultValues function on the class for inheritance\r\n    (klass as any)._getDefaultValues = getDefaultValues;\r\n\r\n    // Add methods to the prototype\r\n    Object.assign(klass.prototype, methods);\r\n\r\n    for (let fieldName in viewTagFields) {\r\n        view(viewTagFields[fieldName])(klass.prototype, fieldName);\r\n    }\r\n\r\n    if (name) {\r\n        Object.defineProperty(klass, \"name\", { value: name });\r\n    }\r\n\r\n    klass.extends = <T2 extends Definition = Definition>(fields: T2, name?: string) =>\r\n        schema<T2>(fields, name, klass as any) as SchemaWithExtendsConstructor<T & T2, ExtractInitProps<T2>, P>;\r\n\r\n    return klass;\r\n}\r\n"]}