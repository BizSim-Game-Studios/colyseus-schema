{"version":3,"file":"TypeContext.js","sourceRoot":"","sources":["../../src/types/TypeContext.ts"],"names":[],"mappings":"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","sourcesContent":["import { Metadata } from \"../Metadata\";\r\nimport { Schema } from \"../Schema\";\r\nimport { $viewFieldIndexes } from \"./symbols\";\r\n\r\nexport class TypeContext {\r\n    types: { [id: number]: typeof Schema; } = {};\r\n    schemas = new Map<typeof Schema, number>();\r\n\r\n    hasFilters: boolean = false;\r\n    parentFiltered: {[typeIdAndParentIndex: string]: boolean} = {};\r\n\r\n    /**\r\n     * For inheritance support\r\n     * Keeps track of which classes extends which. (parent -> children)\r\n     */\r\n    static inheritedTypes = new Map<typeof Schema, Set<typeof Schema>>();\r\n    static cachedContexts = new Map<typeof Schema, TypeContext>();\r\n\r\n    static register(target: typeof Schema) {\r\n        const parent = Object.getPrototypeOf(target);\r\n        if (parent !== Schema) {\r\n            let inherits = TypeContext.inheritedTypes.get(parent);\r\n            if (!inherits) {\r\n                inherits = new Set<typeof Schema>();\r\n                TypeContext.inheritedTypes.set(parent, inherits);\r\n            }\r\n            inherits.add(target);\r\n        }\r\n    }\r\n\r\n    static cache (rootClass: typeof Schema) {\r\n        let context = TypeContext.cachedContexts.get(rootClass);\r\n        if (!context) {\r\n            context = new TypeContext(rootClass);\r\n            TypeContext.cachedContexts.set(rootClass, context);\r\n        }\r\n        return context;\r\n    }\r\n\r\n    constructor(rootClass?: typeof Schema) {\r\n        if (rootClass) {\r\n            this.discoverTypes(rootClass);\r\n        }\r\n    }\r\n\r\n    has(schema: typeof Schema) {\r\n        return this.schemas.has(schema);\r\n    }\r\n\r\n    get(typeid: number) {\r\n        return this.types[typeid];\r\n    }\r\n\r\n    add(schema: typeof Schema, typeid = this.schemas.size) {\r\n        // skip if already registered\r\n        if (this.schemas.has(schema)) {\r\n            return false;\r\n        }\r\n\r\n        this.types[typeid] = schema;\r\n\r\n        //\r\n        // Workaround to allow using an empty Schema (with no `@type()` fields)\r\n        //\r\n        if (schema[Symbol.metadata] === undefined) {\r\n            Metadata.initialize(schema);\r\n        }\r\n\r\n        this.schemas.set(schema, typeid);\r\n        return true;\r\n    }\r\n\r\n    getTypeId(klass: typeof Schema) {\r\n        return this.schemas.get(klass);\r\n    }\r\n\r\n    private discoverTypes(klass: typeof Schema, parentType?: typeof Schema, parentIndex?: number, parentHasViewTag?: boolean) {\r\n        if (parentHasViewTag) {\r\n            this.registerFilteredByParent(klass, parentType, parentIndex);\r\n        }\r\n\r\n        // skip if already registered\r\n        if (!this.add(klass)) { return; }\r\n\r\n        // add classes inherited from this base class\r\n        TypeContext.inheritedTypes.get(klass)?.forEach((child) => {\r\n            this.discoverTypes(child, parentType, parentIndex, parentHasViewTag);\r\n        });\r\n\r\n        // add parent classes\r\n        let parent: any = klass;\r\n        while (\r\n            (parent = Object.getPrototypeOf(parent)) &&\r\n            parent !== Schema && // stop at root (Schema)\r\n            parent !== Function.prototype // stop at root (non-Schema)\r\n        ) {\r\n            this.discoverTypes(parent);\r\n        }\r\n\r\n        const metadata: Metadata = (klass[Symbol.metadata] ??= {} as Metadata);\r\n\r\n        // if any schema/field has filters, mark \"context\" as having filters.\r\n        if (metadata[$viewFieldIndexes]) {\r\n            this.hasFilters = true;\r\n        }\r\n\r\n        for (const fieldIndex in metadata) {\r\n            const index = fieldIndex as any as number;\r\n\r\n            const fieldType = metadata[index].type;\r\n            const fieldHasViewTag = (metadata[index].tag !== undefined);\r\n\r\n            if (typeof (fieldType) === \"string\") {\r\n                continue;\r\n            }\r\n\r\n            if (typeof (fieldType) === \"function\") {\r\n                this.discoverTypes(fieldType as typeof Schema, klass, index, parentHasViewTag || fieldHasViewTag);\r\n\r\n            } else {\r\n                const type = Object.values(fieldType)[0];\r\n\r\n                // skip primitive types\r\n                if (typeof (type) === \"string\") {\r\n                    continue;\r\n                }\r\n\r\n                this.discoverTypes(type as typeof Schema, klass, index, parentHasViewTag || fieldHasViewTag);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Keep track of which classes have filters applied.\r\n     * Format: `${typeid}-${parentTypeid}-${parentIndex}`\r\n     */\r\n    private registerFilteredByParent(schema: typeof Schema, parentType?: typeof Schema, parentIndex?: number) {\r\n        const typeid = this.schemas.get(schema) ?? this.schemas.size;\r\n\r\n        let key = `${typeid}`;\r\n        if (parentType) { key += `-${this.schemas.get(parentType)}`; }\r\n\r\n        key += `-${parentIndex}`;\r\n        this.parentFiltered[key] = true;\r\n    }\r\n\r\n    debug() {\r\n        let parentFiltered = \"\";\r\n\r\n        for (const key in this.parentFiltered) {\r\n            const keys: number[] = key.split(\"-\").map(Number);\r\n            const fieldIndex = keys.pop();\r\n\r\n            parentFiltered += `\\n\\t\\t`;\r\n            parentFiltered += `${key}: ${keys.reverse().map((id, i) => {\r\n                const klass = this.types[id];\r\n                const metadata: Metadata = klass[Symbol.metadata];\r\n                let txt = klass.name;\r\n                if (i === 0) { txt += `[${metadata[fieldIndex].name}]`; }\r\n                return `${txt}`;\r\n            }).join(\" -> \")}`;\r\n        }\r\n\r\n        return `TypeContext ->\\n` +\r\n            `\\tSchema types: ${this.schemas.size}\\n` +\r\n            `\\thasFilters: ${this.hasFilters}\\n` +\r\n            `\\tparentFiltered:${parentFiltered}`;\r\n    }\r\n\r\n}\r\n"]}