{"version":3,"file":"HelperTypes.js","sourceRoot":"","sources":["../../src/types/HelperTypes.ts"],"names":[],"mappings":"","sourcesContent":["import type { Definition, DefinitionType, PrimitiveType, RawPrimitiveType } from \"../annotations\";\r\nimport type { Schema } from \"../Schema\";\r\nimport type { ArraySchema } from \"./custom/ArraySchema\";\r\nimport type { CollectionSchema } from \"./custom/CollectionSchema\";\r\nimport type { MapSchema } from \"./custom/MapSchema\";\r\nimport type { SetSchema } from \"./custom/SetSchema\";\r\n\r\nexport type Constructor<T = {}> = new (...args: any[]) => T;\r\n\r\nexport interface Collection<K = any, V = any, IT = V> {\r\n    [Symbol.iterator](): IterableIterator<IT>;\r\n    forEach(callback: Function): void;\r\n    entries(): IterableIterator<[K, V]>;\r\n}\r\n\r\nexport type InferValueType<T extends DefinitionType> =\r\n    T extends \"string\" ? string\r\n    : T extends \"number\" ? number\r\n    : T extends \"int8\" ? number\r\n    : T extends \"uint8\" ? number\r\n    : T extends \"int16\" ? number\r\n    : T extends \"uint16\" ? number\r\n    : T extends \"int32\" ? number\r\n    : T extends \"uint32\" ? number\r\n    : T extends \"int64\" ? number\r\n    : T extends \"uint64\" ? number\r\n    : T extends \"float32\" ? number\r\n    : T extends \"float64\" ? number\r\n    : T extends \"boolean\" ? boolean\r\n\r\n    // Handle { type: ... } patterns\r\n    : T extends { type: infer ChildType extends PrimitiveType } ? InferValueType<ChildType>\r\n    : T extends { type: infer ChildType extends Constructor } ? InstanceType<ChildType>\r\n    : T extends { type: Array<infer ChildType> } ? (ChildType extends Record<string | number, string | number> ? ChildType[keyof ChildType][] : ChildType[]) // TS ENUM\r\n    : T extends { type: { map: infer ChildType } } ? (ChildType extends Record<string | number, string | number> ? MapSchema<ChildType[keyof ChildType]> : MapSchema<ChildType>) // TS ENUM\r\n    : T extends { type: { set: infer ChildType } } ? (ChildType extends Record<string | number, string | number> ? SetSchema<ChildType[keyof ChildType]> : SetSchema<ChildType>) // TS ENUM\r\n    : T extends { type: { collection: infer ChildType } } ? (ChildType extends Record<string | number, string | number> ? CollectionSchema<ChildType[keyof ChildType]> : CollectionSchema<ChildType>) // TS ENUM\r\n    : T extends { type: infer ChildType } ? (ChildType extends Record<string | number, string | number> ? ChildType[keyof ChildType] : ChildType) // TS ENUM\r\n\r\n    // Handle direct array patterns\r\n    : T extends Array<infer ChildType extends Constructor> ? InstanceType<ChildType>[]\r\n    : T extends Array<infer ChildType extends RawPrimitiveType> ? InferValueType<ChildType>[] // primitive types\r\n    : T extends Array<infer ChildType> ? (ChildType extends Record<string | number, string | number> ? ChildType[keyof ChildType][] : ChildType[]) // TS ENUM\r\n\r\n    // Handle collection object patterns\r\n    : T extends { array: infer ChildType extends Constructor } ? InstanceType<ChildType>[]\r\n    : T extends { array: infer ChildType extends RawPrimitiveType } ? InferValueType<ChildType>[] // primitive types\r\n    : T extends { array: infer ChildType } ? (ChildType extends Record<string | number, string | number> ? ChildType[keyof ChildType][] : ChildType[]) // TS ENUM\r\n\r\n    : T extends { map: infer ChildType extends Constructor } ? MapSchema<InstanceType<ChildType>>\r\n    : T extends { map: infer ChildType extends RawPrimitiveType } ? MapSchema<InferValueType<ChildType>> // primitive types\r\n    : T extends { map: infer ChildType } ? (ChildType extends Record<string | number, string | number> ? MapSchema<ChildType[keyof ChildType]> : MapSchema<ChildType>) // TS ENUM\r\n\r\n    : T extends { set: infer ChildType extends Constructor } ? SetSchema<InstanceType<ChildType>>\r\n    : T extends { set: infer ChildType extends RawPrimitiveType } ? SetSchema<InferValueType<ChildType>> // primitive types\r\n    : T extends { set: infer ChildType } ? (ChildType extends Record<string | number, string | number> ? SetSchema<ChildType[keyof ChildType]> : SetSchema<ChildType>) // TS ENUM\r\n\r\n    : T extends { collection: infer ChildType extends Constructor } ? CollectionSchema<InstanceType<ChildType>>\r\n    : T extends { collection: infer ChildType extends RawPrimitiveType } ? CollectionSchema<InferValueType<ChildType>> // primitive types\r\n    : T extends { collection: infer ChildType } ? (ChildType extends Record<string | number, string | number> ? CollectionSchema<ChildType[keyof ChildType]> : CollectionSchema<ChildType>) // TS ENUM\r\n\r\n    // Handle direct types\r\n    : T extends Constructor ? InstanceType<T>\r\n    : T extends Record<string | number, string | number> ? T[keyof T] // TS ENUM\r\n    : T extends PrimitiveType ? T\r\n\r\n    : never;\r\n\r\nexport type InferSchemaInstanceType<T extends Definition> = {\r\n    [K in keyof T]: T[K] extends (...args: any[]) => any\r\n        ? (T[K] extends new (...args: any[]) => any ? InferValueType<T[K]> : T[K])\r\n        : InferValueType<T[K]>\r\n} & Schema;\r\n\r\nexport type NonFunctionProps<T> = Omit<T, {\r\n    [K in keyof T]: T[K] extends Function ? K : never;\r\n}[keyof T]>;\r\n\r\nexport type NonFunctionPropNames<T> = {\r\n    [K in keyof T]: T[K] extends Function ? never : K\r\n}[keyof T];\r\n\r\nexport type NonFunctionNonPrimitivePropNames<T> = {\r\n    [K in keyof T]: T[K] extends Function\r\n        ? never\r\n        : T[K] extends number | string | boolean\r\n            ? never\r\n            : K\r\n}[keyof T];\r\n\r\n// Helper to recursively convert Schema instances to their JSON representation\r\ntype ToJSONValue<U> = U extends Schema ? ToJSON<U> : U;\r\n\r\nexport type ToJSON<T> = NonFunctionProps<{\r\n    [K in keyof T]:\r\n        T[K] extends MapSchema<infer U> ? Record<string, ToJSONValue<U>>\r\n        : T[K] extends Map<string, infer U> ? Record<string, ToJSONValue<U>>\r\n        : T[K] extends ArraySchema<infer U> ? ToJSONValue<U>[]\r\n        : T[K] extends SetSchema<infer U> ? ToJSONValue<U>[]\r\n        : T[K] extends CollectionSchema<infer U> ? ToJSONValue<U>[]\r\n        : T[K] extends Schema ? ToJSON<T[K]>\r\n        : T[K]\r\n}>;\r\n\r\n// Helper type to check if T is exactly 'never' (meaning no InitProps was provided)\r\nexport type IsNever<T> = [T] extends [never] ? true : false;\r\n\r\n/**\r\n * Type helper for .assign() method - allows assigning values in a flexible way\r\n * - Primitives can be assigned directly\r\n * - Schema instances can be assigned from plain objects or Schema instances\r\n * - Collections can be assigned from their JSON representations\r\n */\r\nexport type AssignableProps<T> = {\r\n    [K in NonFunctionPropNames<T>]?: T[K] extends MapSchema<infer U>\r\n        ? MapSchema<U> | Record<string, U extends Schema ? (U | AssignableProps<U>) : U>\r\n        : T[K] extends ArraySchema<infer U>\r\n            ? ArraySchema<U> | (U extends Schema ? (U | AssignableProps<U>)[] : U[])\r\n            : T[K] extends SetSchema<infer U>\r\n                ? SetSchema<U> | Set<U> | (U extends Schema ? (U | AssignableProps<U>)[] : U[])\r\n                : T[K] extends CollectionSchema<infer U>\r\n                    ? CollectionSchema<U> | (U extends Schema ? (U | AssignableProps<U>)[] : U[])\r\n                    : T[K] extends Schema\r\n                        ? T[K] | AssignableProps<T[K]>\r\n                        : T[K]\r\n};"]}