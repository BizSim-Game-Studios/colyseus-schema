{"version":3,"file":"ChangeTree.js","sourceRoot":"","sources":["../../src/encoder/ChangeTree.ts"],"names":[],"mappings":"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","sourcesContent":["import { OPERATION } from \"../encoding/spec\";\r\nimport { Schema } from \"../Schema\";\r\nimport { $changes, $childType, $decoder, $onEncodeEnd, $encoder, $getByIndex, $refTypeFieldIndexes, $viewFieldIndexes, type $deleteByIndex } from \"../types/symbols\";\r\n\r\nimport type { MapSchema } from \"../types/custom/MapSchema\";\r\nimport type { ArraySchema } from \"../types/custom/ArraySchema\";\r\nimport type { CollectionSchema } from \"../types/custom/CollectionSchema\";\r\nimport type { SetSchema } from \"../types/custom/SetSchema\";\r\n\r\nimport { Root } from \"./Root\";\r\nimport { Metadata } from \"../Metadata\";\r\nimport type { EncodeOperation } from \"./EncodeOperation\";\r\nimport type { DecodeOperation } from \"../decoder/DecodeOperation\";\r\n\r\ndeclare global {\r\n    interface Object {\r\n        // FIXME: not a good practice to extend globals here\r\n        [$changes]?: ChangeTree;\r\n        [$encoder]?: EncodeOperation,\r\n        [$decoder]?: DecodeOperation,\r\n    }\r\n}\r\n\r\nexport interface IRef {\r\n    [$changes]?: ChangeTree;\r\n    [$getByIndex]?: (index: number, isEncodeAll?: boolean) => any;\r\n    [$deleteByIndex]?: (index: number) => void;\r\n}\r\n\r\nexport type Ref = Schema\r\n    | ArraySchema\r\n    | MapSchema\r\n    | CollectionSchema\r\n    | SetSchema;\r\n\r\nexport type ChangeSetName = \"changes\"\r\n    | \"allChanges\"\r\n    | \"filteredChanges\"\r\n    | \"allFilteredChanges\";\r\n\r\nexport interface IndexedOperations {\r\n    [index: number]: OPERATION;\r\n}\r\n\r\n// Linked list node for change trees\r\nexport interface ChangeTreeNode {\r\n    changeTree: ChangeTree;\r\n    next?: ChangeTreeNode;\r\n    prev?: ChangeTreeNode;\r\n    position: number; // Cached position in the linked list for O(1) lookup\r\n}\r\n\r\n// Linked list for change trees\r\nexport interface ChangeTreeList {\r\n    next?: ChangeTreeNode;\r\n    tail?: ChangeTreeNode;\r\n}\r\n\r\nexport interface ChangeSet {\r\n    // field index -> operation index\r\n    indexes: { [index: number]: number };\r\n    operations: number[];\r\n    queueRootNode?: ChangeTreeNode; // direct reference to ChangeTreeNode in the linked list\r\n}\r\n\r\nfunction createChangeSet(queueRootNode?: ChangeTreeNode): ChangeSet {\r\n    return { indexes: {}, operations: [], queueRootNode };\r\n}\r\n\r\n// Linked list helper functions\r\nexport function createChangeTreeList(): ChangeTreeList {\r\n    return { next: undefined, tail: undefined };\r\n}\r\n\r\nexport function setOperationAtIndex(changeSet: ChangeSet, index: number) {\r\n    const operationsIndex = changeSet.indexes[index];\r\n    if (operationsIndex === undefined) {\r\n        changeSet.indexes[index] = changeSet.operations.push(index) - 1;\r\n    } else {\r\n        changeSet.operations[operationsIndex] = index;\r\n    }\r\n}\r\n\r\nexport function deleteOperationAtIndex(changeSet: ChangeSet, index: number | string) {\r\n    let operationsIndex = changeSet.indexes[index as any as number];\r\n    if (operationsIndex === undefined) {\r\n        //\r\n        // if index is not found, we need to find the last operation\r\n        // FIXME: this is not very efficient\r\n        //\r\n        // > See \"should allow consecutive splices (same place)\" tests\r\n        //\r\n        operationsIndex = Object.values(changeSet.indexes).at(-1);\r\n        index = Object.entries(changeSet.indexes).find(([_, value]) => value === operationsIndex)?.[0];\r\n    }\r\n    changeSet.operations[operationsIndex] = undefined;\r\n    delete changeSet.indexes[index as any as number];\r\n}\r\n\r\nexport function debugChangeSet(label: string, changeSet: ChangeSet) {\r\n    let indexes: string[] = [];\r\n    let operations: string[] = [];\r\n\r\n    for (const index in changeSet.indexes) {\r\n        indexes.push(`\\t${index} => [${changeSet.indexes[index]}]`);\r\n    }\r\n\r\n    for (let i = 0; i < changeSet.operations.length; i++) {\r\n        const index = changeSet.operations[i];\r\n        if (index !== undefined) {\r\n            operations.push(`\\t[${i}] => ${index}`);\r\n        }\r\n    }\r\n\r\n    console.log(`${label} =>\\nindexes (${Object.keys(changeSet.indexes).length}) {`);\r\n    console.log(indexes.join(\"\\n\"), \"\\n}\");\r\n    console.log(`operations (${changeSet.operations.filter(op => op !== undefined).length}) {`);\r\n    console.log(operations.join(\"\\n\"), \"\\n}\");\r\n}\r\n\r\nexport interface ParentChain {\r\n    ref: Ref;\r\n    index: number;\r\n    next?: ParentChain;\r\n}\r\n\r\nexport class ChangeTree<T extends Ref = any> {\r\n    ref: T;\r\n    refId: number;\r\n    metadata: Metadata;\r\n\r\n    root?: Root;\r\n    parentChain?: ParentChain; // Linked list for tracking parents\r\n\r\n    /**\r\n     * Whether this structure is parent of a filtered structure.\r\n     */\r\n    isFiltered: boolean = false;\r\n    isVisibilitySharedWithParent?: boolean; // See test case: 'should not be required to manually call view.add() items to child arrays without @view() tag'\r\n\r\n    indexedOperations: IndexedOperations = {};\r\n\r\n    //\r\n    // TODO:\r\n    //   try storing the index + operation per item.\r\n    //   example: 1024 & 1025 => ADD, 1026 => DELETE\r\n    //\r\n    // => https://chatgpt.com/share/67107d0c-bc20-8004-8583-83b17dd7c196\r\n    //\r\n    changes: ChangeSet = { indexes: {}, operations: [] };\r\n    allChanges: ChangeSet = { indexes: {}, operations: [] };\r\n    filteredChanges: ChangeSet;\r\n    allFilteredChanges: ChangeSet;\r\n\r\n    indexes: { [index: string]: any }; // TODO: remove this, only used by MapSchema/SetSchema/CollectionSchema (`encodeKeyValueOperation`)\r\n\r\n    /**\r\n     * Is this a new instance? Used on ArraySchema to determine OPERATION.MOVE_AND_ADD operation.\r\n     */\r\n    isNew = true;\r\n\r\n    constructor(ref: T) {\r\n        this.ref = ref;\r\n        this.metadata = (ref.constructor as typeof Schema)[Symbol.metadata];\r\n\r\n        //\r\n        // Does this structure have \"filters\" declared?\r\n        //\r\n        if (this.metadata?.[$viewFieldIndexes]) {\r\n            this.allFilteredChanges = { indexes: {}, operations: [] };\r\n            this.filteredChanges = { indexes: {}, operations: [] };\r\n        }\r\n    }\r\n\r\n    setRoot(root: Root) {\r\n        this.root = root;\r\n\r\n        const isNewChangeTree = this.root.add(this);\r\n\r\n        this.checkIsFiltered(this.parent, this.parentIndex, isNewChangeTree);\r\n\r\n        // Recursively set root on child structures\r\n        if (isNewChangeTree) {\r\n            this.forEachChild((child, _) => {\r\n                if (child.root !== root) {\r\n                    child.setRoot(root);\r\n                } else {\r\n                    root.add(child); // increment refCount\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    setParent(\r\n        parent: Ref,\r\n        root?: Root,\r\n        parentIndex?: number,\r\n    ) {\r\n        this.addParent(parent, parentIndex);\r\n\r\n        // avoid setting parents with empty `root`\r\n        if (!root) { return; }\r\n\r\n        const isNewChangeTree = root.add(this);\r\n\r\n        // skip if parent is already set\r\n        if (root !== this.root) {\r\n            this.root = root;\r\n            this.checkIsFiltered(parent, parentIndex, isNewChangeTree);\r\n        }\r\n\r\n        // assign same parent on child structures\r\n        if (isNewChangeTree) {\r\n            //\r\n            // assign same parent on child structures\r\n            //\r\n            this.forEachChild((child, index) => {\r\n                if (child.root === root) {\r\n                    //\r\n                    // re-assigning a child of the same root, move it next to parent\r\n                    // so encoding order is preserved\r\n                    //\r\n                    root.add(child);\r\n                    root.moveNextToParent(child);\r\n                    return;\r\n                }\r\n                child.setParent(this.ref, root, index);\r\n            });\r\n        }\r\n    }\r\n\r\n    forEachChild(callback: (change: ChangeTree, at: any) => void) {\r\n        //\r\n        // assign same parent on child structures\r\n        //\r\n        if ((this.ref as any)[$childType]) {\r\n            if (typeof ((this.ref as any)[$childType]) !== \"string\") {\r\n                // MapSchema / ArraySchema, etc.\r\n                for (const [key, value] of (this.ref as MapSchema).entries()) {\r\n                    if (!value) { continue; } // sparse arrays can have undefined values\r\n                    callback(value[$changes], this.indexes?.[key] ?? key);\r\n                };\r\n            }\r\n\r\n        } else {\r\n            for (const index of this.metadata?.[$refTypeFieldIndexes] ?? []) {\r\n                const field = this.metadata[index as any as number];\r\n                const value = this.ref[field.name as keyof Ref];\r\n                if (!value) { continue; }\r\n                callback(value[$changes], index);\r\n            }\r\n        }\r\n    }\r\n\r\n    operation(op: OPERATION) {\r\n        // operations without index use negative values to represent them\r\n        // this is checked during .encode() time.\r\n        if (this.filteredChanges !== undefined) {\r\n            this.filteredChanges.operations.push(-op);\r\n            this.root?.enqueueChangeTree(this, 'filteredChanges');\r\n\r\n        } else {\r\n            this.changes.operations.push(-op);\r\n            this.root?.enqueueChangeTree(this, 'changes');\r\n        }\r\n    }\r\n\r\n    change(index: number, operation: OPERATION = OPERATION.ADD) {\r\n        const isFiltered = this.isFiltered || (this.metadata?.[index]?.tag !== undefined);\r\n        const changeSet = (isFiltered)\r\n            ? this.filteredChanges\r\n            : this.changes;\r\n\r\n        const previousOperation = this.indexedOperations[index];\r\n        if (!previousOperation || previousOperation === OPERATION.DELETE) {\r\n            const op = (!previousOperation)\r\n                ? operation\r\n                : (previousOperation === OPERATION.DELETE)\r\n                    ? OPERATION.DELETE_AND_ADD\r\n                    : operation\r\n            //\r\n            // TODO: are DELETE operations being encoded as ADD here ??\r\n            //\r\n            this.indexedOperations[index] = op;\r\n        }\r\n\r\n        setOperationAtIndex(changeSet, index);\r\n\r\n        if (isFiltered) {\r\n            setOperationAtIndex(this.allFilteredChanges, index);\r\n\r\n            if (this.root) {\r\n                this.root.enqueueChangeTree(this, 'filteredChanges');\r\n                this.root.enqueueChangeTree(this, 'allFilteredChanges');\r\n            }\r\n\r\n        } else {\r\n            setOperationAtIndex(this.allChanges, index);\r\n            this.root?.enqueueChangeTree(this, 'changes');\r\n        }\r\n    }\r\n\r\n    shiftChangeIndexes(shiftIndex: number) {\r\n        //\r\n        // Used only during:\r\n        //\r\n        // - ArraySchema#unshift()\r\n        //\r\n        const changeSet = (this.isFiltered)\r\n            ? this.filteredChanges\r\n            : this.changes;\r\n\r\n        const newIndexedOperations: any = {};\r\n        const newIndexes: { [index: number]: number } = {};\r\n        for (const index in this.indexedOperations) {\r\n            newIndexedOperations[Number(index) + shiftIndex] = this.indexedOperations[index];\r\n            newIndexes[Number(index) + shiftIndex] = changeSet.indexes[index];\r\n        }\r\n        this.indexedOperations = newIndexedOperations;\r\n        changeSet.indexes = newIndexes;\r\n\r\n        changeSet.operations = changeSet.operations.map((index) => index + shiftIndex);\r\n    }\r\n\r\n    shiftAllChangeIndexes(shiftIndex: number, startIndex: number = 0) {\r\n        //\r\n        // Used only during:\r\n        //\r\n        // - ArraySchema#splice()\r\n        //\r\n        if (this.filteredChanges !== undefined) {\r\n            this._shiftAllChangeIndexes(shiftIndex, startIndex, this.allFilteredChanges);\r\n            this._shiftAllChangeIndexes(shiftIndex, startIndex, this.allChanges);\r\n\r\n        } else {\r\n            this._shiftAllChangeIndexes(shiftIndex, startIndex, this.allChanges);\r\n        }\r\n    }\r\n\r\n    private _shiftAllChangeIndexes(shiftIndex: number, startIndex: number = 0, changeSet: ChangeSet) {\r\n        const newIndexes: { [index: number]: number } = {};\r\n        let newKey = 0;\r\n        for (const key in changeSet.indexes) {\r\n            newIndexes[newKey++] = changeSet.indexes[key];\r\n        }\r\n        changeSet.indexes = newIndexes;\r\n\r\n        for (let i = 0; i < changeSet.operations.length; i++) {\r\n            const index = changeSet.operations[i];\r\n            if (index > startIndex) {\r\n                changeSet.operations[i] = index + shiftIndex;\r\n            }\r\n        }\r\n    }\r\n\r\n    indexedOperation(index: number, operation: OPERATION, allChangesIndex: number = index) {\r\n        this.indexedOperations[index] = operation;\r\n\r\n        if (this.filteredChanges !== undefined) {\r\n            setOperationAtIndex(this.allFilteredChanges, allChangesIndex);\r\n            setOperationAtIndex(this.filteredChanges, index);\r\n            this.root?.enqueueChangeTree(this, 'filteredChanges');\r\n\r\n        } else {\r\n            setOperationAtIndex(this.allChanges, allChangesIndex);\r\n            setOperationAtIndex(this.changes, index);\r\n            this.root?.enqueueChangeTree(this, 'changes');\r\n        }\r\n    }\r\n\r\n    getType(index?: number) {\r\n        return (\r\n            //\r\n            // Get the child type from parent structure.\r\n            // - [\"string\"] => \"string\"\r\n            // - { map: \"string\" } => \"string\"\r\n            // - { set: \"string\" } => \"string\"\r\n            //\r\n            (this.ref as any)[$childType] || // ArraySchema | MapSchema | SetSchema | CollectionSchema\r\n            this.metadata[index].type // Schema\r\n        );\r\n    }\r\n\r\n    getChange(index: number) {\r\n        return this.indexedOperations[index];\r\n    }\r\n\r\n    //\r\n    // used during `.encode()`\r\n    //\r\n    getValue(index: number, isEncodeAll: boolean = false) {\r\n        //\r\n        // `isEncodeAll` param is only used by ArraySchema\r\n        //\r\n        return (this.ref as any)[$getByIndex](index, isEncodeAll);\r\n    }\r\n\r\n    delete(index: number, operation?: OPERATION, allChangesIndex = index) {\r\n        if (index === undefined) {\r\n            try {\r\n                throw new Error(`@colyseus/schema ${this.ref.constructor.name}: trying to delete non-existing index '${index}'`);\r\n            } catch (e) {\r\n                console.warn(e);\r\n            }\r\n            return;\r\n        }\r\n\r\n        const changeSet = (this.filteredChanges !== undefined)\r\n            ? this.filteredChanges\r\n            : this.changes;\r\n\r\n        this.indexedOperations[index] = operation ?? OPERATION.DELETE;\r\n        setOperationAtIndex(changeSet, index);\r\n        deleteOperationAtIndex(this.allChanges, allChangesIndex);\r\n\r\n        const previousValue = this.getValue(index);\r\n\r\n        // remove `root` reference\r\n        if (previousValue && previousValue[$changes]) {\r\n            //\r\n            // FIXME: this.root is \"undefined\"\r\n            //\r\n            // This method is being called at decoding time when a DELETE operation is found.\r\n            //\r\n            // - This is due to using the concrete Schema class at decoding time.\r\n            // - \"Reflected\" structures do not have this problem.\r\n            //\r\n            // (The property descriptors should NOT be used at decoding time. only at encoding time.)\r\n            //\r\n            this.root?.remove(previousValue[$changes]);\r\n        }\r\n\r\n        //\r\n        // FIXME: this is looking a ugly and repeated\r\n        //\r\n        if (this.filteredChanges !== undefined) {\r\n            deleteOperationAtIndex(this.allFilteredChanges, allChangesIndex);\r\n            this.root?.enqueueChangeTree(this, 'filteredChanges');\r\n\r\n        } else {\r\n            this.root?.enqueueChangeTree(this, 'changes');\r\n        }\r\n\r\n        return previousValue;\r\n    }\r\n\r\n    endEncode(changeSetName: ChangeSetName) {\r\n        this.indexedOperations = {};\r\n\r\n        // clear changeset\r\n        this[changeSetName] = createChangeSet();\r\n\r\n        // ArraySchema and MapSchema have a custom \"encode end\" method\r\n        (this.ref as any)[$onEncodeEnd]?.();\r\n\r\n        // Not a new instance anymore\r\n        this.isNew = false;\r\n    }\r\n\r\n    discard(discardAll: boolean = false) {\r\n        //\r\n        // > MapSchema:\r\n        //      Remove cached key to ensure ADD operations is unsed instead of\r\n        //      REPLACE in case same key is used on next patches.\r\n        //\r\n        (this.ref as any)[$onEncodeEnd]?.();\r\n\r\n        this.indexedOperations = {};\r\n        this.changes = createChangeSet(this.changes.queueRootNode);\r\n\r\n        if (this.filteredChanges !== undefined) {\r\n            this.filteredChanges = createChangeSet(this.filteredChanges.queueRootNode);\r\n        }\r\n\r\n        if (discardAll) {\r\n            // preserve queueRootNode references\r\n            this.allChanges = createChangeSet(this.allChanges.queueRootNode);\r\n\r\n            if (this.allFilteredChanges !== undefined) {\r\n                this.allFilteredChanges = createChangeSet(this.allFilteredChanges.queueRootNode);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Recursively discard all changes from this, and child structures.\r\n     * (Used in tests only)\r\n     */\r\n    discardAll() {\r\n        const keys = Object.keys(this.indexedOperations);\r\n        for (let i = 0, len = keys.length; i < len; i++) {\r\n            const value = this.getValue(Number(keys[i]));\r\n\r\n            if (value && value[$changes]) {\r\n                value[$changes].discardAll();\r\n            }\r\n        }\r\n\r\n        this.discard();\r\n    }\r\n\r\n    get changed() {\r\n        return (Object.entries(this.indexedOperations).length > 0);\r\n    }\r\n\r\n    protected checkIsFiltered(parent: Ref, parentIndex: number, isNewChangeTree: boolean) {\r\n        if (this.root.types.hasFilters) {\r\n            //\r\n            // At Schema initialization, the \"root\" structure might not be available\r\n            // yet, as it only does once the \"Encoder\" has been set up.\r\n            //\r\n            // So the \"parent\" may be already set without a \"root\".\r\n            //\r\n            this._checkFilteredByParent(parent, parentIndex);\r\n\r\n            if (this.filteredChanges !== undefined) {\r\n                this.root?.enqueueChangeTree(this, 'filteredChanges');\r\n\r\n                if (isNewChangeTree) {\r\n                    this.root?.enqueueChangeTree(this, 'allFilteredChanges');\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!this.isFiltered) {\r\n            this.root?.enqueueChangeTree(this, 'changes');\r\n\r\n            if (isNewChangeTree) {\r\n                this.root?.enqueueChangeTree(this, 'allChanges');\r\n            }\r\n        }\r\n    }\r\n\r\n    protected _checkFilteredByParent(parent: Ref, parentIndex: number) {\r\n        // skip if parent is not set\r\n        if (!parent) { return; }\r\n\r\n        //\r\n        // ArraySchema | MapSchema - get the child type\r\n        // (if refType is typeof string, the parentFiltered[key] below will always be invalid)\r\n        //\r\n        const refType = Metadata.isValidInstance(this.ref)\r\n            ? this.ref.constructor\r\n            : (this.ref as any)[$childType];\r\n\r\n        let parentChangeTree: ChangeTree;\r\n\r\n        let parentIsCollection = !Metadata.isValidInstance(parent);\r\n        if (parentIsCollection) {\r\n            parentChangeTree = parent[$changes];\r\n            parent = parentChangeTree.parent;\r\n            parentIndex = parentChangeTree.parentIndex;\r\n\r\n        } else {\r\n            parentChangeTree = parent[$changes]\r\n        }\r\n\r\n        const parentConstructor = parent.constructor as typeof Schema;\r\n\r\n        let key = `${this.root.types.getTypeId(refType as typeof Schema)}`;\r\n        if (parentConstructor) {\r\n            key += `-${this.root.types.schemas.get(parentConstructor)}`;\r\n        }\r\n        key += `-${parentIndex}`;\r\n\r\n        const fieldHasViewTag = Metadata.hasViewTagAtIndex(parentConstructor?.[Symbol.metadata], parentIndex);\r\n\r\n        this.isFiltered = parent[$changes].isFiltered // in case parent is already filtered\r\n            || this.root.types.parentFiltered[key]\r\n            || fieldHasViewTag;\r\n\r\n        //\r\n        // \"isFiltered\" may not be imedialely available during `change()` due to the instance not being attached to the root yet.\r\n        // when it's available, we need to enqueue the \"changes\" changeset into the \"filteredChanges\" changeset.\r\n        //\r\n        if (this.isFiltered) {\r\n\r\n            this.isVisibilitySharedWithParent = (\r\n                parentChangeTree.isFiltered &&\r\n                typeof (refType) !== \"string\" &&\r\n                !fieldHasViewTag &&\r\n                parentIsCollection\r\n            );\r\n\r\n            if (!this.filteredChanges) {\r\n                this.filteredChanges = createChangeSet();\r\n                this.allFilteredChanges = createChangeSet();\r\n            }\r\n\r\n            if (this.changes.operations.length > 0) {\r\n                this.changes.operations.forEach((index) =>\r\n                    setOperationAtIndex(this.filteredChanges, index));\r\n\r\n                this.allChanges.operations.forEach((index) =>\r\n                    setOperationAtIndex(this.allFilteredChanges, index));\r\n\r\n                this.changes = createChangeSet();\r\n                this.allChanges = createChangeSet();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the immediate parent\r\n     */\r\n    get parent(): Ref | undefined {\r\n        return this.parentChain?.ref;\r\n    }\r\n\r\n    /**\r\n     * Get the immediate parent index\r\n     */\r\n    get parentIndex(): number | undefined {\r\n        return this.parentChain?.index;\r\n    }\r\n\r\n    /**\r\n     * Add a parent to the chain\r\n     */\r\n    addParent(parent: Ref, index: number) {\r\n        // Check if this parent already exists in the chain\r\n        if (this.hasParent((p, _) => p[$changes] === parent[$changes])) {\r\n        // if (this.hasParent((p, i) => p[$changes] === parent[$changes] && i === index)) {\r\n            this.parentChain.index = index;\r\n            return;\r\n        }\r\n\r\n        this.parentChain = {\r\n            ref: parent,\r\n            index,\r\n            next: this.parentChain\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Remove a parent from the chain\r\n     * @param parent - The parent to remove\r\n     * @returns true if parent was removed\r\n     */\r\n    removeParent(parent: Ref = this.parent): boolean {\r\n        let current = this.parentChain;\r\n        let previous = null;\r\n        while (current) {\r\n            //\r\n            // FIXME: it is required to check against `$changes` here because\r\n            // ArraySchema is instance of Proxy\r\n            //\r\n            if (current.ref[$changes] === parent[$changes]) {\r\n                if (previous) {\r\n                    previous.next = current.next;\r\n                } else {\r\n                    this.parentChain = current.next;\r\n                }\r\n                return true;\r\n            }\r\n            previous = current;\r\n            current = current.next;\r\n        }\r\n        return this.parentChain === undefined;\r\n    }\r\n\r\n    /**\r\n     * Find a specific parent in the chain\r\n     */\r\n    findParent(predicate: (parent: Ref, index: number) => boolean): ParentChain | undefined {\r\n        let current = this.parentChain;\r\n        while (current) {\r\n            if (predicate(current.ref, current.index)) {\r\n                return current;\r\n            }\r\n            current = current.next;\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    /**\r\n     * Check if this ChangeTree has a specific parent\r\n     */\r\n    hasParent(predicate: (parent: Ref, index: number) => boolean): boolean {\r\n        return this.findParent(predicate) !== undefined;\r\n    }\r\n\r\n    /**\r\n     * Get all parents as an array (for debugging/testing)\r\n     */\r\n    getAllParents(): Array<{ ref: Ref, index: number }> {\r\n        const parents: Array<{ ref: Ref, index: number }> = [];\r\n        let current = this.parentChain;\r\n        while (current) {\r\n            parents.push({ ref: current.ref, index: current.index });\r\n            current = current.next;\r\n        }\r\n        return parents;\r\n    }\r\n\r\n}\r\n"]}