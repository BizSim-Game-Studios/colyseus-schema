{"version":3,"file":"Encoder.js","sourceRoot":"","sources":["../../src/encoder/Encoder.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Schema } from \"../Schema\";\r\nimport { TypeContext } from \"../types/TypeContext\";\r\nimport { $changes, $encoder, $filter, $getByIndex } from \"../types/symbols\";\r\n\r\nimport { encode } from \"../encoding/encode\";\r\nimport type { Iterator } from \"../encoding/decode\";\r\n\r\nimport { OPERATION, SWITCH_TO_STRUCTURE, TYPE_ID } from '../encoding/spec';\r\nimport { Root } from \"./Root\";\r\n\r\nimport type { StateView } from \"./StateView\";\r\nimport type { Metadata } from \"../Metadata\";\r\nimport type { ChangeSetName, ChangeTree, ChangeTreeList, ChangeTreeNode } from \"./ChangeTree\";\r\nimport { createChangeTreeList } from \"./ChangeTree\";\r\n\r\nexport class Encoder<T extends Schema = any> {\r\n    static BUFFER_SIZE = (typeof(Buffer) !== \"undefined\") && Buffer.poolSize || 8 * 1024; // 8KB\r\n    sharedBuffer = Buffer.allocUnsafe(Encoder.BUFFER_SIZE);\r\n\r\n    context: TypeContext;\r\n    state: T;\r\n\r\n    root: Root;\r\n\r\n    constructor(state: T) {\r\n        //\r\n        // Use .cache() here to avoid re-creating a new context for every new room instance.\r\n        //\r\n        // We may need to make this optional in case of dynamically created\r\n        // schemas - which would lead to memory leaks\r\n        //\r\n        this.context = TypeContext.cache(state.constructor as typeof Schema);\r\n        this.root = new Root(this.context);\r\n\r\n        this.setState(state);\r\n\r\n        // console.log(\">>>>>>>>>>>>>>>> Encoder types\");\r\n        // this.context.schemas.forEach((id, schema) => {\r\n        //     console.log(\"type:\", id, schema.name, Object.keys(schema[Symbol.metadata]));\r\n        // });\r\n    }\r\n\r\n    protected setState(state: T) {\r\n        this.state = state;\r\n        this.state[$changes].setRoot(this.root);\r\n    }\r\n\r\n    encode(\r\n        it: Iterator = { offset: 0 },\r\n        view?: StateView,\r\n        buffer = this.sharedBuffer,\r\n        changeSetName: ChangeSetName = \"changes\",\r\n        isEncodeAll = changeSetName === \"allChanges\",\r\n        initialOffset = it.offset // cache current offset in case we need to resize the buffer\r\n    ): Buffer {\r\n        const hasView = (view !== undefined);\r\n        const rootChangeTree = this.state[$changes];\r\n\r\n        let current: ChangeTreeList | ChangeTreeNode = this.root[changeSetName];\r\n\r\n        while (current = current.next) {\r\n            const changeTree = (current as ChangeTreeNode).changeTree;\r\n\r\n            if (hasView) {\r\n                if (!view.isChangeTreeVisible(changeTree)) {\r\n                    // console.log(\"MARK AS INVISIBLE:\", { ref: changeTree.ref.constructor.name, refId: changeTree.refId, raw: changeTree.ref.toJSON() });\r\n                    view.invisible.add(changeTree);\r\n                    continue; // skip this change tree\r\n                }\r\n                view.invisible.delete(changeTree); // remove from invisible list\r\n            }\r\n\r\n            const changeSet = changeTree[changeSetName];\r\n            const ref = changeTree.ref;\r\n\r\n            // TODO: avoid iterating over change tree if no changes were made\r\n            const numChanges = changeSet.operations.length;\r\n            if (numChanges === 0) { continue; }\r\n\r\n            const ctor = ref.constructor;\r\n            const encoder = ctor[$encoder];\r\n            const filter = ctor[$filter];\r\n            const metadata = ctor[Symbol.metadata];\r\n\r\n            // skip root `refId` if it's the first change tree\r\n            // (unless it \"hasView\", which will need to revisit the root)\r\n            if (hasView || it.offset > initialOffset || changeTree !== rootChangeTree) {\r\n                buffer[it.offset++] = SWITCH_TO_STRUCTURE & 255;\r\n                encode.number(buffer, changeTree.refId, it);\r\n            }\r\n\r\n            for (let j = 0; j < numChanges; j++) {\r\n                const fieldIndex = changeSet.operations[j];\r\n\r\n                if (fieldIndex < 0) {\r\n                    // \"pure\" operation without fieldIndex (e.g. CLEAR, REVERSE, etc.)\r\n                    // encode and continue early - no need to reach $filter check\r\n                    buffer[it.offset++] = Math.abs(fieldIndex) & 255;\r\n                    continue;\r\n                }\r\n\r\n                const operation = (isEncodeAll)\r\n                    ? OPERATION.ADD\r\n                    : changeTree.indexedOperations[fieldIndex];\r\n\r\n                //\r\n                // first pass (encodeAll), identify \"filtered\" operations without encoding them\r\n                // they will be encoded per client, based on their view.\r\n                //\r\n                // TODO: how can we optimize filtering out \"encode all\" operations?\r\n                // TODO: avoid checking if no view tags were defined\r\n                //\r\n                if (fieldIndex === undefined || operation === undefined || (filter && !filter(ref, fieldIndex, view))) {\r\n                    // console.log(\"ADD AS INVISIBLE:\", fieldIndex, changeTree.ref.constructor.name)\r\n                    // view?.invisible.add(changeTree);\r\n                    continue;\r\n                }\r\n\r\n                encoder(this, buffer, changeTree, fieldIndex, operation, it, isEncodeAll, hasView, metadata);\r\n            }\r\n        }\r\n\r\n        if (it.offset > buffer.byteLength) {\r\n            // we can assume that n + 1 poolSize will suffice given that we are likely done with encoding at this point\r\n            // multiples of poolSize are faster to allocate than arbitrary sizes\r\n            // if we are on an older platform that doesn't implement pooling use 8kb as poolSize (that's the default for node)\r\n            const newSize = Math.ceil(it.offset / (Buffer.poolSize ?? 8 * 1024)) * (Buffer.poolSize ?? 8 * 1024);\r\n\r\n            console.warn(`@colyseus/schema buffer overflow. Encoded state is higher than default BUFFER_SIZE. Use the following to increase default BUFFER_SIZE:\r\n\r\n    import { Encoder } from \"@colyseus/schema\";\r\n    Encoder.BUFFER_SIZE = ${Math.round(newSize / 1024)} * 1024; // ${Math.round(newSize / 1024)} KB\r\n`);\r\n\r\n            //\r\n            // resize buffer and re-encode (TODO: can we avoid re-encoding here?)\r\n            // -> No we probably can't unless we catch the need for resize before encoding which is likely more computationally expensive than resizing on demand\r\n            //\r\n            buffer = Buffer.alloc(newSize, buffer); // fill with buffer here to memcpy previous encoding steps beyond the initialOffset\r\n\r\n            // assign resized buffer to local sharedBuffer\r\n            if (buffer === this.sharedBuffer) {\r\n                this.sharedBuffer = buffer;\r\n            }\r\n\r\n            return this.encode({ offset: initialOffset }, view, buffer, changeSetName, isEncodeAll);\r\n\r\n        } else {\r\n\r\n            return buffer.subarray(0, it.offset);\r\n        }\r\n    }\r\n\r\n    encodeAll(it: Iterator = { offset: 0 }, buffer: Buffer = this.sharedBuffer) {\r\n        return this.encode(it, undefined, buffer, \"allChanges\", true);\r\n    }\r\n\r\n    encodeAllView(view: StateView, sharedOffset: number, it: Iterator, bytes = this.sharedBuffer) {\r\n        const viewOffset = it.offset;\r\n\r\n        // try to encode \"filtered\" changes\r\n        this.encode(it, view, bytes, \"allFilteredChanges\", true, viewOffset);\r\n\r\n        return Buffer.concat([\r\n            bytes.subarray(0, sharedOffset),\r\n            bytes.subarray(viewOffset, it.offset)\r\n        ]);\r\n    }\r\n\r\n    encodeView(view: StateView, sharedOffset: number, it: Iterator, bytes = this.sharedBuffer) {\r\n        const viewOffset = it.offset;\r\n\r\n        // encode visibility changes (add/remove for this view)\r\n        for (const [refId, changes] of view.changes) {\r\n            const changeTree: ChangeTree = this.root.changeTrees[refId];\r\n\r\n            if (changeTree === undefined) {\r\n                // detached instance, remove from view and skip.\r\n                // console.log(\"detached instance, remove from view and skip.\", refId);\r\n                view.changes.delete(refId);\r\n                continue;\r\n            }\r\n\r\n            const keys = Object.keys(changes);\r\n            if (keys.length === 0) {\r\n                // FIXME: avoid having empty changes if no changes were made\r\n                // console.log(\"changes.size === 0, skip\", refId, changeTree.ref.constructor.name);\r\n                continue;\r\n            }\r\n\r\n            const ref = changeTree.ref;\r\n\r\n            const ctor = ref.constructor;\r\n            const encoder = ctor[$encoder];\r\n            const metadata = ctor[Symbol.metadata];\r\n\r\n            bytes[it.offset++] = SWITCH_TO_STRUCTURE & 255;\r\n            encode.number(bytes, changeTree.refId, it);\r\n\r\n            for (let i = 0, numChanges = keys.length; i < numChanges; i++) {\r\n                const index = Number(keys[i]);\r\n                // workaround when using view.add() on item that has been deleted from state (see test \"adding to view item that has been removed from state\")\r\n                const value = changeTree.ref[$getByIndex](index);\r\n                const operation = (value !== undefined && changes[index]) || OPERATION.DELETE;\r\n\r\n                // isEncodeAll = false\r\n                // hasView = true\r\n                encoder(this, bytes, changeTree, index, operation, it, false, true, metadata);\r\n            }\r\n        }\r\n\r\n        //\r\n        // TODO: only clear view changes after all views are encoded\r\n        // (to allow re-using StateView's for multiple clients)\r\n        //\r\n        // clear \"view\" changes after encoding\r\n        view.changes.clear();\r\n\r\n        // try to encode \"filtered\" changes\r\n        this.encode(it, view, bytes, \"filteredChanges\", false, viewOffset);\r\n\r\n        return Buffer.concat([\r\n            bytes.subarray(0, sharedOffset),\r\n            bytes.subarray(viewOffset, it.offset)\r\n        ]);\r\n    }\r\n\r\n    discardChanges() {\r\n        // discard shared changes\r\n        let current = this.root.changes.next;\r\n        while (current) {\r\n            current.changeTree.endEncode('changes');\r\n            current = current.next;\r\n        }\r\n        this.root.changes = createChangeTreeList();\r\n\r\n        // discard filtered changes\r\n        current = this.root.filteredChanges.next;\r\n        while (current) {\r\n            current.changeTree.endEncode('filteredChanges');\r\n            current = current.next;\r\n        }\r\n        this.root.filteredChanges = createChangeTreeList();\r\n    }\r\n\r\n    tryEncodeTypeId (bytes: Buffer, baseType: typeof Schema, targetType: typeof Schema, it: Iterator) {\r\n        const baseTypeId = this.context.getTypeId(baseType);\r\n        const targetTypeId = this.context.getTypeId(targetType);\r\n\r\n        if (targetTypeId === undefined) {\r\n            console.warn(`@colyseus/schema WARNING: Class \"${targetType.name}\" is not registered on TypeRegistry - Please either tag the class with @entity or define a @type() field.`);\r\n            return;\r\n        }\r\n\r\n        if (baseTypeId !== targetTypeId) {\r\n            bytes[it.offset++] = TYPE_ID & 255;\r\n            encode.number(bytes, targetTypeId, it);\r\n        }\r\n    }\r\n\r\n    get hasChanges() {\r\n        return (\r\n            this.root.changes.next !== undefined ||\r\n            this.root.filteredChanges.next !== undefined\r\n        );\r\n    }\r\n}\r\n"]}