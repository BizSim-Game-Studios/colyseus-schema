{"version":3,"file":"DecodeOperation.js","sourceRoot":"","sources":["../../src/decoder/DecodeOperation.ts"],"names":[],"mappings":"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","sourcesContent":["import { OPERATION } from \"../encoding/spec\";\r\nimport { Metadata } from \"../Metadata\";\r\nimport { Schema } from \"../Schema\";\r\nimport type { Ref } from \"../encoder/ChangeTree\";\r\nimport type { Decoder } from \"./Decoder\";\r\nimport { Iterator, decode } from \"../encoding/decode\";\r\nimport { $childType, $deleteByIndex, $getByIndex } from \"../types/symbols\";\r\n\r\nimport type { MapSchema } from \"../types/custom/MapSchema\";\r\nimport type { ArraySchema } from \"../types/custom/ArraySchema\";\r\nimport type { CollectionSchema } from \"../types/custom/CollectionSchema\";\r\n\r\nimport { getType } from \"../types/registry\";\r\nimport { Collection } from \"../types/HelperTypes\";\r\n\r\nexport interface DataChange<T = any, F = string> {\r\n    ref: Ref,\r\n    refId: number,\r\n    op: OPERATION,\r\n    field: F;\r\n    dynamicIndex?: number | string;\r\n    value: T;\r\n    previousValue: T;\r\n}\r\n\r\nexport const DEFINITION_MISMATCH = -1;\r\n\r\nexport type DecodeOperation<T extends Schema = any> = (\r\n    decoder: Decoder<T>,\r\n    bytes: Buffer,\r\n    it: Iterator,\r\n    ref: Ref,\r\n    allChanges: DataChange[],\r\n) => number | void;\r\n\r\nexport function decodeValue<T extends Ref>(\r\n    decoder: Decoder,\r\n    operation: OPERATION,\r\n    ref: T,\r\n    index: number,\r\n    type: any,\r\n    bytes: Buffer,\r\n    it: Iterator,\r\n    allChanges: DataChange[],\r\n) {\r\n    const $root = decoder.root;\r\n    const previousValue = (ref as any)[$getByIndex](index) as T;\r\n\r\n    let value: any;\r\n\r\n    if ((operation & OPERATION.DELETE) === OPERATION.DELETE)\r\n    {\r\n        // Flag `refId` for garbage collection.\r\n        const previousRefId = $root.refIds.get(previousValue);\r\n        if (previousRefId !== undefined) { $root.removeRef(previousRefId); }\r\n\r\n        //\r\n        // Delete operations\r\n        //\r\n        if (operation !== OPERATION.DELETE_AND_ADD) {\r\n            (ref as any)[$deleteByIndex](index);\r\n        }\r\n\r\n        value = undefined;\r\n    }\r\n\r\n    if (operation === OPERATION.DELETE) {\r\n        //\r\n        // Don't do anything\r\n        //\r\n\r\n    } else if (Schema.is(type)) {\r\n        const refId = decode.number(bytes, it);\r\n        value = $root.refs.get(refId);\r\n\r\n        if ((operation & OPERATION.ADD) === OPERATION.ADD) {\r\n            const childType = decoder.getInstanceType(bytes, it, type);\r\n            if (!value) {\r\n                value = decoder.createInstanceOfType(childType);\r\n            }\r\n\r\n            $root.addRef(\r\n                refId,\r\n                value,\r\n                (\r\n                    value !== previousValue || // increment ref count if value has changed\r\n                    (operation === OPERATION.DELETE_AND_ADD && value === previousValue) // increment ref count if the same instance is being added again\r\n                )\r\n            );\r\n        }\r\n\r\n    } else if (typeof(type) === \"string\") {\r\n        //\r\n        // primitive value (number, string, boolean, etc)\r\n        //\r\n        value = (decode as any)[type](bytes, it);\r\n\r\n    } else {\r\n        const typeDef = getType(Object.keys(type)[0]);\r\n        const refId = decode.number(bytes, it);\r\n\r\n        const valueRef: Ref = ($root.refs.has(refId))\r\n            ? previousValue || $root.refs.get(refId)\r\n            : new typeDef.constructor();\r\n\r\n        value = valueRef.clone(true);\r\n        value[$childType] = Object.values(type)[0]; // cache childType for ArraySchema and MapSchema\r\n\r\n        if (previousValue) {\r\n            let previousRefId = $root.refIds.get(previousValue);\r\n\r\n            if (previousRefId !== undefined && refId !== previousRefId) {\r\n                //\r\n                // enqueue onRemove if structure has been replaced.\r\n                //\r\n                const entries: IterableIterator<[any, any]> = (previousValue as any).entries();\r\n                let iter: IteratorResult<[any, any]>;\r\n                while ((iter = entries.next()) && !iter.done) {\r\n                    const [key, value] = iter.value;\r\n\r\n                    // if value is a schema, remove its reference\r\n                    if (typeof(value) === \"object\") {\r\n                        previousRefId = $root.refIds.get(value);\r\n                        $root.removeRef(previousRefId);\r\n                    }\r\n\r\n                    allChanges.push({\r\n                        ref: previousValue,\r\n                        refId: previousRefId,\r\n                        op: OPERATION.DELETE,\r\n                        field: key,\r\n                        value: undefined,\r\n                        previousValue: value,\r\n                    });\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n        $root.addRef(refId, value, (\r\n            valueRef !== previousValue ||\r\n            (operation === OPERATION.DELETE_AND_ADD && valueRef === previousValue)\r\n        ));\r\n    }\r\n\r\n    return { value, previousValue };\r\n}\r\n\r\nexport const decodeSchemaOperation: DecodeOperation = function <T extends Schema>(\r\n    decoder: Decoder<any>,\r\n    bytes: Buffer,\r\n    it: Iterator,\r\n    ref: T,\r\n    allChanges: DataChange[],\r\n) {\r\n    const first_byte = bytes[it.offset++];\r\n    const metadata: Metadata = (ref.constructor as typeof Schema)[Symbol.metadata];\r\n\r\n    // \"compressed\" index + operation\r\n    const operation = (first_byte >> 6) << 6\r\n    const index = first_byte % (operation || 255);\r\n\r\n    // skip early if field is not defined\r\n    const field = metadata[index];\r\n    if (field === undefined) {\r\n        console.warn(\"@colyseus/schema: field not defined at\", { index, ref: ref.constructor.name, metadata });\r\n        return DEFINITION_MISMATCH;\r\n    }\r\n\r\n    const { value, previousValue } = decodeValue(\r\n        decoder,\r\n        operation,\r\n        ref,\r\n        index,\r\n        field.type,\r\n        bytes,\r\n        it,\r\n        allChanges,\r\n    );\r\n\r\n    if (value !== null && value !== undefined) {\r\n        ref[field.name as keyof T] = value;\r\n    }\r\n\r\n    // add change\r\n    if (previousValue !== value) {\r\n        allChanges.push({\r\n            ref,\r\n            refId: decoder.currentRefId,\r\n            op: operation,\r\n            field: field.name,\r\n            value,\r\n            previousValue,\r\n        });\r\n    }\r\n}\r\n\r\nexport const decodeKeyValueOperation: DecodeOperation = function (\r\n    decoder: Decoder<any>,\r\n    bytes: Buffer,\r\n    it: Iterator,\r\n    ref: Ref,\r\n    allChanges: DataChange[]\r\n) {\r\n    // \"uncompressed\" index + operation (array/map items)\r\n    const operation = bytes[it.offset++];\r\n\r\n    if (operation === OPERATION.CLEAR) {\r\n        //\r\n        // When decoding:\r\n        // - enqueue items for DELETE callback.\r\n        // - flag child items for garbage collection.\r\n        //\r\n        decoder.removeChildRefs(ref as unknown as Collection, allChanges);\r\n\r\n        (ref as any).clear();\r\n        return;\r\n    }\r\n\r\n    const index = decode.number(bytes, it);\r\n    const type = (ref as any)[$childType];\r\n\r\n    let dynamicIndex: number | string;\r\n\r\n    if ((operation & OPERATION.ADD) === OPERATION.ADD) { // ADD or DELETE_AND_ADD\r\n        if (typeof((ref as any)['set']) === \"function\") {\r\n            dynamicIndex = decode.string(bytes, it); // MapSchema\r\n            (ref as any)['setIndex'](index, dynamicIndex);\r\n        } else {\r\n            dynamicIndex = index; // ArraySchema\r\n        }\r\n    } else {\r\n        // get dynamic index from \"ref\"\r\n        dynamicIndex = (ref as any)['getIndex'](index);\r\n    }\r\n\r\n    const { value, previousValue } = decodeValue(\r\n        decoder,\r\n        operation,\r\n        ref,\r\n        index,\r\n        type,\r\n        bytes,\r\n        it,\r\n        allChanges,\r\n    );\r\n\r\n    if (value !== null && value !== undefined) {\r\n        if (typeof((ref as any)['set']) === \"function\") {\r\n            // MapSchema\r\n            (ref as any)['$items'].set(dynamicIndex as string, value);\r\n\r\n        } else if (typeof((ref as any)['$setAt']) === \"function\") {\r\n            // ArraySchema\r\n            (ref as any)['$setAt'](index, value, operation);\r\n\r\n        } else if (typeof((ref as any)['add']) === \"function\") {\r\n            // CollectionSchema && SetSchema\r\n            const index = (ref as any).add(value);\r\n\r\n            if (typeof(index) === \"number\") {\r\n                (ref as any)['setIndex'](index, index);\r\n            }\r\n        }\r\n    }\r\n\r\n    // add change\r\n    if (previousValue !== value) {\r\n        allChanges.push({\r\n            ref,\r\n            refId: decoder.currentRefId,\r\n            op: operation,\r\n            field: \"\", // FIXME: remove this\r\n            dynamicIndex,\r\n            value,\r\n            previousValue,\r\n        });\r\n    }\r\n}\r\n\r\nexport const decodeArray: DecodeOperation = function (\r\n    decoder: Decoder<any>,\r\n    bytes: Buffer,\r\n    it: Iterator,\r\n    ref: ArraySchema,\r\n    allChanges: DataChange[]\r\n) {\r\n    // \"uncompressed\" index + operation (array/map items)\r\n    let operation = bytes[it.offset++];\r\n    let index: number;\r\n\r\n    if (operation === OPERATION.CLEAR) {\r\n        //\r\n        // When decoding:\r\n        // - enqueue items for DELETE callback.\r\n        // - flag child items for garbage collection.\r\n        //\r\n        decoder.removeChildRefs(ref as unknown as Collection, allChanges);\r\n        (ref as ArraySchema).clear();\r\n        return;\r\n\r\n    } else if (operation === OPERATION.REVERSE) {\r\n        (ref as ArraySchema).reverse();\r\n        return;\r\n\r\n    } else if (operation === OPERATION.DELETE_BY_REFID) {\r\n        // TODO: refactor here, try to follow same flow as below\r\n        const refId = decode.number(bytes, it);\r\n        const previousValue = decoder.root.refs.get(refId);\r\n        index = ref.findIndex((value) => value === previousValue);\r\n        ref[$deleteByIndex](index);\r\n        allChanges.push({\r\n            ref,\r\n            refId: decoder.currentRefId,\r\n            op: OPERATION.DELETE,\r\n            field: \"\", // FIXME: remove this\r\n            dynamicIndex: index,\r\n            value: undefined,\r\n            previousValue,\r\n        });\r\n\r\n        return;\r\n\r\n    } else if (operation === OPERATION.ADD_BY_REFID) {\r\n        const refId = decode.number(bytes, it);\r\n        const itemByRefId = decoder.root.refs.get(refId);\r\n\r\n        // if item already exists, use existing index\r\n        if (itemByRefId) {\r\n            index = ref.findIndex((value) => value === itemByRefId);\r\n        }\r\n\r\n        // fallback to use last index\r\n        if (index === -1 || index === undefined) {\r\n            index = ref.length;\r\n        }\r\n\r\n    } else {\r\n        index = decode.number(bytes, it);\r\n    }\r\n\r\n    const type = ref[$childType];\r\n\r\n    let dynamicIndex: number | string = index;\r\n\r\n    const { value, previousValue } = decodeValue(\r\n        decoder,\r\n        operation,\r\n        ref,\r\n        index,\r\n        type,\r\n        bytes,\r\n        it,\r\n        allChanges,\r\n    );\r\n\r\n    if (\r\n        value !== null && value !== undefined &&\r\n        value !== previousValue // avoid setting same value twice (if index === 0 it will result in a \"unshift\" for ArraySchema)\r\n    ) {\r\n        // ArraySchema\r\n        (ref as ArraySchema)['$setAt'](index, value, operation);\r\n    }\r\n\r\n    // add change\r\n    if (previousValue !== value) {\r\n        allChanges.push({\r\n            ref,\r\n            refId: decoder.currentRefId,\r\n            op: operation,\r\n            field: \"\", // FIXME: remove this\r\n            dynamicIndex,\r\n            value,\r\n            previousValue,\r\n        });\r\n    }\r\n}"]}