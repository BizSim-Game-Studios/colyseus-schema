{"version":3,"file":"StateCallbacks.js","sourceRoot":"","sources":["../../../src/decoder/strategy/StateCallbacks.ts"],"names":[],"mappings":"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","sourcesContent":["import { Metadata } from \"../../Metadata\";\r\nimport { Collection, NonFunctionNonPrimitivePropNames, NonFunctionPropNames } from \"../../types/HelperTypes\";\r\nimport { Ref } from \"../../encoder/ChangeTree\";\r\nimport { Decoder } from \"../Decoder\";\r\nimport { DataChange } from \"../DecodeOperation\";\r\nimport { OPERATION } from \"../../encoding/spec\";\r\nimport { Schema } from \"../../Schema\";\r\nimport type { DefinitionType } from \"../../annotations\";\r\nimport type { CollectionSchema } from \"../../types/custom/CollectionSchema\";\r\n\r\n//\r\n// Discussion: https://github.com/colyseus/schema/issues/155\r\n//\r\n// Main points:\r\n// - Decouple structures from their callbacks.\r\n// - Registering deep callbacks can be confusing.\r\n// - Avoid closures by allowing to pass a context. (https://github.com/colyseus/schema/issues/155#issuecomment-1804694081)\r\n//\r\n\r\n/**\r\n * TODO: define a schema interface, which even having duplicate definitions, it could be used to get the callback proxy.\r\n *\r\n * ```ts\r\n *     export type SchemaCallbackProxy<RoomState> = (<T extends Schema>(instance: T) => CallbackProxy<T>);\r\n * ```\r\n */\r\nexport type SchemaCallbackProxy<RoomState> = (<T>(instance: T) => CallbackProxy<T>);\r\nexport type GetCallbackProxy = SchemaCallbackProxy<any>; // workaround for compatibility for < colyseus.js0.16.6. Remove me on next major release.\r\n\r\nexport type CallbackProxy<T> = unknown extends T // is \"any\"?\r\n    ? SchemaCallback<T> & CollectionCallback<any, any>\r\n    : T extends Collection<infer K, infer V, infer _>\r\n        ? CollectionCallback<K, V>\r\n        : SchemaCallback<T>;\r\n\r\nexport type SchemaCallback<T> = {\r\n    /**\r\n     * Trigger callback when value of a property changes.\r\n     *\r\n     * @param prop name of the property\r\n     * @param callback callback to be triggered on property change\r\n     * @param immediate trigger immediatelly if property has been already set.\r\n     * @return callback to detach the listener\r\n     */\r\n    listen<K extends NonFunctionPropNames<T>>(\r\n        prop: K,\r\n        callback: (value: T[K], previousValue: T[K]) => void,\r\n        immediate?: boolean,\r\n    ): () => void;\r\n\r\n    /**\r\n     * Trigger callback whenever any property changed within this instance.\r\n     *\r\n     * @param prop name of the property\r\n     * @param callback callback to be triggered on property change\r\n     * @param immediate trigger immediatelly if property has been already set.\r\n     * @return callback to detach the listener\r\n     */\r\n    onChange(callback: () => void): () => void;\r\n\r\n    /**\r\n     * Bind properties to another object. Changes on the properties will be reflected on the target object.\r\n     *\r\n     * @param targetObject object to bind properties to\r\n     * @param properties list of properties to bind. If not provided, all properties will be bound.\r\n     */\r\n    bindTo(targetObject: any, properties?: Array<NonFunctionPropNames<T>>): void;\r\n} & {\r\n    [K in NonFunctionNonPrimitivePropNames<T>]: CallbackProxy<T[K]>;\r\n}\r\n\r\nexport type CollectionCallback<K, V> = {\r\n    /**\r\n     * Trigger callback when an item has been added to the collection.\r\n     *\r\n     * @param callback\r\n     * @param immediate\r\n     * @return callback to detach the onAdd listener\r\n     */\r\n    onAdd(callback: (item: V, index: K) => void, immediate?: boolean): () => void;\r\n\r\n    /**\r\n     * Trigger callback when an item has been removed to the collection.\r\n     *\r\n     * @param callback\r\n     * @return callback to detach the onRemove listener\r\n     */\r\n    onRemove(callback: (item: V, index: K) => void): () => void;\r\n\r\n    /**\r\n     * Trigger callback when the value on a key has changed.\r\n     *\r\n     * THIS METHOD IS NOT RECURSIVE!\r\n     * If you want to listen to changes on individual items, you need to attach callbacks to the them directly inside the `onAdd` callback.\r\n     *\r\n     * @param callback\r\n     * @return callback to detach the onChange listener\r\n     */\r\n    onChange(callback: (item: V, index: K) => void): () => void;\r\n};\r\n\r\ntype OnInstanceAvailableCallback = (callback: (ref: Ref, existing: boolean) => void) => void;\r\n\r\ntype CallContext = {\r\n    instance?: any,\r\n    parentInstance?: any,\r\n    onInstanceAvailable?: OnInstanceAvailableCallback,\r\n}\r\n\r\n\r\nexport function getDecoderStateCallbacks<T extends Schema>(decoder: Decoder<T>): SchemaCallbackProxy<T> {\r\n    const $root = decoder.root;\r\n    const callbacks = $root.callbacks;\r\n\r\n    const onAddCalls: WeakMap<Function, boolean> = new WeakMap();\r\n    let currentOnAddCallback: Function | undefined;\r\n\r\n    decoder.triggerChanges = function (allChanges: DataChange[]) {\r\n        const uniqueRefIds = new Set<number>();\r\n\r\n        for (let i = 0, l = allChanges.length; i < l; i++) {\r\n            const change = allChanges[i];\r\n            const refId = change.refId;\r\n            const ref = change.ref;\r\n            const $callbacks = callbacks[refId];\r\n\r\n            if (!$callbacks) { continue; }\r\n\r\n            //\r\n            // trigger onRemove on child structure.\r\n            //\r\n            if (\r\n                (change.op & OPERATION.DELETE) === OPERATION.DELETE &&\r\n                change.previousValue instanceof Schema\r\n            ) {\r\n                const deleteCallbacks = callbacks[$root.refIds.get(change.previousValue)]?.[OPERATION.DELETE];\r\n                for (let i = deleteCallbacks?.length - 1; i >= 0; i--) {\r\n                    deleteCallbacks[i]();\r\n                }\r\n            }\r\n\r\n            if (ref instanceof Schema) {\r\n                //\r\n                // Handle schema instance\r\n                //\r\n\r\n                if (!uniqueRefIds.has(refId)) {\r\n                    // trigger onChange\r\n                    const replaceCallbacks = $callbacks?.[OPERATION.REPLACE];\r\n                    for (let i = replaceCallbacks?.length - 1; i >= 0; i--) {\r\n                        replaceCallbacks[i]();\r\n                        // try {\r\n                        // } catch (e) {\r\n                        //     console.error(e);\r\n                        // }\r\n                    }\r\n                }\r\n\r\n                if ($callbacks.hasOwnProperty(change.field)) {\r\n                    const fieldCallbacks = $callbacks[change.field];\r\n                    for (let i = fieldCallbacks?.length - 1; i >= 0; i--) {\r\n                        fieldCallbacks[i](change.value, change.previousValue);\r\n                        // try {\r\n                        // } catch (e) {\r\n                        //     console.error(e);\r\n                        // }\r\n                    }\r\n                }\r\n\r\n\r\n            } else {\r\n                //\r\n                // Handle collection of items\r\n                //\r\n\r\n                if ((change.op & OPERATION.DELETE) === OPERATION.DELETE) {\r\n                    //\r\n                    // FIXME: `previousValue` should always be available.\r\n                    //\r\n                    if (change.previousValue !== undefined) {\r\n                        // triger onRemove\r\n                        const deleteCallbacks = $callbacks[OPERATION.DELETE];\r\n                        for (let i = deleteCallbacks?.length - 1; i >= 0; i--) {\r\n                            deleteCallbacks[i](change.previousValue, change.dynamicIndex ?? change.field);\r\n                        }\r\n                    }\r\n\r\n                    // Handle DELETE_AND_ADD operations\r\n                    if ((change.op & OPERATION.ADD) === OPERATION.ADD) {\r\n                        const addCallbacks = $callbacks[OPERATION.ADD];\r\n                        for (let i = addCallbacks?.length - 1; i >= 0; i--) {\r\n                            addCallbacks[i](change.value, change.dynamicIndex ?? change.field);\r\n                        }\r\n                    }\r\n\r\n                } else if (\r\n                    (change.op & OPERATION.ADD) === OPERATION.ADD &&\r\n                    change.previousValue !== change.value\r\n                ) {\r\n                    // triger onAdd\r\n                    const addCallbacks = $callbacks[OPERATION.ADD];\r\n                    for (let i = addCallbacks?.length - 1; i >= 0; i--) {\r\n                        addCallbacks[i](change.value, change.dynamicIndex ?? change.field);\r\n                    }\r\n                }\r\n\r\n                // trigger onChange\r\n                if (\r\n                    change.value !== change.previousValue &&\r\n                    // FIXME: see \"should not encode item if added and removed at the same patch\" test case.\r\n                    // some \"ADD\" + \"DELETE\" operations on same patch are being encoded as \"DELETE\"\r\n                    (change.value !== undefined || change.previousValue !== undefined)\r\n                ) {\r\n                    const replaceCallbacks = $callbacks[OPERATION.REPLACE];\r\n                    for (let i = replaceCallbacks?.length - 1; i >= 0; i--) {\r\n                        replaceCallbacks[i](change.value, change.dynamicIndex ?? change.field);\r\n                    }\r\n                }\r\n            }\r\n\r\n            uniqueRefIds.add(refId);\r\n        }\r\n    };\r\n\r\n    function getProxy(\r\n        metadataOrType: Metadata | DefinitionType,\r\n        context: CallContext\r\n    ) {\r\n        let metadata: Metadata = context.instance?.constructor[Symbol.metadata] || metadataOrType;\r\n        let isCollection = (\r\n            (context.instance && typeof (context.instance['forEach']) === \"function\") ||\r\n            (metadataOrType && typeof ((metadataOrType as typeof Schema)[Symbol.metadata]) === \"undefined\")\r\n        );\r\n\r\n        if (metadata && !isCollection) {\r\n\r\n            const onAddListen = function (\r\n                ref: Ref,\r\n                prop: string,\r\n                callback: (value: any, previousValue: any) => void, immediate: boolean\r\n            ) {\r\n                // immediate trigger\r\n                if (\r\n                    immediate &&\r\n                    context.instance[prop] !== undefined &&\r\n                    !onAddCalls.has(currentOnAddCallback) // Workaround for https://github.com/colyseus/schema/issues/147\r\n                ) {\r\n                    callback(context.instance[prop], undefined);\r\n                }\r\n                return $root.addCallback($root.refIds.get(ref), prop, callback);\r\n            }\r\n\r\n            /**\r\n             * Schema instances\r\n             */\r\n            return new Proxy({\r\n                listen: function listen(prop: string, callback: (value: any, previousValue: any) => void, immediate: boolean = true) {\r\n                    if (context.instance) {\r\n                        return onAddListen(context.instance, prop, callback, immediate);\r\n\r\n                    } else {\r\n                        // collection instance not received yet\r\n                        let detachCallback = () => {};\r\n\r\n                        context.onInstanceAvailable((ref: Ref, existing: boolean) => {\r\n                            detachCallback = onAddListen(ref, prop, callback, immediate && existing && !onAddCalls.has(currentOnAddCallback))\r\n                        });\r\n\r\n                        return () => detachCallback();\r\n                    }\r\n                },\r\n\r\n                onChange: function onChange(callback: () => void) {\r\n                    return $root.addCallback(\r\n                        $root.refIds.get(context.instance),\r\n                        OPERATION.REPLACE,\r\n                        callback\r\n                    );\r\n                },\r\n\r\n                //\r\n                // TODO: refactor `bindTo()` implementation.\r\n                // There is room for improvement.\r\n                //\r\n                bindTo: function bindTo(targetObject: any, properties?: string[]) {\r\n                    if (!properties) {\r\n                        properties = Object.keys(metadata).map((index) => metadata[index as any as number].name);\r\n                    }\r\n                    return $root.addCallback(\r\n                        $root.refIds.get(context.instance),\r\n                        OPERATION.REPLACE,\r\n                        () => {\r\n                            properties.forEach((prop) =>\r\n                                targetObject[prop] = context.instance[prop])\r\n                        }\r\n                    );\r\n                }\r\n            }, {\r\n                get(target, prop: string) {\r\n                    const metadataField = metadata[metadata[prop]];\r\n                    if (metadataField) {\r\n                        const instance = context.instance?.[prop];\r\n                        const onInstanceAvailable: OnInstanceAvailableCallback = (\r\n                            (callback: (ref: Ref, existing: boolean) => void) => {\r\n                                const unbind = $(context.instance).listen(prop, (value, _) => {\r\n                                    callback(value, false);\r\n\r\n                                    // FIXME: by \"unbinding\" the callback here,\r\n                                    // it will not support when the server\r\n                                    // re-instantiates the instance.\r\n                                    //\r\n                                    unbind?.();\r\n                                }, false);\r\n\r\n                                // has existing value\r\n                                if ($root.refIds.get(instance) !== undefined) {\r\n                                    callback(instance, true);\r\n                                }\r\n                            }\r\n                        );\r\n\r\n                        return getProxy(metadataField.type, {\r\n                            // make sure refId is available, otherwise need to wait for the instance to be available.\r\n                            instance: ($root.refIds.get(instance) && instance),\r\n                            parentInstance: context.instance,\r\n                            onInstanceAvailable,\r\n                        });\r\n\r\n                    } else {\r\n                        // accessing the function\r\n                        return target[prop as keyof typeof target];\r\n                    }\r\n                },\r\n                has(target, prop: string) { return metadata[prop] !== undefined; },\r\n                set(_, _1, _2) { throw new Error(\"not allowed\"); },\r\n                deleteProperty(_, _1) { throw new Error(\"not allowed\"); },\r\n            });\r\n\r\n        } else {\r\n            /**\r\n             * Collection instances\r\n             */\r\n\r\n            const onAdd = function (ref: Ref, callback: (value: any, key: any) => void, immediate: boolean) {\r\n                // Trigger callback on existing items\r\n                if (immediate) {\r\n                    (ref as CollectionSchema).forEach((v, k) => callback(v, k));\r\n                }\r\n\r\n                return $root.addCallback($root.refIds.get(ref), OPERATION.ADD, (value: any, key: any) => {\r\n                    onAddCalls.set(callback, true);\r\n                    currentOnAddCallback = callback;\r\n                    callback(value, key);\r\n                    onAddCalls.delete(callback)\r\n                    currentOnAddCallback = undefined;\r\n                });\r\n            };\r\n\r\n            const onRemove = function (ref: Ref, callback: (value: any, key: any) => void) {\r\n                return $root.addCallback($root.refIds.get(ref), OPERATION.DELETE, callback);\r\n            };\r\n\r\n            const onChange = function (ref: Ref, callback: (value: any, key: any) => void) {\r\n                return $root.addCallback($root.refIds.get(ref), OPERATION.REPLACE, callback);\r\n            };\r\n\r\n            return new Proxy({\r\n                onAdd: function(callback: (value: any, key: any) => void, immediate: boolean = true) {\r\n                    //\r\n                    // https://github.com/colyseus/schema/issues/147\r\n                    // If parent instance has \"onAdd\" registered, avoid triggering immediate callback.\r\n                    //\r\n\r\n                    if (context.instance) {\r\n                        return onAdd(context.instance, callback, immediate && !onAddCalls.has(currentOnAddCallback));\r\n\r\n                    } else if (context.onInstanceAvailable) {\r\n                        // collection instance not received yet\r\n                        let detachCallback = () => {};\r\n\r\n                        context.onInstanceAvailable((ref: Ref, existing: boolean) => {\r\n                            detachCallback = onAdd(ref, callback, immediate && existing && !onAddCalls.has(currentOnAddCallback));\r\n                        });\r\n\r\n                        return () => detachCallback();\r\n                    }\r\n                },\r\n                onRemove: function(callback: (value: any, key: any) => void) {\r\n                    if (context.instance) {\r\n                        return onRemove(context.instance, callback);\r\n\r\n                    } else if (context.onInstanceAvailable) {\r\n                        // collection instance not received yet\r\n                        let detachCallback = () => {};\r\n\r\n                        context.onInstanceAvailable((ref: Ref) => {\r\n                            detachCallback = onRemove(ref, callback)\r\n                        });\r\n\r\n                        return () => detachCallback();\r\n                    }\r\n                },\r\n                onChange: function(callback: (value: any, key: any) => void) {\r\n                    if (context.instance) {\r\n                        return onChange(context.instance, callback);\r\n\r\n                    } else if (context.onInstanceAvailable) {\r\n                        // collection instance not received yet\r\n                        let detachCallback = () => {};\r\n\r\n                        context.onInstanceAvailable((ref: Ref) => {\r\n                            detachCallback = onChange(ref, callback)\r\n                        });\r\n\r\n                        return () => detachCallback();\r\n                    }\r\n                },\r\n            }, {\r\n                get(target, prop: string) {\r\n                    if (!target[prop as keyof typeof target]) {\r\n                        throw new Error(`Can't access '${prop}' through callback proxy. access the instance directly.`);\r\n                    }\r\n                    return target[prop as keyof typeof target];\r\n                },\r\n                has(target, prop) { return target[prop as keyof typeof target] !== undefined; },\r\n                set(_, _1, _2) { throw new Error(\"not allowed\"); },\r\n                deleteProperty(_, _1) { throw new Error(\"not allowed\"); },\r\n            });\r\n        }\r\n    }\r\n\r\n    function $<T>(instance: T): CallbackProxy<T> {\r\n        return getProxy(undefined, { instance }) as unknown as CallbackProxy<T>;\r\n    }\r\n\r\n    return $;\r\n}\r\n"]}