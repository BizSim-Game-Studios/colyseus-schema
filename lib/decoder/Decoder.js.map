{"version":3,"file":"Decoder.js","sourceRoot":"","sources":["../../src/decoder/Decoder.ts"],"names":[],"mappings":"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","sourcesContent":["import { TypeContext } from \"../types/TypeContext\";\r\nimport { $changes, $childType, $decoder, $onDecodeEnd } from \"../types/symbols\";\r\nimport { Schema } from \"../Schema\";\r\n\r\nimport { decode } from \"../encoding/decode\";\r\nimport { OPERATION, SWITCH_TO_STRUCTURE, TYPE_ID } from '../encoding/spec';\r\nimport type { Ref } from \"../encoder/ChangeTree\";\r\nimport type { Iterator } from \"../encoding/decode\";\r\nimport { ReferenceTracker } from \"./ReferenceTracker\";\r\nimport { DEFINITION_MISMATCH, type DataChange, type DecodeOperation } from \"./DecodeOperation\";\r\nimport { Collection } from \"../types/HelperTypes\";\r\n\r\nexport class Decoder<T extends Schema = any> {\r\n    context: TypeContext;\r\n\r\n    state: T;\r\n    root: ReferenceTracker;\r\n\r\n    currentRefId: number = 0;\r\n\r\n    triggerChanges?: (allChanges: DataChange[]) => void;\r\n\r\n    constructor(root: T, context?: TypeContext) {\r\n        this.setState(root);\r\n\r\n        this.context = context || new TypeContext(root.constructor as typeof Schema);\r\n\r\n        // console.log(\">>>>>>>>>>>>>>>> Decoder types\");\r\n        // this.context.schemas.forEach((id, schema) => {\r\n        //     console.log(\"type:\", id, schema.name, Object.keys(schema[Symbol.metadata]));\r\n        // });\r\n    }\r\n\r\n    protected setState(root: T) {\r\n        this.state = root;\r\n        this.root = new ReferenceTracker();\r\n        this.root.addRef(0, root);\r\n    }\r\n\r\n    decode(\r\n        bytes: Buffer,\r\n        it: Iterator = { offset: 0 },\r\n        ref: Ref = this.state,\r\n    ) {\r\n        const allChanges: DataChange[] = [];\r\n\r\n        const $root = this.root;\r\n        const totalBytes = bytes.byteLength;\r\n\r\n        let decoder: DecodeOperation = ref['constructor'][$decoder];\r\n\r\n        this.currentRefId = 0;\r\n\r\n        while (it.offset < totalBytes) {\r\n            //\r\n            // Peek ahead, check if it's a switch to a different structure\r\n            //\r\n            if (bytes[it.offset] == SWITCH_TO_STRUCTURE) {\r\n                it.offset++;\r\n\r\n                (ref as any)[$onDecodeEnd]?.()\r\n\r\n                const nextRefId = decode.number(bytes, it);\r\n                const nextRef = $root.refs.get(nextRefId);\r\n\r\n                //\r\n                // Trying to access a reference that haven't been decoded yet.\r\n                //\r\n                if (!nextRef) {\r\n                    // throw new Error(`\"refId\" not found: ${nextRefId}`);\r\n                    console.error(`\"refId\" not found: ${nextRefId}`, { previousRef: ref, previousRefId: this.currentRefId });\r\n                    console.warn(\"Please report this issue to the developers.\");\r\n                    this.skipCurrentStructure(bytes, it, totalBytes);\r\n\r\n                } else {\r\n                    ref = nextRef;\r\n                    decoder = ref.constructor[$decoder];\r\n                    this.currentRefId = nextRefId;\r\n                }\r\n\r\n                continue;\r\n            }\r\n\r\n            const result = decoder(this, bytes, it, ref, allChanges);\r\n\r\n            if (result === DEFINITION_MISMATCH) {\r\n                console.warn(\"@colyseus/schema: definition mismatch\");\r\n                this.skipCurrentStructure(bytes, it, totalBytes);\r\n                continue;\r\n            }\r\n        }\r\n\r\n        // FIXME: DRY with SWITCH_TO_STRUCTURE block.\r\n        (ref as any)[$onDecodeEnd]?.()\r\n\r\n        // trigger changes\r\n        this.triggerChanges?.(allChanges);\r\n\r\n        // drop references of unused schemas\r\n        $root.garbageCollectDeletedRefs();\r\n\r\n        return allChanges;\r\n    }\r\n\r\n    skipCurrentStructure(bytes: Buffer, it: Iterator, totalBytes: number) {\r\n        //\r\n        // keep skipping next bytes until reaches a known structure\r\n        // by local decoder.\r\n        //\r\n        const nextIterator: Iterator = { offset: it.offset };\r\n        while (it.offset < totalBytes) {\r\n            if (bytes[it.offset] === SWITCH_TO_STRUCTURE) {\r\n                nextIterator.offset = it.offset + 1;\r\n                if (this.root.refs.has(decode.number(bytes, nextIterator))) {\r\n                    break;\r\n                }\r\n            }\r\n            it.offset++;\r\n        }\r\n    }\r\n\r\n    getInstanceType(bytes: Buffer, it: Iterator, defaultType: typeof Schema): typeof Schema {\r\n        let type: typeof Schema;\r\n\r\n        if (bytes[it.offset] === TYPE_ID) {\r\n            it.offset++;\r\n            const type_id = decode.number(bytes, it);\r\n            type = this.context.get(type_id);\r\n        }\r\n\r\n        return type || defaultType;\r\n    }\r\n\r\n    createInstanceOfType (type: typeof Schema): Schema {\r\n        return new (type as any)();\r\n    }\r\n\r\n    removeChildRefs(ref: Collection, allChanges: DataChange[]) {\r\n        const needRemoveRef = typeof ((ref as any)[$childType]) !== \"string\";\r\n        const refId = this.root.refIds.get(ref as Ref);\r\n\r\n        ref.forEach((value: any, key: any) => {\r\n            allChanges.push({\r\n                ref: ref as Ref,\r\n                refId,\r\n                op: OPERATION.DELETE,\r\n                field: key,\r\n                value: undefined,\r\n                previousValue: value\r\n            });\r\n\r\n            if (needRemoveRef) {\r\n                this.root.removeRef(this.root.refIds.get(value));\r\n            }\r\n        });\r\n    }\r\n\r\n}\r\n"]}