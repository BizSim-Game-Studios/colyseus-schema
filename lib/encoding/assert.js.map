{"version":3,"file":"assert.js","sourceRoot":"","sources":["../../src/encoding/assert.ts"],"names":[],"mappings":";;;AASA,gCA0CC;AAED,gDAaC;AA3DD,MAAa,iBAAkB,SAAQ,KAAK;CAAG;AAA/C,8CAA+C;AAE/C,SAAgB,UAAU,CAAC,KAAU,EAAE,IAAY,EAAE,KAAa,EAAE,KAAsB;IACtF,IAAI,YAAoB,CAAC;IACzB,IAAI,SAAS,GAAY,KAAK,CAAC;IAE/B,QAAQ,IAAI,EAAE,CAAC;QACX,KAAK,QAAQ,CAAC;QACd,KAAK,MAAM,CAAC;QACZ,KAAK,OAAO,CAAC;QACb,KAAK,OAAO,CAAC;QACb,KAAK,QAAQ,CAAC;QACd,KAAK,OAAO,CAAC;QACb,KAAK,QAAQ,CAAC;QACd,KAAK,OAAO,CAAC;QACb,KAAK,QAAQ,CAAC;QACd,KAAK,SAAS,CAAC;QACf,KAAK,SAAS;YACV,YAAY,GAAG,QAAQ,CAAC;YACxB,IAAI,KAAK,CAAC,KAAK,CAAC,EAAE,CAAC;gBACf,OAAO,CAAC,GAAG,CAAC,6BAA6B,KAAK,CAAC,WAAW,CAAC,IAAI,IAAI,KAAK,EAAE,CAAC,CAAC;YAChF,CAAC;YACD,MAAM;QACV,KAAK,UAAU,CAAC;QAChB,KAAK,WAAW;YACZ,YAAY,GAAG,QAAQ,CAAC;YACxB,MAAM;QACV,KAAK,QAAQ;YACT,YAAY,GAAG,QAAQ,CAAC;YACxB,SAAS,GAAG,IAAI,CAAC;YACjB,MAAM;QACV,KAAK,SAAS;YACV,8DAA8D;YAC9D,OAAO;QACX;YACI,kCAAkC;YAClC,0DAA0D;YAC1D,OAAO;IACf,CAAC;IAED,IAAI,OAAO,CAAC,KAAK,CAAC,KAAK,YAAY,IAAI,CAAC,CAAC,SAAS,IAAI,CAAC,SAAS,IAAI,KAAK,KAAK,IAAI,CAAC,CAAC,EAAE,CAAC;QACnF,IAAI,UAAU,GAAG,IAAI,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,IAAI,KAAK,CAAC,WAAW,IAAI,KAAK,KAAK,CAAC,WAAW,CAAC,IAAI,GAAG,CAAC,IAAI,EAAE,EAAE,CAAC;QACrH,MAAM,IAAI,iBAAiB,CAAC,MAAM,YAAY,uBAAuB,UAAU,oBAAoB,KAAK,CAAC,WAAW,CAAC,IAAI,IAAI,KAAK,EAAE,CAAC,CAAC;IAC1I,CAAC;AACL,CAAC;AAED,SAAgB,kBAAkB,CAC9B,KAAU,EACV,IAIsB,EACtB,QAAa,EACb,KAAsB;IAEtB,IAAI,CAAC,CAAC,KAAK,YAAY,IAAI,CAAC,EAAE,CAAC;QAC3B,MAAM,IAAI,iBAAiB,CAAC,MAAM,IAAI,CAAC,IAAI,wBAAwB,KAAK,IAAK,KAAa,CAAC,WAAW,CAAC,IAAI,qBAAqB,QAAQ,CAAC,WAAW,CAAC,IAAI,IAAI,KAAK,EAAE,CAAC,CAAC;IAC1K,CAAC;AACL,CAAC","sourcesContent":["import type { Schema } from \"../Schema\";\r\nimport type { CollectionSchema } from \"../types/custom/CollectionSchema\";\r\nimport type { MapSchema } from \"../types/custom/MapSchema\";\r\nimport type { SetSchema } from \"../types/custom/SetSchema\";\r\nimport type { ArraySchema } from \"../types/custom/ArraySchema\";\r\nimport type { Ref } from \"../encoder/ChangeTree\";\r\n\r\nexport class EncodeSchemaError extends Error {}\r\n\r\nexport function assertType(value: any, type: string, klass: Schema, field: string | number) {\r\n    let typeofTarget: string;\r\n    let allowNull: boolean = false;\r\n\r\n    switch (type) {\r\n        case \"number\":\r\n        case \"int8\":\r\n        case \"uint8\":\r\n        case \"int16\":\r\n        case \"uint16\":\r\n        case \"int32\":\r\n        case \"uint32\":\r\n        case \"int64\":\r\n        case \"uint64\":\r\n        case \"float32\":\r\n        case \"float64\":\r\n            typeofTarget = \"number\";\r\n            if (isNaN(value)) {\r\n                console.log(`trying to encode \"NaN\" in ${klass.constructor.name}#${field}`);\r\n            }\r\n            break;\r\n        case \"bigint64\":\r\n        case \"biguint64\":\r\n            typeofTarget = \"bigint\";\r\n            break;\r\n        case \"string\":\r\n            typeofTarget = \"string\";\r\n            allowNull = true;\r\n            break;\r\n        case \"boolean\":\r\n            // boolean is always encoded as true/false based on truthiness\r\n            return;\r\n        default:\r\n            // skip assertion for custom types\r\n            // TODO: allow custom types to define their own assertions\r\n            return;\r\n    }\r\n\r\n    if (typeof (value) !== typeofTarget && (!allowNull || (allowNull && value !== null))) {\r\n        let foundValue = `'${JSON.stringify(value)}'${(value && value.constructor && ` (${value.constructor.name})`) || ''}`;\r\n        throw new EncodeSchemaError(`a '${typeofTarget}' was expected, but ${foundValue} was provided in ${klass.constructor.name}#${field}`);\r\n    }\r\n}\r\n\r\nexport function assertInstanceType(\r\n    value: Ref,\r\n    type: typeof Schema\r\n        | typeof ArraySchema\r\n        | typeof MapSchema\r\n        | typeof CollectionSchema\r\n        | typeof SetSchema,\r\n    instance: Ref,\r\n    field: string | number,\r\n) {\r\n    if (!(value instanceof type)) {\r\n        throw new EncodeSchemaError(`a '${type.name}' was expected, but '${value && (value as any).constructor.name}' was provided in ${instance.constructor.name}#${field}`);\r\n    }\r\n}"]}