{"version":3,"file":"parser.js","sourceRoot":"","sources":["../../src/codegen/parser.ts"],"names":[],"mappings":"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","sourcesContent":["import * as ts from \"typescript\";\r\nimport * as path from \"path\";\r\nimport {readFileSync} from \"fs\";\r\nimport {IStructure, Class, Interface, Property, Context, Enum} from \"./types\";\r\n\r\nlet currentStructure: IStructure;\r\nlet currentProperty: Property;\r\n\r\nlet globalContext: Context;\r\n\r\nfunction defineProperty(property: Property, initializer: any) {\r\n    if (ts.isIdentifier(initializer)) {\r\n        property.type = \"ref\";\r\n        property.childType = initializer.text;\r\n\r\n    } else if (initializer.kind == ts.SyntaxKind.ObjectLiteralExpression) {\r\n        property.type = initializer.properties[0].name.text;\r\n        property.childType = initializer.properties[0].initializer.text;\r\n\r\n    } else if (initializer.kind == ts.SyntaxKind.ArrayLiteralExpression) {\r\n        property.type = \"array\";\r\n        property.childType = initializer.elements[0].text;\r\n\r\n    } else {\r\n        property.type = initializer.text;\r\n    }\r\n}\r\n\r\nfunction inspectNode(node: ts.Node, context: Context, decoratorName: string) {\r\n    switch (node.kind) {\r\n        case ts.SyntaxKind.ImportClause:\r\n            const specifier = (node.parent as any).moduleSpecifier;\r\n            if (specifier && (specifier.text as string).startsWith('.')) {\r\n                const currentDir = path.dirname(node.getSourceFile().fileName);\r\n                const pathToImport = path.resolve(currentDir, specifier.text);\r\n                parseFiles([pathToImport], decoratorName, globalContext);\r\n            }\r\n            break;\r\n\r\n        case ts.SyntaxKind.ClassDeclaration:\r\n            currentStructure = new Class();\r\n\r\n            const heritageClauses = (node as ts.ClassLikeDeclarationBase).heritageClauses;\r\n            if (heritageClauses && heritageClauses.length > 0) {\r\n                (currentStructure as Class).extends = heritageClauses[0].types[0].expression.getText();\r\n            }\r\n\r\n            context.addStructure(currentStructure);\r\n            break;\r\n\r\n        case ts.SyntaxKind.InterfaceDeclaration:\r\n            //\r\n            // Only generate Interfaces if it has \"Message\" on its name.\r\n            // Example: MyMessage\r\n            //\r\n            const interfaceName = (node as ts.TypeParameterDeclaration).name.escapedText.toString();\r\n            if (interfaceName.indexOf(\"Message\") !== -1) {\r\n                currentStructure = new Interface();\r\n                currentStructure.name = interfaceName;\r\n\r\n                context.addStructure(currentStructure);\r\n            }\r\n            break;\r\n\r\n        case ts.SyntaxKind.EnumDeclaration:\r\n            const enumName = (\r\n                node as ts.EnumDeclaration\r\n            ).name.escapedText.toString();\r\n            currentStructure = new Enum();\r\n            currentStructure.name = enumName;\r\n            context.addStructure(currentStructure);\r\n            break;\r\n\r\n        case ts.SyntaxKind.ExtendsKeyword:\r\n            // console.log(node.getText());\r\n            break;\r\n\r\n        case ts.SyntaxKind.PropertySignature:\r\n            if (currentStructure instanceof Interface) {\r\n                const interfaceDeclaration = node.parent;\r\n\r\n                if (\r\n                    currentStructure.name !== (interfaceDeclaration as ts.TypeParameterDeclaration).name.escapedText.toString()\r\n                ) {\r\n                    // skip if property if for a another interface than the one we're interested in.\r\n                    break;\r\n                }\r\n\r\n                // define a property of an interface\r\n                const property = new Property();\r\n                property.name = (node as any).name.escapedText.toString();\r\n                property.type = (node as any).type.getText();\r\n                currentStructure.addProperty(property);\r\n            }\r\n            break;\r\n\r\n        case ts.SyntaxKind.Identifier:\r\n            if (\r\n                node.getText() === \"deprecated\" &&\r\n                node.parent.kind !== ts.SyntaxKind.ImportSpecifier\r\n            ) {\r\n                currentProperty = new Property();\r\n                currentProperty.deprecated = true;\r\n                break;\r\n            }\r\n\r\n            if (node.getText() === decoratorName) {\r\n                const prop: any = node.parent?.parent?.parent;\r\n                const propDecorator = getDecorators(prop);\r\n                const hasExpression = prop?.expression?.arguments;\r\n                const hasDecorator = (propDecorator?.length > 0);\r\n\r\n                /**\r\n                 * neither a `@type()` decorator or `type()` call. skip.\r\n                 */\r\n                if (!hasDecorator && !hasExpression) {\r\n                    break;\r\n                }\r\n\r\n                // using as decorator\r\n                if (propDecorator) {\r\n                    /**\r\n                     * Calling `@type()` as decorator\r\n                     */\r\n                    const typeDecorator: any = propDecorator.find((decorator => {\r\n                        return (decorator.expression as any).expression.escapedText === decoratorName;\r\n                    })).expression;\r\n\r\n                    const property = currentProperty || new Property();\r\n                    property.name = prop.name.escapedText;\r\n                    currentStructure.addProperty(property);\r\n\r\n                    const typeArgument = typeDecorator.arguments[0];\r\n                    defineProperty(property, typeArgument);\r\n\r\n                } else if (\r\n                    prop.expression.arguments?.[1] &&\r\n                    prop.expression.expression.arguments?.[0]\r\n                ) {\r\n                    /**\r\n                     * Calling `type()` as a regular method\r\n                     */\r\n                    const property = currentProperty || new Property();\r\n                    property.name = prop.expression.arguments[1].text;\r\n                    currentStructure.addProperty(property);\r\n\r\n                    const typeArgument = prop.expression.expression.arguments[0];\r\n                    defineProperty(property, typeArgument);\r\n                }\r\n\r\n            } else if (\r\n                node.getText() === \"setFields\" &&\r\n                (\r\n                    node.parent.kind === ts.SyntaxKind.CallExpression ||\r\n                    node.parent.kind === ts.SyntaxKind.PropertyAccessExpression\r\n                )\r\n            ) {\r\n                /**\r\n                 * Metadata.setFields(klassName, { ... })\r\n                 */\r\n                const callExpression = (node.parent.kind === ts.SyntaxKind.PropertyAccessExpression)\r\n                    ? node.parent.parent as ts.CallExpression\r\n                    : node.parent as ts.CallExpression;\r\n\r\n                /**\r\n                 * Skip if @codegen-ignore comment is found before the call expression\r\n                 * TODO: currently, if @codegen-ignore is on the file, it will skip all the setFields calls.\r\n                 */\r\n                const sourceFile = node.getSourceFile();\r\n                const fullText = sourceFile.getFullText();\r\n                const nodeStart = callExpression.getFullStart();\r\n                const textBeforeNode = fullText.substring(0, nodeStart);\r\n                if (textBeforeNode.includes('@codegen-ignore')) {\r\n                    break;\r\n                }\r\n\r\n                if (callExpression.kind !== ts.SyntaxKind.CallExpression) {\r\n                    break;\r\n                }\r\n\r\n                const classNameNode = callExpression.arguments[0];\r\n                const className = ts.isClassExpression(classNameNode)\r\n                    ? classNameNode.name?.escapedText.toString()\r\n                    : classNameNode.getText();\r\n\r\n                // skip if no className is provided\r\n                if (!className) { break; }\r\n\r\n                if (currentStructure?.name !== className) {\r\n                    currentStructure = new Class();\r\n                }\r\n                context.addStructure(currentStructure);\r\n                (currentStructure as Class).extends = \"Schema\"; // force extends to Schema\r\n                currentStructure.name = className;\r\n\r\n                const types = callExpression.arguments[1] as any;\r\n                for (let i = 0; i < types.properties.length; i++) {\r\n                    const prop = types.properties[i];\r\n\r\n                    const property = currentProperty || new Property();\r\n                    property.name = prop.name.escapedText;\r\n\r\n                    currentStructure.addProperty(property);\r\n                    defineProperty(property, prop.initializer);\r\n                }\r\n\r\n            } else if (\r\n                node.getText() === \"defineTypes\" &&\r\n                (\r\n                    node.parent.kind === ts.SyntaxKind.CallExpression ||\r\n                    node.parent.kind === ts.SyntaxKind.PropertyAccessExpression\r\n                )\r\n            ) {\r\n                /**\r\n                 * JavaScript source file (`.js`)\r\n                 * Using `defineTypes()`\r\n                 */\r\n                const callExpression = (node.parent.kind === ts.SyntaxKind.PropertyAccessExpression)\r\n                    ? node.parent.parent as ts.CallExpression\r\n                    : node.parent as ts.CallExpression;\r\n\r\n                if (callExpression.kind !== ts.SyntaxKind.CallExpression) {\r\n                    break;\r\n                }\r\n\r\n                const className = callExpression.arguments[0].getText()\r\n                currentStructure.name = className;\r\n\r\n                const types = callExpression.arguments[1] as any;\r\n                for (let i = 0; i < types.properties.length; i++) {\r\n                    const prop = types.properties[i];\r\n\r\n                    const property = currentProperty || new Property();\r\n                    property.name = prop.name.escapedText;\r\n                    currentStructure.addProperty(property);\r\n\r\n                    defineProperty(property, prop.initializer);\r\n                }\r\n\r\n            }\r\n\r\n            if (node.parent.kind === ts.SyntaxKind.ClassDeclaration) {\r\n                currentStructure.name = node.getText();\r\n            }\r\n\r\n            currentProperty = undefined;\r\n\r\n            break;\r\n\r\n        case ts.SyntaxKind.CallExpression:\r\n            /**\r\n             * Defining schema via `schema.schema({ ... })`\r\n             * - schema.schema({})\r\n             * - schema({})\r\n             * - ClassName.extends({})\r\n             */\r\n            if (\r\n                (\r\n                    (\r\n                        (node as ts.CallExpression).expression?.getText() === \"schema.schema\" ||\r\n                        (node as ts.CallExpression).expression?.getText() === \"schema\"\r\n                    ) ||\r\n                    (\r\n                        (node as ts.CallExpression).expression?.getText().indexOf(\".extends\") !== -1\r\n                    )\r\n                ) &&\r\n                (node as ts.CallExpression).arguments[0].kind === ts.SyntaxKind.ObjectLiteralExpression\r\n            ) {\r\n                const callExpression = node as ts.CallExpression;\r\n\r\n                let className = callExpression.arguments[1]?.getText();\r\n\r\n                if (!className && callExpression.parent.kind === ts.SyntaxKind.VariableDeclaration) {\r\n                    className = (callExpression.parent as ts.VariableDeclaration).name?.getText();\r\n                }\r\n\r\n                // skip if no className is provided\r\n                if (!className) { break; }\r\n\r\n                if (currentStructure?.name !== className) {\r\n                    currentStructure = new Class();\r\n                    context.addStructure(currentStructure);\r\n                }\r\n\r\n                if ((node as ts.CallExpression).expression?.getText().indexOf(\".extends\") !== -1) {\r\n                    // if it's using `.extends({})`\r\n                    const extendsClass = (node as any).expression?.expression?.escapedText;\r\n\r\n                    // skip if no extendsClass is provided\r\n                    if (!extendsClass) { break; }\r\n                    (currentStructure as Class).extends = extendsClass;\r\n\r\n                } else {\r\n                    // if it's using `schema({})`\r\n                    (currentStructure as Class).extends = \"Schema\"; // force extends to Schema\r\n                }\r\n\r\n                currentStructure.name = className;\r\n\r\n                const types = callExpression.arguments[0] as any;\r\n                for (let i = 0; i < types.properties.length; i++) {\r\n                    const prop = types.properties[i];\r\n\r\n                    const property = currentProperty || new Property();\r\n                    property.name = prop.name.escapedText;\r\n\r\n                    currentStructure.addProperty(property);\r\n                    defineProperty(property, prop.initializer);\r\n                }\r\n            }\r\n\r\n            break;\r\n\r\n        case ts.SyntaxKind.EnumMember:\r\n            if (currentStructure instanceof Enum) {\r\n                const initializer = (node as any).initializer?.text;\r\n                const name = node.getFirstToken().getText();\r\n                const property = currentProperty || new Property();\r\n                property.name = name;\r\n                if (initializer !== undefined) {\r\n                    property.type = initializer;\r\n                }\r\n                currentStructure.addProperty(property);\r\n                currentProperty = undefined;\r\n            }\r\n            break;\r\n    }\r\n\r\n    ts.forEachChild(node, (n) => inspectNode(n, context, decoratorName));\r\n}\r\n\r\nlet parsedFiles: { [filename: string]: boolean };\r\n\r\nexport function parseFiles(\r\n    fileNames: string[],\r\n    decoratorName: string = \"type\",\r\n    context: Context = new Context()\r\n) {\r\n    /**\r\n     * Re-set globalContext for each test case\r\n     */\r\n    if (globalContext !== context) {\r\n        parsedFiles = {};\r\n        globalContext = context;\r\n    }\r\n\r\n    fileNames.forEach((fileName) => {\r\n        let sourceFile: ts.Node;\r\n        let sourceFileName: string;\r\n\r\n        const fileNameAlternatives = [];\r\n\r\n        if (\r\n            !fileName.endsWith(\".ts\") &&\r\n            !fileName.endsWith(\".js\") &&\r\n            !fileName.endsWith(\".mjs\")\r\n        ) {\r\n            fileNameAlternatives.push(`${fileName}.ts`);\r\n            fileNameAlternatives.push(`${fileName}/index.ts`);\r\n\r\n        } else {\r\n            fileNameAlternatives.push(fileName);\r\n        }\r\n\r\n        for (let i = 0; i < fileNameAlternatives.length; i++) {\r\n            try {\r\n                sourceFileName = path.resolve(fileNameAlternatives[i]);\r\n\r\n                if (parsedFiles[sourceFileName]) {\r\n                    break;\r\n                }\r\n\r\n                sourceFile = ts.createSourceFile(\r\n                    sourceFileName,\r\n                    readFileSync(sourceFileName).toString(),\r\n                    ts.ScriptTarget.Latest,\r\n                    true\r\n                );\r\n\r\n                parsedFiles[sourceFileName] = true;\r\n\r\n                break;\r\n            } catch (e) {\r\n                // console.log(`${fileNameAlternatives[i]} => ${e.message}`);\r\n            }\r\n        }\r\n\r\n        if (sourceFile) {\r\n            inspectNode(sourceFile, context, decoratorName);\r\n        }\r\n    });\r\n\r\n    return context.getStructures();\r\n}\r\n\r\n/**\r\n * TypeScript 4.8+ has introduced a change on how to access decorators.\r\n * - https://github.com/microsoft/TypeScript/pull/49089\r\n * - https://devblogs.microsoft.com/typescript/announcing-typescript-4-8/#decorators-are-placed-on-modifiers-on-typescripts-syntax-trees\r\n */\r\nexport function getDecorators(node: ts.Node | null | undefined,): undefined | ts.Decorator[] {\r\n    if (node == undefined) { return undefined; }\r\n\r\n    // TypeScript 4.7 and below\r\n    // @ts-ignore\r\n    if (node.decorators) { return node.decorators; }\r\n\r\n    // TypeScript 4.8 and above\r\n    // @ts-ignore\r\n    if (ts.canHaveDecorators && ts.canHaveDecorators(node)) {\r\n        // @ts-ignore\r\n        const decorators = ts.getDecorators(node);\r\n        return decorators ? Array.from(decorators) : undefined;\r\n    }\r\n\r\n    // @ts-ignore\r\n    return node.modifiers?.filter(ts.isDecorator);\r\n}\r\n"]}