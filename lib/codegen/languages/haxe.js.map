{"version":3,"file":"haxe.js","sourceRoot":"","sources":["../../../src/codegen/languages/haxe.ts"],"names":[],"mappings":"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","sourcesContent":["import { Class, Property, File, getCommentHeader, Context } from \"../types\";\r\nimport { GenerateOptions } from \"../api\";\r\n\r\nconst typeMaps: { [key: string]: string } = {\r\n    \"string\": \"String\",\r\n    \"number\": \"Dynamic\",\r\n    \"boolean\": \"Bool\",\r\n    \"int8\": \"Int\",\r\n    \"uint8\": \"UInt\",\r\n    \"int16\": \"Int\",\r\n    \"uint16\": \"UInt\",\r\n    \"int32\": \"Int\",\r\n    \"uint32\": \"UInt\",\r\n    \"int64\": \"Int\",\r\n    \"uint64\": \"UInt\",\r\n    \"float32\": \"Float\",\r\n    \"float64\": \"Float\",\r\n}\r\n\r\nconst typeInitializer: { [key: string]: string } = {\r\n    \"string\": '\"\"',\r\n    \"number\": \"0\",\r\n    \"boolean\": \"false\",\r\n    \"int8\": \"0\",\r\n    \"uint8\": \"0\",\r\n    \"int16\": \"0\",\r\n    \"uint16\": \"0\",\r\n    \"int32\": \"0\",\r\n    \"uint32\": \"0\",\r\n    \"int64\": \"0\",\r\n    \"uint64\": \"0\",\r\n    \"float32\": \"0\",\r\n    \"float64\": \"0\",\r\n}\r\n\r\nexport function generate (context: Context, options: GenerateOptions): File[] {\r\n    return context.classes.map(klass => ({\r\n        name: klass.name + \".hx\",\r\n        content: generateClass(klass, options.namespace, context.classes)\r\n    }));\r\n}\r\n\r\nfunction getInheritanceTree(klass: Class, allClasses: Class[], includeSelf: boolean = true) {\r\n    let currentClass = klass;\r\n    let inheritanceTree: Class[] = [];\r\n\r\n    if (includeSelf) {\r\n        inheritanceTree.push(currentClass);\r\n    }\r\n\r\n    while (currentClass.extends !== \"Schema\") {\r\n        currentClass = allClasses.find(klass => klass.name == currentClass.extends);\r\n        inheritanceTree.push(currentClass);\r\n    }\r\n\r\n    return inheritanceTree;\r\n}\r\n\r\nfunction generateClass(klass: Class, namespace: string, allClasses: Class[]) {\r\n    return `${getCommentHeader()}\r\n\r\n${namespace ? `package ${namespace};` : \"\"}\r\nimport io.colyseus.serializer.schema.Schema;\r\nimport io.colyseus.serializer.schema.types.*;\r\n\r\nclass ${klass.name} extends ${klass.extends} {\r\n${klass.properties.map(prop => generateProperty(prop)).join(\"\\n\")}\r\n}\r\n`;\r\n}\r\n\r\nfunction generateProperty(prop: Property) {\r\n    let langType: string;\r\n    let initializer = \"\";\r\n    let typeArgs = `\"${prop.type}\"`;\r\n\r\n    if (prop.childType) {\r\n        const isUpcaseFirst = prop.childType.match(/^[A-Z]/);\r\n\r\n        if (isUpcaseFirst) {\r\n            typeArgs += `, ${prop.childType}`;\r\n\r\n        } else {\r\n            typeArgs += `, \"${prop.childType}\"`;\r\n        }\r\n\r\n        if(prop.type === \"ref\") {\r\n            langType = `${prop.childType}`;\r\n            initializer = `new ${prop.childType}()`;\r\n\r\n        } else if(prop.type === \"array\") {\r\n            langType = (isUpcaseFirst)\r\n                ? `ArraySchema<${prop.childType}>`\r\n                : `ArraySchema<${typeMaps[prop.childType]}>`;\r\n            initializer = `new ${langType}()`;\r\n\r\n        } else if(prop.type === \"map\") {\r\n            langType = (isUpcaseFirst)\r\n                ? `MapSchema<${prop.childType}>`\r\n                : `MapSchema<${typeMaps[prop.childType]}>`;\r\n            initializer = `new ${langType}()`;\r\n        }\r\n\r\n    } else {\r\n        langType = typeMaps[prop.type];\r\n        initializer = typeInitializer[prop.type];\r\n    }\r\n\r\n    // TODO: remove initializer. The callbacks at the Haxe decoder side have a\r\n    // \"FIXME\" comment about this on Decoder.hx\r\n\r\n    return `\\t@:type(${typeArgs})\\n\\tpublic var ${prop.name}: ${langType} = ${initializer};\\n`\r\n    // return `\\t@:type(${typeArgs})\\n\\tpublic var ${prop.name}: ${langType};\\n`\r\n}\r\n"]}