{"version":3,"file":"cpp.js","sourceRoot":"","sources":["../../../src/codegen/languages/cpp.ts"],"names":[],"mappings":"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","sourcesContent":["import { Class, Property, File, getCommentHeader, getInheritanceTree, Context } from \"../types\";\r\nimport { GenerateOptions } from \"../api\";\r\n\r\nconst typeMaps: { [key: string]: string } = {\r\n    \"string\": \"string\",\r\n    \"number\": \"varint_t\",\r\n    \"boolean\": \"bool\",\r\n    \"int8\": \"int8_t\",\r\n    \"uint8\": \"uint8_t\",\r\n    \"int16\": \"int16_t\",\r\n    \"uint16\": \"uint16_t\",\r\n    \"int32\": \"int32_t\",\r\n    \"uint32\": \"uint32_t\",\r\n    \"int64\": \"int64_t\",\r\n    \"uint64\": \"uint64_t\",\r\n    \"float32\": \"float32_t\",\r\n    \"float64\": \"float64_t\",\r\n}\r\n\r\nconst typeInitializer: { [key: string]: string } = {\r\n    \"string\": '\"\"',\r\n    \"number\": \"0\",\r\n    \"boolean\": \"false\",\r\n    \"int8\": \"0\",\r\n    \"uint8\": \"0\",\r\n    \"int16\": \"0\",\r\n    \"uint16\": \"0\",\r\n    \"int32\": \"0\",\r\n    \"uint32\": \"0\",\r\n    \"int64\": \"0\",\r\n    \"uint64\": \"0\",\r\n    \"float32\": \"0\",\r\n    \"float64\": \"0\",\r\n}\r\n\r\n/**\r\n * C++ Code Generator\r\n */\r\n\r\nconst capitalize = (s: string) => {\r\n    if (typeof s !== 'string') return ''\r\n    return s.charAt(0).toUpperCase() + s.slice(1);\r\n}\r\nconst distinct = (value: string, index: number, self: string[]) =>\r\n    self.indexOf(value) === index;\r\n\r\nexport function generate (context: Context, options: GenerateOptions): File[] {\r\n    return context.classes.map(klass => ({\r\n        name: klass.name + \".hpp\",\r\n        content: generateClass(klass, options.namespace, context.classes)\r\n    }));\r\n}\r\n\r\nfunction generateClass(klass: Class, namespace: string, allClasses: Class[]) {\r\n    const propertiesPerType: {[type: string]: Property[]} = {};\r\n    const allRefs: Property[] = [];\r\n    klass.properties.forEach(property => {\r\n        let type = property.type;\r\n\r\n        if (!propertiesPerType[type]) {\r\n            propertiesPerType[type] = [];\r\n        }\r\n\r\n        propertiesPerType[type].push(property);\r\n\r\n        // keep all refs list\r\n        if ((type === \"ref\" || type === \"array\" || type === \"map\")) {\r\n            allRefs.push(property);\r\n        }\r\n    });\r\n\r\n    const allProperties = getAllProperties(klass, allClasses);\r\n    const createInstanceMethod = (allRefs.length === 0) ? \"\" :\r\n    `\\tinline Schema* createInstance(std::type_index type) {\r\n\\t\\t${generateFieldIfElseChain(allRefs,\r\n    (property) => `type == typeid(${property.childType})`,\r\n    (property) => `return new ${property.childType}();`,\r\n    (property) => typeMaps[property.childType] === undefined)}\r\n\\t\\treturn ${klass.extends}::createInstance(type);\r\n\\t}`;\r\n\r\n    return `${getCommentHeader()}\r\n#ifndef __SCHEMA_CODEGEN_${klass.name.toUpperCase()}_H__\r\n#define __SCHEMA_CODEGEN_${klass.name.toUpperCase()}_H__ 1\r\n\r\n#include \"schema.h\"\r\n#include <typeinfo>\r\n#include <typeindex>\r\n\r\n${allRefs.\r\n    filter(ref => ref.childType && typeMaps[ref.childType] === undefined).\r\n    map(ref => ref.childType).\r\n    concat(getInheritanceTree(klass, allClasses, false).map(klass => klass.name)).\r\n    filter(distinct).\r\n    map(childType => `#include \"${childType}.hpp\"`).\r\n    join(\"\\n\")}\r\n\r\nusing namespace colyseus::schema;\r\n\r\n${namespace ? `namespace ${namespace} {` : \"\"}\r\nclass ${klass.name} : public ${klass.extends} {\r\npublic:\r\n${klass.properties.map(prop => generateProperty(prop)).join(\"\\n\")}\r\n\r\n\\t${klass.name}() {\r\n\\t\\tthis->_indexes = ${generateAllIndexes(allProperties)};\r\n\\t\\tthis->_types = ${generateAllTypes(allProperties)};\r\n\\t\\tthis->_childPrimitiveTypes = ${generateAllChildPrimitiveTypes(allProperties)};\r\n\\t\\tthis->_childSchemaTypes = ${generateAllChildSchemaTypes(allProperties)};\r\n\\t}\r\n\r\n\\tvirtual ~${klass.name}() {\r\n\\t\\t${generateDestructors(allProperties).join(\"\\n\\t\\t\")}\r\n\\t}\r\n\r\nprotected:\r\n${Object.keys(propertiesPerType).map(type =>\r\n    generateGettersAndSetters(klass, type, propertiesPerType[type])).\r\n    join(\"\\n\")}\r\n\r\n${createInstanceMethod}\r\n};\r\n${namespace ? \"}\" : \"\"}\r\n\r\n#endif\r\n`;\r\n}\r\n\r\nfunction generateProperty(prop: Property) {\r\n    let property = \"\";\r\n    let langType: string;\r\n    let initializer = \"\";\r\n    let isPropPointer = \"\";\r\n\r\n    if (prop.childType) {\r\n        const isUpcaseFirst = prop.childType.match(/^[A-Z]/);\r\n\r\n        if(prop.type === \"ref\") {\r\n            langType = `${prop.childType}`;\r\n            initializer = `new ${prop.childType}()`;\r\n\r\n        } else if(prop.type === \"array\") {\r\n            langType = (isUpcaseFirst)\r\n                ? `ArraySchema<${prop.childType}*>`\r\n                : `ArraySchema<${typeMaps[prop.childType]}>`;\r\n            initializer = `new ${langType}()`;\r\n\r\n        } else if(prop.type === \"map\") {\r\n            langType = (isUpcaseFirst)\r\n                ? `MapSchema<${prop.childType}*>`\r\n                : `MapSchema<${typeMaps[prop.childType]}>`;\r\n            initializer = `new ${langType}()`;\r\n        }\r\n        isPropPointer = \"*\";\r\n\r\n    } else {\r\n        langType = typeMaps[prop.type];\r\n        initializer = typeInitializer[prop.type];\r\n    }\r\n\r\n    property += ` ${langType} ${isPropPointer}${prop.name}`;\r\n\r\n    return `\\t${property} = ${initializer};`\r\n}\r\n\r\nfunction generateGettersAndSetters(klass: Class, type: string, properties: Property[]) {\r\n    let langType = typeMaps[type];\r\n    let typeCast = \"\";\r\n\r\n    const getMethodName = `get${capitalize(type)}`;\r\n    const setMethodName = `set${capitalize(type)}`;\r\n\r\n    if (type === \"ref\") {\r\n        langType = \"Schema*\";\r\n\r\n    } else if (type === \"array\") {\r\n        langType = `ArraySchema<char*> *`;\r\n        typeCast = `(ArraySchema<char*> *)`;\r\n\r\n    } else if (type === \"map\") {\r\n        langType = `MapSchema<char*> *`;\r\n        typeCast = `(MapSchema<char*> *)`;\r\n    }\r\n\r\n    return `\\tinline ${langType} ${getMethodName}(const string &field)\r\n\\t{\r\n\\t\\t${generateFieldIfElseChain(properties,\r\n    (property) => `field == \"${property.name}\"`,\r\n    (property) => `return ${typeCast}this->${property.name};`)}\r\n\\t\\treturn ${klass.extends}::${getMethodName}(field);\r\n\\t}\r\n\r\n\\tinline void ${setMethodName}(const string &field, ${langType} value)\r\n\\t{\r\n\\t\\t${generateFieldIfElseChain(properties,\r\n    (property) => `field == \"${property.name}\"`,\r\n    (property) => {\r\n        const isSchemaType = (typeMaps[property.childType] === undefined)\r\n\r\n        if (type === \"ref\") {\r\n            langType = `${property.childType}*`;\r\n            typeCast = (isSchemaType)\r\n                ? `(${property.childType}*)`\r\n                : `/* bug? */`;\r\n\r\n        } else if (type === \"array\") {\r\n            typeCast = (isSchemaType)\r\n                ? `(ArraySchema<${property.childType}*> *)`\r\n                : `(ArraySchema<${typeMaps[property.childType]}> *)`;\r\n\r\n        } else if (type === \"map\") {\r\n            typeCast = (isSchemaType)\r\n                ? `(MapSchema<${property.childType}*> *)`\r\n                : `(MapSchema<${typeMaps[property.childType]}> *)`;\r\n        }\r\n\r\n        return `this->${property.name} = ${typeCast}value;\\n\\t\\t\\treturn;`\r\n    })}\r\n\\t\\treturn ${klass.extends}::${setMethodName}(field, value);\r\n\\t}`;\r\n}\r\n\r\nfunction generateFieldIfElseChain(\r\n    properties: Property[],\r\n    ifCallback: (property: Property) => string,\r\n    callback: (property: Property) => string,\r\n    filter: (property: Property) => boolean = (_) => true,\r\n) {\r\n    let chain = \"\";\r\n\r\n    const uniqueChecks: string[] = [];\r\n    properties.filter(filter).forEach((property, i) => {\r\n        const check = ifCallback(property);\r\n        if (uniqueChecks.indexOf(check) === -1) {\r\n            uniqueChecks.push(check);\r\n\r\n        } else {\r\n            return;\r\n        }\r\n\r\n        if (i === 0) { chain += \"if \" } else { chain += \" else if \" }\r\n        chain += `(${check})\r\n\\t\\t{\r\n\\t\\t\\t${callback(property)}\\n\r\n\\t\\t}`\r\n    });\r\n\r\n    return chain;\r\n}\r\n\r\nfunction generateAllIndexes(properties: Property[]) {\r\n    return `{${properties.map((property, i) => `{${i}, \"${property.name}\"}`).join(\", \")}}`\r\n\r\n}\r\n\r\nfunction generateAllTypes(properties: Property[]) {\r\n    return `{${properties.map((property, i) => `{${i}, \"${property.type}\"}`).join(\", \")}}`\r\n}\r\n\r\nfunction generateAllChildSchemaTypes(properties: Property[]) {\r\n    return `{${properties.map((property, i) => {\r\n        if (property.childType && typeMaps[property.childType] === undefined) {\r\n            return `{${i}, typeid(${property.childType})}`\r\n        } else {\r\n            return null;\r\n        }\r\n    }).filter(r => r !== null).join(\", \")}}`\r\n}\r\n\r\nfunction generateAllChildPrimitiveTypes(properties: Property[]) {\r\n    return `{${properties.map((property, i) => {\r\n        if (typeMaps[property.childType] !== undefined) {\r\n            return `{${i}, \"${property.childType}\"}`\r\n        } else {\r\n            return null;\r\n        }\r\n    }).filter(r => r !== null).join(\", \")}}`\r\n}\r\n\r\nfunction generateDestructors(properties: Property[]) {\r\n    return properties.map((property, i) => {\r\n        if (property.childType) {\r\n            return `delete this->${property.name};`;\r\n        } else {\r\n            return null;\r\n        }\r\n    }).filter(r => r !== null);\r\n}\r\n\r\nfunction getAllProperties (klass: Class, allClasses: Class[]) {\r\n    let properties: Property[] = [];\r\n\r\n    getInheritanceTree(klass, allClasses).reverse().forEach((klass) => {\r\n        properties = properties.concat(klass.properties);\r\n    });\r\n\r\n    return properties;\r\n}"]}